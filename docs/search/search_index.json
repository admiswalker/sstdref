{"config":{"lang":["en","ja"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":".img_overlay { /* parent div */ position: relative; } .img_overlay p { position: absolute; font-size: 40px; font-weight: normal; color: white; /* string color */ top: 0; left: 0; margin:0; padding:0; margin-top:-5px; } .img_overlay img { width: 100%; } SubStandardLibrary What is SSTD ? SubStandardLibrary (SSTD) is a convenient functions set for C++, works on GCC (g++). Installation Downloading source code from github.com/admiswalker/SubStandardLibrary . Copying all of under ./sstd/*. Compilling the sstd. $ cd ./sstd $ make Adding flags in your makefile. CFLAGS += -I./sstd/include -L./sstd/lib -lsstd CFLAGS += -std=gnu++0x Including a header #include <sstd/sstd.hpp> in your code. License MIT licence or Public domain. (This software is dual license, so you can choose whichever you want). Repository Source code: github.com/admiswalker/SubStandardLibrary Documentation: github.com/admiswalker/sstdref","title":"What is SSTD ?"},{"location":"index.html#what-is-sstd","text":"SubStandardLibrary (SSTD) is a convenient functions set for C++, works on GCC (g++).","title":"What is SSTD ?"},{"location":"index.html#installation","text":"Downloading source code from github.com/admiswalker/SubStandardLibrary . Copying all of under ./sstd/*. Compilling the sstd. $ cd ./sstd $ make Adding flags in your makefile. CFLAGS += -I./sstd/include -L./sstd/lib -lsstd CFLAGS += -std=gnu++0x Including a header #include <sstd/sstd.hpp> in your code.","title":"Installation"},{"location":"index.html#license","text":"MIT licence or Public domain. (This software is dual license, so you can choose whichever you want).","title":"License"},{"location":"index.html#repository","text":"Source code: github.com/admiswalker/SubStandardLibrary Documentation: github.com/admiswalker/sstdref","title":"Repository"},{"location":"src/c2py.html","text":"c2py Abstract c2py() calls any Python functions with built-in, std::vector<T> , sstd::mat_c<T> and sstd::mat_r<T> ( T is limitted by built-in types.) types of arguments from 2 lines of C++ codes. Data is sharing by the tmp directory. c2py() \u306f built-in \u578b\uff0c std::vector<T> \u578b, sstd::mat_c<T> \u578b\uff0c\u304a\u3088\u3073 sstd::mat_r<T> \u578b (\u305f\u3060\u3057\uff0c T \u306f built-in \u578b\u306b\u5236\u9650\u3055\u308c\u308b\uff0e) \u3092\u5f15\u6570\u306b\u6301\u3064 Python \u95a2\u6570\u3092 2 \u884c\u306e C++ \u30b3\u30fc\u30c9\u3067\u547c\u3073\u51fa\u3057\u307e\u3059\uff0e \u30c7\u30fc\u30bf\u306f tmp \u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306b\u3088\u308a\u5171\u6709\u3055\u308c\u307e\u3059\uff0e Header file namespace sstd { template < typename T > class c2py ; } template < typename T > class sstd :: c2py { public : c2py ( const char * temporarilyDir , const char * importFile , const char * functionName , const char * format ); ~ c2py (); template < typename ... ARGS > T operator ()( ARGS ... args ); }; c2py interface sstd :: c2py < ATypeOfReturnValue > FunctionName ( \"Tempolary directory\" , // Argument 1 \"A name of calling .py file (without extension)\" , // Argument 2 \"A function name calling from .py file\" , // Argument 3 \"Arguments types specification of Python function\" ); // Argument 4 c2py \u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u306e\u8a2d\u8a08 sstd :: c2py < \u623b\u308a\u5024\u306e\u578b > \u95a2\u6570\u540d ( \"\u4e00\u6642\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\" , // \u7b2c 1 \u5f15\u6570 \"\u547c\u3073\u51fa\u3057\u5148\u306e .py \u30d5\u30a1\u30a4\u30eb (\u305f\u3060\u3057\u62e1\u5f35\u5b50\u3092\u9664\u304f)\" , // \u7b2c 2 \u5f15\u6570 \".py \u30d5\u30a1\u30a4\u30eb\u4e2d\u304b\u3089\u547c\u3073\u51fa\u3059\u95a2\u6570\u540d\" , // \u7b2c 3 \u5f15\u6570 \"Python \u95a2\u6570\u306e\u578b\u6307\u5b9a\" ); // \u7b2c 4 \u5f15\u6570 Requirements c2py() requires the importlib , inspect , itertools , numpy , os and sys Python packages. See sstd/src/c2py.py for details. c2py() \u306f\uff0c importlib , inspect , itertools , numpy , os , sys \u306e Python \u30d1\u30c3\u30b1\u30fc\u30b8\u3092\u5fc5\u8981\u3068\u3057\u307e\u3059\uff0e\u8a73\u7d30\u306f sstd/src/c2py.py \u3092\u53c2\u7167\u3059\u308b\u3053\u3068\uff0e List of corresponding types. (\u5bfe\u5fdc\u3059\u308b\u578b\u306e\u4e00\u89a7) Table 1. shows the correspondence between the types on the C ++ side and the types on the Python side. Table 2. shows a list of type names given when specifying a type on the C ++ side. If not specifying type on the Python side, numpy will be selected. And selecting the conversion symbol ~ , the numpy type will be converted to the built-in type. The c2py is basically processed by numpy, because of the binary compatibility between C++ and Python, type conversion of numpy to built-in type will be overhead. \u8868 1. \u306b C++ \u5074\u306e\u578b\u3068\uff0cPython \u5074\u306e\u578b\u3068\u306e\u5bfe\u5fdc\u3092\u793a\u3059\uff0e \u8868 2. \u306b C++ \u5074\u306e\u578b\u3092\u6307\u5b9a\u3059\u308b\u969b\u306b\u4e0e\u3048\u308b\u578b\u540d\u306e\u4e00\u89a7\u3092\u793a\u3059\uff0e Python \u5074\u306e\u578b\u306b\u3064\u3044\u3066\uff0c\u4f55\u3082\u6307\u5b9a\u3057\u306a\u3044\u5834\u5408\u306f\uff0cnumpy \u578b\u304c\u9078\u629e\u3055\u308c\uff0c\u5909\u63db\u8a18\u53f7 ~ \u3092\u6307\u5b9a\u3059\u308b\u3053\u3068\u3067\uff0cbuilt-in \u578b\u306b\u5909\u63db\u3055\u308c\u308b\uff0e c2py \u4e0a\u306e\u51e6\u7406\u306f\uff0cC++ \u3068\u306e\u30d0\u30a4\u30ca\u30ea\u4e92\u63db\u6027\u306e\u554f\u984c\u304b\u3089\uff0c\u57fa\u672c\u7684\u306b numpy \u578b\u3067\u884c\u308f\u308c\u308b\u305f\u3081\uff0cbuilt-in \u578b\u3078\u306e\u5909\u63db\u306f\uff0c\u30aa\u30fc\u30d0\u30fc\u30d8\u30c3\u30c9\u3068\u306a\u308b\uff0e Table 1. Correspondence between types implemented in c2py and Python \u8868 1. c2py \u3067\u5b9f\u88c5\u3055\u308c\u3066\u3044\u308b\u578b\u3068 Python \u578b\u3068\u306e\u5bfe\u5fdc Types of C++ side Types of Python side Entity / Pointer / Pointer array Entity / Pointer Entity / Pointer Entity / Pointer Entity / Pointer bool std::vector<bool> sstd::mat_c<bool> sstd::mat_r<bool> numpy / built-in char std::vector<char> sstd::mat_c<char> sstd::mat_r<char> built-in uchar std::vector<uchar> sstd::mat_c<uchar> sstd::mat_r<uchar> built-in int8 std::vector<int8> sstd::mat_c<int8> sstd::mat_r<int8> numpy / built-in int16 std::vector<int16> sstd::mat_c<int16> sstd::mat_r<int16> numpy / built-in int32 std::vector<int32> sstd::mat_c<int32> sstd::mat_r<int32> numpy / built-in int64 std::vector<int64> sstd::mat_c<int64> sstd::mat_r<int64> numpy / built-in uint8 std::vector<uint8> sstd::mat_c<uint8> sstd::mat_r<uint8> numpy / built-in uint16 std::vector<uint16> sstd::mat_c<uint16> sstd::mat_r<uint16> numpy / built-in uint32 std::vector<uint32> sstd::mat_c<uint32> sstd::mat_r<uint32> numpy / built-in uint64 std::vector<uint64> sstd::mat_c<uint64> sstd::mat_r<uint64> numpy / built-in float std::vector<float> sstd::mat_c<float> sstd::mat_r<float> numpy / built-in double std::vector<double> sstd::mat_c<double> sstd::mat_r<double> numpy / built-in std::string std::vector<std::string> sstd::mat_c<std::string> sstd::mat_r<std::string> built-in Table 2. Type names giving to the 4th argument of c2py. \u8868 2. c2py \u306e\u7b2c 4 \u5f15\u6570\u306b\u4e0e\u3048\u308b\u578b\u540d\uff0e Types of C++ side Entity / Pointer / Pointer array Entity / Pointer Entity / Pointer Entity / Pointer bool vec<bool> mat_c<bool> mat_r<bool> char vec<char> mat_c<char> mat_r<char> uchar vec<uchar> mat_c<uchar> mat_r<uchar> int8 vec<int8> mat_c<int8> mat_r<int8> int16 vec<int16> mat_c<int16> mat_r<int16> int32 vec<int32> mat_c<int32> mat_r<int32> int64 vec<int64> mat_c<int64> mat_r<int64> uint8 vec<uint8> mat_c<uint8> mat_r<uint8> uint16 vec<uint16> mat_c<uint16> mat_r<uint16> uint32 vec<uint32> mat_c<uint32> mat_r<uint32> uint64 vec<uint64> mat_c<uint64> mat_r<uint64> float vec<float> mat_c<float> mat_r<float> double vec<double> mat_c<double> mat_r<double> str / string vec<str> / vec<string> mat_c<str> / mat_c<string> mat_r<str> / mat_r<string> Usage Sample1: (Return: \"int\" / Input: \"int\" and \"const int*\") pyFunction.py def plus_a_b ( a , b ): return a + b main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"echo 'def plus_a_b(a, b): return a+b' > ./tmp/pyFunction.py\" ); sstd :: c2py < int > plus_a_b ( \"./tmpDir\" , \"./tmp/pyFunction\" , \"plus_a_b\" , \"int, int, const int*\" ); int a = 1 , b = 2 ; int c = plus_a_b ( a , & b ); // Running Python here sstd :: printn ( c ); sstd :: rm ( \"./tmp\" ); return 0 ; } Execution result c = 3 Sample2: (Return: \"vec<int>\" / Input: \"const int*\", \"len\" and \"const vec<int>*\") pyFunction.py def plus_vecA_vecB ( vecA , vecB ): return vecA + vecB main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"echo 'def plus_vecA_vecB(vecA, vecB): return vecA+vecB' > ./tmp/pyFunction.py\" ); sstd :: c2py < std :: vector < int >> plus_vecA_vecB ( \"./tmpDir\" , \"./tmp/pyFunction\" , \"plus_vecA_vecB\" , \"vec<int>, const int*, len, const vec<int>*\" ); int arrA [] = { 1 , 2 , 3 }; std :: vector < int > vecB = { 4 , 5 , 6 }; std :: vector < int > vecC = plus_vecA_vecB ( arrA , 3 , & vecB ); // Running Python here sstd :: printn ( vecC ); sstd :: rm ( \"./tmp\" ); return 0 ; } Execution result vecC = [5 7 9] Sample3: (Return: \"void\" / Input: \"int*\", \"int*\", \"len\" and \"vec<int>*\") Writing back self multiplied value. \u81ea\u5df1\u4e57\u7b97\u5024\u3092\u66f8\u304d\u623b\u3059\uff0e pyFunction.py def selfMult ( a , vecB , vecC ): a [ 0 ] = a [ 0 ] * a [ 0 ] for i in range ( len ( vecB )): vecB [ i ] = vecB [ i ] * vecB [ i ] for i in range ( len ( vecC )): vecC [ i ] = vecC [ i ] * vecC [ i ] main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"echo 'def selfMult(a, vecB, vecC): \\n a[0]=a[0]*a[0] \\n for i in range(len(vecB)): vecB[i]=vecB[i]*vecB[i] \\n for i in range(len(vecC)): vecC[i]=vecC[i]*vecC[i]' > ./tmp/pyFunction.py\" ); sstd :: c2py < void > selfMult ( \"./tmpDir\" , \"./tmp/pyFunction\" , \"selfMult\" , \"void, int*, int*, len, vec<int>*\" ); int a = 2 ; int arrB [] = { 3 , 4 , 5 }; std :: vector < int > vecC = { 6 , 7 , 8 }; selfMult ( & a , arrB , 3 , & vecC ); sstd :: printn ( a ); printf ( \"arrB[3] = [ \" ); for ( uint i = 0 ; i < 3 ; i ++ ){ printf ( \"%d \" , arrB [ i ]); } printf ( \"] \\n \" ); sstd :: printn ( vecC ); sstd :: rm ( \"./tmp\" ); return 0 ; } Execution result a = 4 arrB[3] = [ 9 16 25 ] vecC = [36 49 64] Sample4: Types conversion of numpy to built-in Conversion types in Python side. Symbols on the right side of \"|\" (which is a separator symbol between C++ and Python) mean the symbols have effect on the Python side. On the right side of \"|\" enable to take \" \" or \"~\" and these order have no meaning. (There is no difference between \"| ~\" and \"|~*\", so it will work same.) *: A symbol have a meaning to convert input value on Python side to a pseudo pointer type (self inclusion list). ~: A symbol have a meaning to convert input value on Python side to a built-in type (instead of numpy type). Python \u5074\u3067\u578b\u5909\u63db\u3092\u884c\u3046\u5834\u5408\uff0e\u30bb\u30d1\u30ec\u30fc\u30bf\u8a18\u53f7 \"|\" \u306e\u5de6\u53f3\u306f\uff0c\u305d\u308c\u305e\u308c\uff0cC++ \u5074\u3068 Python \u5074\u3092\u8868\u3057\u3066\u3044\u308b\uff0e\u5206\u5272\u8a18\u53f7 \"|\" \u306e\u53f3\u5074\u306e\u578b\u306f \" \" \u307e\u305f\u306f \"~\" \u3092\u53d6\u308b\u3053\u3068\u304c\u3067\u304d\uff0c\u3053\u308c\u306f Python \u5074\u306b\u304a\u3051\u308b\u5909\u63db\u8a18\u53f7\u3067\u3042\u308b\uff0e\u3053\u306e\u3068\u304d\uff0c\u5909\u63db\u8a18\u53f7 \" \"\uff0c\"~\" \u306e\u9806\u5e8f\u306f\u610f\u5473\u3092\u306a\u3055\u306a\u3044\uff0e(\u3057\u305f\u304c\u3063\u3066\uff0c \"| ~\" \u3068 \"|~ \" \u306e\u9593\u306b\u5dee\u306f\u306a\u304f\uff0c\u540c\u3058\u3088\u3046\u306b\u52d5\u4f5c\u3059\u308b\uff0e) *: Python \u5074\u306e\u5165\u529b\u5024\u3092\u64ec\u4f3c\u30dd\u30a4\u30f3\u30bf\u578b (\u81ea\u5df1\u5305\u542b\u30ea\u30b9\u30c8) \u3078\u5909\u63db\u3059\u308b\uff0e ~: Python \u5074\u306e\u5165\u529b\u5024\u3092\uff08numpy \u578b\u306e\u4ee3\u308f\u308a\u306b\uff09\u7d44\u307f\u8fbc\u307f\u578b\u306b\u5909\u63db\u3059\u308b\uff0e pyFunction.py def checkTypes ( Numpy , builtIn , pNumpy , pBuiltIn ): print ( type ( Numpy ), Numpy ) print ( type ( builtIn ), builtIn ) print ( type ( pNumpy ), pNumpy ) print ( type ( pBuiltIn ), pBuiltIn ) main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"echo 'def checkTypes(Numpy, builtIn, pNumpy, pBuiltIn): \\n print(type(Numpy), Numpy) \\n print(type(builtIn), builtIn) \\n print(type(pNumpy), pNumpy) \\n print(type(pBuiltIn), pBuiltIn)' > ./tmp/pyFunction.py\" ); sstd :: c2py < void > checkTypes ( \"./tmpDir\" , \"./tmp/pyFunction\" , \"checkTypes\" , \"void, int, int|~, int|*, int|*~\" ); checkTypes ( 0 , 0 , 0 , 0 ); sstd :: rm ( \"./tmp\" ); return 0 ; } Execution result <class 'numpy.ndarray'> [0] <class 'list'> [0] <class 'list'> [array([0], dtype=int32)] <class 'list'> [[0]] Sample5: Writing back with changing the length of std::vector<T> Writing back with changing the length of std::vector<T> . (In order to get value from function, sending address is needed.) \u914d\u5217\u9577\u306e\u5909\u5316\u3092\u542b\u3080 std::vector<T> \u306e\u66f8\u304d\u623b\u3057\uff0e(\u95a2\u6570\u304b\u3089\u5024\u3092\u53d7\u3051\u53d6\u308b\u305f\u3081\uff0c\u30a2\u30c9\u30ec\u30b9\u3092\u53d7\u3051\u6e21\u3057\u3066\u3044\u308b) pyFunction.py import numpy as np def changeLen ( pVec1 , vec2 ): pVec1 [ 0 ] = np . append ( pVec1 [ 0 ], 4 ) # numpy # numpy is not able to add values without changing address of variables. so we need to treat as a pointer like objects (self inclusion list). vec2 . append ( 4 ) # built-in main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"echo 'import numpy as np \\n def changeLen(pVec1, vec2): \\n pVec1[0]=np.append(pVec1[0], 4) \\n vec2.append(4)' > ./tmp/pyFunction.py\" ); sstd :: c2py < void > changeLen ( \"./tmpDir\" , \"./tmp/pyFunction\" , \"changeLen\" , \"void, vec<int>*|*, vec<int>*|~\" ); std :: vector < int > vec1 = { 1 , 2 , 3 }, vec2 = { 1 , 2 , 3 }; changeLen ( & vec1 , & vec2 ); sstd :: printn ( vec1 ); sstd :: printn ( vec2 ); sstd :: rm ( \"./tmp\" ); return 0 ; } Execution result vec1 = [1 2 3 4] vec2 = [1 2 3 4] Sample6 Receiving multiple return values from python side. (\u203b \"ret\" which is a symbol of return value, must be continuous in arg 4. Interrupted ret occurs error.) Python \u5074\u304b\u3089\u8907\u6570\u306e\u623b\u308a\u5024\u3092\u53d7\u3051\u53d6\u308b\uff0e(\u203b \u623b\u308a\u5024\u8a18\u53f7 \"ret\" \u306f\uff0c\u7b2c 4 \u5f15\u6570\u4e2d\u3067\u9023\u7d9a\u3057\u3066\u3044\u308b\u5fc5\u8981\u304c\u3042\u308b\uff0e\u4e0d\u9023\u7d9a\u306a ret \u306f\u30a8\u30e9\u30fc\u3092\u5f15\u304d\u8d77\u3053\u3059\uff0e) pyFunction.py def multiRet (): return ( 9 , 9 , [ 1 , 2 , 3 ], [ 4 , 5 , 6 ]) main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"echo 'def multiRet(): return (9, 9, [1,2,3], [4,5,6])' > ./tmp/pyFunction.py\" ); sstd :: c2py < int > multiRet ( \"./tmpDir\" , \"./tmp/pyFunction\" , \"multiRet\" , \"int, ret int*, ret int*, len, ret vec<int>*\" ); int ret0 = 0 ; int ret1 = 0 ; int ret2 [] = { 0 , 0 , 0 }; std :: vector < int > ret3 ; ret0 = multiRet ( & ret1 , & ret2 , 3 , & ret3 ); sstd :: printn ( ret0 ); sstd :: printn ( ret1 ); printf ( \"ret2[3] = [ \" ); for ( uint i = 0 ; i < 3 ; i ++ ){ printf ( \"%d \" , ret2 [ i ]); } printf ( \"] \\n \" ); sstd :: printn ( ret3 ); sstd :: rm ( \"./tmp\" ); return 0 ; } Execution result ret0 = 9 ret1 = 9 ret2[3] = [ 1 2 3 ] ret3 = [4 5 6] Appendix Application sample 1 As one of the most convenient application, c2py enable to call matplotlib which is a famous graph plot library in python from C++. In the code below, generate sin wave on C++ and write graph by matplotlib in Python. \u6700\u3082\u4fbf\u5229\u306a\u5fdc\u7528\u306e 1 \u3064\u3068\u3057\u3066\uff0cc2py \u3067\u306f\uff0cPython \u3067\u6709\u540d\u306a\u30b0\u30e9\u30d5\u30d7\u30ed\u30c3\u30c8\u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u3042\u308b matplotlib \u3092 C++ \u304b\u3089\u547c\u3073\u51fa\u3059\u3053\u3068\u304c\u3067\u304d\u308b\uff0e\u4e0b\u8a18\u306e\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u3067\u306f\uff0cC++ \u5074\u3067\u751f\u6210\u3057\u305f sin \u6ce2\u3092\uff0cPython \u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u3042\u308b matplotlib \u3067\u63cf\u753b\u3057\u3066\u3044\u308b\uff0e pyFunction.py import matplotlib as mpl # \"QXcbConnection: Could not connect to display\" \u3078\u306e\u5bfe\u7b56 mpl . use ( 'Agg' ) # \"QXcbConnection: Could not connect to display\" \u3078\u306e\u5bfe\u7b56 import matplotlib.pyplot as plt # \"QXcbConnection: Could not connect to display\" \u3078\u306e\u5bfe\u7b56 import matplotlib.ticker as tick def vec2graph ( writeName , vecX , vecY ): plt . clf () fig = plt . figure ( figsize = ( 9 , 3 )) # \u30a2\u30b9\u30da\u30af\u30c8\u6bd4\u306e\u8a2d\u5b9a ax1 = fig . add_subplot ( 111 ) ax1 . plot ( vecX , vecY , color = 'k' , linewidth = 0.5 ) title = \"An example of Plotting a figure of sin wave data generated on C++, \\n \" title += \"using matplotlib which is a famous graph plotting library of python. \\n \" title += \" \\\" sstd::c2py() \\\" convertes a type of std::vector<double> on C++ to \\n \" title += \"numpy array type on Python, and calling a Python function from \\n \" title += \"only 2 lines of C++ code. \" ax1 . set_title ( title ) ax1 . grid ( which = 'minor' , linewidth = 0.5 , linestyle = ':' , color = 'gainsboro' ) ax1 . grid ( which = 'major' , linewidth = 0.5 , linestyle = '-' , color = 'silver' ) ax1 . tick_params ( pad = 5 , which = 'major' , direction = 'in' , bottom = True , top = True , left = True , right = True , length = 4 ) # \u8ef8\u306e\u4f59\u767d # which: major tick \u3068 minor tick \u306b\u5bfe\u3057\u3066\u5909\u66f4\u3092\u9069\u7528 # tick \u3092\u5185\u5074\u65b9\u5411\u306b # tick \u3092 bottom, top, left, right \u306b\u4ed8\u52a0 # tick width # tick length ax1 . tick_params ( pad = 5 , which = 'minor' , direction = 'in' , bottom = True , top = True , left = True , right = True , length = 2 ) # \u8ef8\u306e\u4f59\u767d # which: major tick \u3068 minor tick \u306b\u5bfe\u3057\u3066\u5909\u66f4\u3092\u9069\u7528 # tick \u3092\u5185\u5074\u65b9\u5411\u306b # tick \u3092 bottom, top, left, right \u306b\u4ed8\u52a0 # tick width # tick length ax1 . set_xlabel ( \"Time [sec] \\n Fig 1. 0.1 Hz sin wave sampled by 10 Hz, 0-60 sec.\" ) ax1 . set_xlim ( 0 - 1 , 60 + 1 ) ax1 . xaxis . set_major_locator ( tick . MultipleLocator ( 5 )) ax1 . xaxis . set_minor_locator ( tick . MultipleLocator ( 1 )) ax1 . set_ylabel ( \"Amplitude\" ) ax1 . set_ylim ( - 1.1 , 1.1 ) ax1 . yaxis . set_major_locator ( tick . MultipleLocator ( 0.5 )) ax1 . yaxis . set_minor_locator ( tick . MultipleLocator ( 0.1 )) plt . savefig ( writeName , bbox_inches = \"tight\" ) main.cpp #include <sstd/sstd.hpp> int main (){ double freq2generate = 0.1 ; // 0.1 Hz sin wave double freq2sample = 10 ; // 10 Hz sampling uint len = 60 * 10 + 1 ; // 60 sec std :: vector < double > vecY = sstd :: sinWave ( freq2generate , freq2sample , len ); std :: vector < double > vecX ( len ); for ( uint i = 0 ; i < vecX . size (); i ++ ){ vecX [ i ] = ( double ) i * ( 1 / freq2sample ); } sstd :: c2py < void > vec2graph ( \"./tmpDir\" , \"pyFunctions\" , \"vec2graph\" , \"void, const char*, vec<double>*, vec<double>*\" ); vec2graph ( \"./sin.png\" , & vecX , & vecY ); return 0 ; } Execution result Application sample 2 An example of the additional implementation of vvec<T> . Currently, only vvec is available. \u8ffd\u52a0\u5b9f\u88c5\u3055\u308c\u305f vvec<T> \u306e\u4f7f\u7528\u4f8b\uff0e\u73fe\u72b6\u3067\u306f\uff0c vvec<double> \u306e\u307f\u5229\u7528\u53ef\u80fd\uff0e Python def vvec2graph ( writeName , vLabel , vvecX , vvecY ): plt . clf () fig = plt . figure ( figsize = ( 8.5 , 3 )) # \u30a2\u30b9\u30da\u30af\u30c8\u6bd4\u306e\u8a2d\u5b9a ax1 = fig . add_subplot ( 111 ) #cmap = plt.get_cmap(\"tab10\") vColor = [ 'black' , 'blue' , 'red' ] vLineStyle = [ 'solid' , 'solid' , 'solid' ] # solid, dashed, dashdot, dotted for i in range ( len ( vvecX )): #ax1.plot(vvecX[i], vvecY[i], linewidth=0.5, color=cmap(i), linestyle=vLineStyle[i], label=vLabel[i]) ax1 . plot ( vvecX [ i ], vvecY [ i ], linewidth = 0.5 , color = vColor [ i ], linestyle = vLineStyle [ i ], label = vLabel [ i ]) ax1 . legend ( loc = 'upper right' ) ax1 . grid ( which = 'minor' , linewidth = 0.5 , linestyle = ':' , color = 'gainsboro' ) ax1 . grid ( which = 'major' , linewidth = 0.5 , linestyle = '-' , color = 'silver' ) ax1 . tick_params ( pad = 5 , which = 'major' , direction = 'in' , bottom = True , top = True , left = True , right = True , length = 4 ) # \u8ef8\u306e\u4f59\u767d # which: major tick \u3068 minor tick \u306b\u5bfe\u3057\u3066\u5909\u66f4\u3092\u9069\u7528 # tick \u3092\u5185\u5074\u65b9\u5411\u306b # tick \u3092 bottom, top, left, right \u306b\u4ed8\u52a0 # tick width # tick length ax1 . tick_params ( pad = 5 , which = 'minor' , direction = 'in' , bottom = True , top = True , left = True , right = True , length = 2 ) # \u8ef8\u306e\u4f59\u767d # which: major tick \u3068 minor tick \u306b\u5bfe\u3057\u3066\u5909\u66f4\u3092\u9069\u7528 # tick \u3092\u5185\u5074\u65b9\u5411\u306b # tick \u3092 bottom, top, left, right \u306b\u4ed8\u52a0 # tick width # tick length ax1 . set_xlabel ( \"Time [sec] \\n Fig 2. 0.1 Hz sin, cos and -cos wave sampled by 10 Hz, 0-60 sec.\" ) ax1 . set_xlim ( 0 - 1 , 60 + 1 ) ax1 . xaxis . set_major_locator ( tick . MultipleLocator ( 5 )) ax1 . xaxis . set_minor_locator ( tick . MultipleLocator ( 1 )) ax1 . set_ylabel ( \"Amplitude\" ) ax1 . set_ylim ( - 1.1 , 1.1 ) ax1 . yaxis . set_major_locator ( tick . MultipleLocator ( 0.5 )) ax1 . yaxis . set_minor_locator ( tick . MultipleLocator ( 0.1 )) plt . legend ( loc = 'best' ) plt . savefig ( writeName , bbox_inches = \"tight\" ) # , dpi=100 main.cpp #include <sstd/sstd.hpp> int main (){ double freq_generate = 0.1 ; // 0.1 Hz sin wave double freq_sample = 10 ; // 10 Hz sampling uint len = 60 * 10 + 1 ; // 60 sec std :: vector < double > sinY = sstd :: sinWave ( freq_generate , freq_sample , len ); std :: vector < double > sinX ( len ); for ( uint i = 0 ; i < sinX . size (); i ++ ){ sinX [ i ] = ( double ) i * ( 1 / freq_sample ); } std :: vector < double > cosY = sstd :: cosWave ( freq_generate , freq_sample , len ); std :: vector < double > cosX ( len ); for ( uint i = 0 ; i < cosX . size (); i ++ ){ cosX [ i ] = ( double ) i * ( 1 / freq_sample ); } std :: vector < std :: string > vLabel = { \"sin\" , \"cos\" , \"-cos\" }; std :: vector < std :: vector < double >> vvecX = { sinX , cosX , cosX }; std :: vector < std :: vector < double >> vvecY = { sinY , cosY , -1 * cosY }; sstd :: c2py < void > vvec2graph ( tmpDir , fileName , \"vvec2graph\" , \"void, const char*, const vec<str>*, const vvec<double>*, const vvec<double>*\" ); vvec2graph ( \"./sin_cos.png\" , & vLabel , & vvecX , & vvecY ); return 0 ; } Execution result Application sample 3 In the code below, reading png image from Python, editing on C++ and writing to png file by Python again. Python \u95a2\u6570\u304b\u3089 png \u30d5\u30a1\u30a4\u30eb\u3092\u8aad\u307f\u8fbc\u307f\uff0cC++ \u3067\u8272\u3092\u7de8\u96c6\u3057\u305f\u5f8c\uff0c\u518d\u5ea6 Python \u95a2\u6570\u3067 png \u30d5\u30a1\u30a4\u30eb\u3078\u66f8\u304d\u51fa\u3059\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u3092\u793a\u3059\uff0e Python import numpy as np from PIL import Image def imgPath2mat_rRGB ( path ): imgRaw = Image . open ( path ) imgRGB = imgRaw . split () imgR = imgRGB [ 0 ] imgG = imgRGB [ 1 ] imgB = imgRGB [ 2 ] return ( imgR , imgG , imgB ) def mat_rRGB2img ( path , imgR , imgG , imgB ): imgCombined = np . dstack (( np . dstack (( imgR , imgG )), imgB )) imgPIL = Image . fromarray ( imgCombined ) imgPIL . save ( path ) main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: c2py < void > imgPath2mat_rRGB ( \"./tmpDir\" , \"pyFunctions\" , \"imgPath2mat_rRGB\" , \"void, ret mat_r<uint8>*, ret mat_r<uint8>*, ret mat_r<uint8>*, const char*\" ); sstd :: mat_r < uint8 > imgR , imgG , imgB ; imgPath2mat_rRGB ( & imgR , & imgG , & imgB , \"./sample.png\" ); for ( uint p = 0 ; p < imgG . rows (); p ++ ){ for ( uint q = 0 ; q < imgG . cols (); q ++ ){ imgG ( p , q ) = sstd :: round2even ( 0.5 * (( double ) imgG ( p , q ))); } } sstd :: c2py < void > mat_rRGB2img ( \"./tmpDir\" , \"pyFunctions\" , \"mat_rRGB2img\" , \"void, const char*, mat_r<uint8>*, mat_r<uint8>*, mat_r<uint8>*\" ); mat_rRGB2img ( \"./sample_reCombined.png\" , & imgR , & imgG , & imgB ); return 0 ; } Execution result Input image (sample.png) Output image (sample_reCombined.png) Implementation Source: sstd/src/c2py.cpp Header: sstd/src/c2py.hpp Python: sstd/src/c2py.py Test: test/c2py.hpp","title":"c2py"},{"location":"src/c2py.html#c2py","text":"","title":"c2py"},{"location":"src/c2py.html#abstract","text":"c2py() calls any Python functions with built-in, std::vector<T> , sstd::mat_c<T> and sstd::mat_r<T> ( T is limitted by built-in types.) types of arguments from 2 lines of C++ codes. Data is sharing by the tmp directory. c2py() \u306f built-in \u578b\uff0c std::vector<T> \u578b, sstd::mat_c<T> \u578b\uff0c\u304a\u3088\u3073 sstd::mat_r<T> \u578b (\u305f\u3060\u3057\uff0c T \u306f built-in \u578b\u306b\u5236\u9650\u3055\u308c\u308b\uff0e) \u3092\u5f15\u6570\u306b\u6301\u3064 Python \u95a2\u6570\u3092 2 \u884c\u306e C++ \u30b3\u30fc\u30c9\u3067\u547c\u3073\u51fa\u3057\u307e\u3059\uff0e \u30c7\u30fc\u30bf\u306f tmp \u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306b\u3088\u308a\u5171\u6709\u3055\u308c\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/c2py.html#header-file","text":"namespace sstd { template < typename T > class c2py ; } template < typename T > class sstd :: c2py { public : c2py ( const char * temporarilyDir , const char * importFile , const char * functionName , const char * format ); ~ c2py (); template < typename ... ARGS > T operator ()( ARGS ... args ); }; c2py interface sstd :: c2py < ATypeOfReturnValue > FunctionName ( \"Tempolary directory\" , // Argument 1 \"A name of calling .py file (without extension)\" , // Argument 2 \"A function name calling from .py file\" , // Argument 3 \"Arguments types specification of Python function\" ); // Argument 4 c2py \u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u306e\u8a2d\u8a08 sstd :: c2py < \u623b\u308a\u5024\u306e\u578b > \u95a2\u6570\u540d ( \"\u4e00\u6642\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\" , // \u7b2c 1 \u5f15\u6570 \"\u547c\u3073\u51fa\u3057\u5148\u306e .py \u30d5\u30a1\u30a4\u30eb (\u305f\u3060\u3057\u62e1\u5f35\u5b50\u3092\u9664\u304f)\" , // \u7b2c 2 \u5f15\u6570 \".py \u30d5\u30a1\u30a4\u30eb\u4e2d\u304b\u3089\u547c\u3073\u51fa\u3059\u95a2\u6570\u540d\" , // \u7b2c 3 \u5f15\u6570 \"Python \u95a2\u6570\u306e\u578b\u6307\u5b9a\" ); // \u7b2c 4 \u5f15\u6570","title":"Header file"},{"location":"src/c2py.html#requirements","text":"c2py() requires the importlib , inspect , itertools , numpy , os and sys Python packages. See sstd/src/c2py.py for details. c2py() \u306f\uff0c importlib , inspect , itertools , numpy , os , sys \u306e Python \u30d1\u30c3\u30b1\u30fc\u30b8\u3092\u5fc5\u8981\u3068\u3057\u307e\u3059\uff0e\u8a73\u7d30\u306f sstd/src/c2py.py \u3092\u53c2\u7167\u3059\u308b\u3053\u3068\uff0e","title":"Requirements"},{"location":"src/c2py.html#list-of-corresponding-types","text":"Table 1. shows the correspondence between the types on the C ++ side and the types on the Python side. Table 2. shows a list of type names given when specifying a type on the C ++ side. If not specifying type on the Python side, numpy will be selected. And selecting the conversion symbol ~ , the numpy type will be converted to the built-in type. The c2py is basically processed by numpy, because of the binary compatibility between C++ and Python, type conversion of numpy to built-in type will be overhead. \u8868 1. \u306b C++ \u5074\u306e\u578b\u3068\uff0cPython \u5074\u306e\u578b\u3068\u306e\u5bfe\u5fdc\u3092\u793a\u3059\uff0e \u8868 2. \u306b C++ \u5074\u306e\u578b\u3092\u6307\u5b9a\u3059\u308b\u969b\u306b\u4e0e\u3048\u308b\u578b\u540d\u306e\u4e00\u89a7\u3092\u793a\u3059\uff0e Python \u5074\u306e\u578b\u306b\u3064\u3044\u3066\uff0c\u4f55\u3082\u6307\u5b9a\u3057\u306a\u3044\u5834\u5408\u306f\uff0cnumpy \u578b\u304c\u9078\u629e\u3055\u308c\uff0c\u5909\u63db\u8a18\u53f7 ~ \u3092\u6307\u5b9a\u3059\u308b\u3053\u3068\u3067\uff0cbuilt-in \u578b\u306b\u5909\u63db\u3055\u308c\u308b\uff0e c2py \u4e0a\u306e\u51e6\u7406\u306f\uff0cC++ \u3068\u306e\u30d0\u30a4\u30ca\u30ea\u4e92\u63db\u6027\u306e\u554f\u984c\u304b\u3089\uff0c\u57fa\u672c\u7684\u306b numpy \u578b\u3067\u884c\u308f\u308c\u308b\u305f\u3081\uff0cbuilt-in \u578b\u3078\u306e\u5909\u63db\u306f\uff0c\u30aa\u30fc\u30d0\u30fc\u30d8\u30c3\u30c9\u3068\u306a\u308b\uff0e Table 1. Correspondence between types implemented in c2py and Python \u8868 1. c2py \u3067\u5b9f\u88c5\u3055\u308c\u3066\u3044\u308b\u578b\u3068 Python \u578b\u3068\u306e\u5bfe\u5fdc Types of C++ side Types of Python side Entity / Pointer / Pointer array Entity / Pointer Entity / Pointer Entity / Pointer Entity / Pointer bool std::vector<bool> sstd::mat_c<bool> sstd::mat_r<bool> numpy / built-in char std::vector<char> sstd::mat_c<char> sstd::mat_r<char> built-in uchar std::vector<uchar> sstd::mat_c<uchar> sstd::mat_r<uchar> built-in int8 std::vector<int8> sstd::mat_c<int8> sstd::mat_r<int8> numpy / built-in int16 std::vector<int16> sstd::mat_c<int16> sstd::mat_r<int16> numpy / built-in int32 std::vector<int32> sstd::mat_c<int32> sstd::mat_r<int32> numpy / built-in int64 std::vector<int64> sstd::mat_c<int64> sstd::mat_r<int64> numpy / built-in uint8 std::vector<uint8> sstd::mat_c<uint8> sstd::mat_r<uint8> numpy / built-in uint16 std::vector<uint16> sstd::mat_c<uint16> sstd::mat_r<uint16> numpy / built-in uint32 std::vector<uint32> sstd::mat_c<uint32> sstd::mat_r<uint32> numpy / built-in uint64 std::vector<uint64> sstd::mat_c<uint64> sstd::mat_r<uint64> numpy / built-in float std::vector<float> sstd::mat_c<float> sstd::mat_r<float> numpy / built-in double std::vector<double> sstd::mat_c<double> sstd::mat_r<double> numpy / built-in std::string std::vector<std::string> sstd::mat_c<std::string> sstd::mat_r<std::string> built-in Table 2. Type names giving to the 4th argument of c2py. \u8868 2. c2py \u306e\u7b2c 4 \u5f15\u6570\u306b\u4e0e\u3048\u308b\u578b\u540d\uff0e Types of C++ side Entity / Pointer / Pointer array Entity / Pointer Entity / Pointer Entity / Pointer bool vec<bool> mat_c<bool> mat_r<bool> char vec<char> mat_c<char> mat_r<char> uchar vec<uchar> mat_c<uchar> mat_r<uchar> int8 vec<int8> mat_c<int8> mat_r<int8> int16 vec<int16> mat_c<int16> mat_r<int16> int32 vec<int32> mat_c<int32> mat_r<int32> int64 vec<int64> mat_c<int64> mat_r<int64> uint8 vec<uint8> mat_c<uint8> mat_r<uint8> uint16 vec<uint16> mat_c<uint16> mat_r<uint16> uint32 vec<uint32> mat_c<uint32> mat_r<uint32> uint64 vec<uint64> mat_c<uint64> mat_r<uint64> float vec<float> mat_c<float> mat_r<float> double vec<double> mat_c<double> mat_r<double> str / string vec<str> / vec<string> mat_c<str> / mat_c<string> mat_r<str> / mat_r<string>","title":"List of corresponding types. (\u5bfe\u5fdc\u3059\u308b\u578b\u306e\u4e00\u89a7)"},{"location":"src/c2py.html#usage","text":"","title":"Usage"},{"location":"src/c2py.html#sample1-return-int-input-int-and-const-int","text":"pyFunction.py def plus_a_b ( a , b ): return a + b main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"echo 'def plus_a_b(a, b): return a+b' > ./tmp/pyFunction.py\" ); sstd :: c2py < int > plus_a_b ( \"./tmpDir\" , \"./tmp/pyFunction\" , \"plus_a_b\" , \"int, int, const int*\" ); int a = 1 , b = 2 ; int c = plus_a_b ( a , & b ); // Running Python here sstd :: printn ( c ); sstd :: rm ( \"./tmp\" ); return 0 ; } Execution result c = 3","title":"Sample1: (Return: \"int\" / Input: \"int\" and \"const int*\")"},{"location":"src/c2py.html#sample2-return-vecint-input-const-int-len-and-const-vecint","text":"pyFunction.py def plus_vecA_vecB ( vecA , vecB ): return vecA + vecB main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"echo 'def plus_vecA_vecB(vecA, vecB): return vecA+vecB' > ./tmp/pyFunction.py\" ); sstd :: c2py < std :: vector < int >> plus_vecA_vecB ( \"./tmpDir\" , \"./tmp/pyFunction\" , \"plus_vecA_vecB\" , \"vec<int>, const int*, len, const vec<int>*\" ); int arrA [] = { 1 , 2 , 3 }; std :: vector < int > vecB = { 4 , 5 , 6 }; std :: vector < int > vecC = plus_vecA_vecB ( arrA , 3 , & vecB ); // Running Python here sstd :: printn ( vecC ); sstd :: rm ( \"./tmp\" ); return 0 ; } Execution result vecC = [5 7 9]","title":"Sample2: (Return: \"vec&lt;int&gt;\" / Input: \"const int*\", \"len\" and \"const vec&lt;int&gt;*\")"},{"location":"src/c2py.html#sample3-return-void-input-int-int-len-and-vecint","text":"Writing back self multiplied value. \u81ea\u5df1\u4e57\u7b97\u5024\u3092\u66f8\u304d\u623b\u3059\uff0e pyFunction.py def selfMult ( a , vecB , vecC ): a [ 0 ] = a [ 0 ] * a [ 0 ] for i in range ( len ( vecB )): vecB [ i ] = vecB [ i ] * vecB [ i ] for i in range ( len ( vecC )): vecC [ i ] = vecC [ i ] * vecC [ i ] main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"echo 'def selfMult(a, vecB, vecC): \\n a[0]=a[0]*a[0] \\n for i in range(len(vecB)): vecB[i]=vecB[i]*vecB[i] \\n for i in range(len(vecC)): vecC[i]=vecC[i]*vecC[i]' > ./tmp/pyFunction.py\" ); sstd :: c2py < void > selfMult ( \"./tmpDir\" , \"./tmp/pyFunction\" , \"selfMult\" , \"void, int*, int*, len, vec<int>*\" ); int a = 2 ; int arrB [] = { 3 , 4 , 5 }; std :: vector < int > vecC = { 6 , 7 , 8 }; selfMult ( & a , arrB , 3 , & vecC ); sstd :: printn ( a ); printf ( \"arrB[3] = [ \" ); for ( uint i = 0 ; i < 3 ; i ++ ){ printf ( \"%d \" , arrB [ i ]); } printf ( \"] \\n \" ); sstd :: printn ( vecC ); sstd :: rm ( \"./tmp\" ); return 0 ; } Execution result a = 4 arrB[3] = [ 9 16 25 ] vecC = [36 49 64]","title":"Sample3: (Return: \"void\" / Input: \"int*\", \"int*\", \"len\" and \"vec&lt;int&gt;*\")"},{"location":"src/c2py.html#sample4-types-conversion-of-numpy-to-built-in","text":"Conversion types in Python side. Symbols on the right side of \"|\" (which is a separator symbol between C++ and Python) mean the symbols have effect on the Python side. On the right side of \"|\" enable to take \" \" or \"~\" and these order have no meaning. (There is no difference between \"| ~\" and \"|~*\", so it will work same.) *: A symbol have a meaning to convert input value on Python side to a pseudo pointer type (self inclusion list). ~: A symbol have a meaning to convert input value on Python side to a built-in type (instead of numpy type). Python \u5074\u3067\u578b\u5909\u63db\u3092\u884c\u3046\u5834\u5408\uff0e\u30bb\u30d1\u30ec\u30fc\u30bf\u8a18\u53f7 \"|\" \u306e\u5de6\u53f3\u306f\uff0c\u305d\u308c\u305e\u308c\uff0cC++ \u5074\u3068 Python \u5074\u3092\u8868\u3057\u3066\u3044\u308b\uff0e\u5206\u5272\u8a18\u53f7 \"|\" \u306e\u53f3\u5074\u306e\u578b\u306f \" \" \u307e\u305f\u306f \"~\" \u3092\u53d6\u308b\u3053\u3068\u304c\u3067\u304d\uff0c\u3053\u308c\u306f Python \u5074\u306b\u304a\u3051\u308b\u5909\u63db\u8a18\u53f7\u3067\u3042\u308b\uff0e\u3053\u306e\u3068\u304d\uff0c\u5909\u63db\u8a18\u53f7 \" \"\uff0c\"~\" \u306e\u9806\u5e8f\u306f\u610f\u5473\u3092\u306a\u3055\u306a\u3044\uff0e(\u3057\u305f\u304c\u3063\u3066\uff0c \"| ~\" \u3068 \"|~ \" \u306e\u9593\u306b\u5dee\u306f\u306a\u304f\uff0c\u540c\u3058\u3088\u3046\u306b\u52d5\u4f5c\u3059\u308b\uff0e) *: Python \u5074\u306e\u5165\u529b\u5024\u3092\u64ec\u4f3c\u30dd\u30a4\u30f3\u30bf\u578b (\u81ea\u5df1\u5305\u542b\u30ea\u30b9\u30c8) \u3078\u5909\u63db\u3059\u308b\uff0e ~: Python \u5074\u306e\u5165\u529b\u5024\u3092\uff08numpy \u578b\u306e\u4ee3\u308f\u308a\u306b\uff09\u7d44\u307f\u8fbc\u307f\u578b\u306b\u5909\u63db\u3059\u308b\uff0e pyFunction.py def checkTypes ( Numpy , builtIn , pNumpy , pBuiltIn ): print ( type ( Numpy ), Numpy ) print ( type ( builtIn ), builtIn ) print ( type ( pNumpy ), pNumpy ) print ( type ( pBuiltIn ), pBuiltIn ) main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"echo 'def checkTypes(Numpy, builtIn, pNumpy, pBuiltIn): \\n print(type(Numpy), Numpy) \\n print(type(builtIn), builtIn) \\n print(type(pNumpy), pNumpy) \\n print(type(pBuiltIn), pBuiltIn)' > ./tmp/pyFunction.py\" ); sstd :: c2py < void > checkTypes ( \"./tmpDir\" , \"./tmp/pyFunction\" , \"checkTypes\" , \"void, int, int|~, int|*, int|*~\" ); checkTypes ( 0 , 0 , 0 , 0 ); sstd :: rm ( \"./tmp\" ); return 0 ; } Execution result <class 'numpy.ndarray'> [0] <class 'list'> [0] <class 'list'> [array([0], dtype=int32)] <class 'list'> [[0]]","title":"Sample4: Types conversion of numpy to built-in"},{"location":"src/c2py.html#sample5-writing-back-with-changing-the-length-of-stdvectort","text":"Writing back with changing the length of std::vector<T> . (In order to get value from function, sending address is needed.) \u914d\u5217\u9577\u306e\u5909\u5316\u3092\u542b\u3080 std::vector<T> \u306e\u66f8\u304d\u623b\u3057\uff0e(\u95a2\u6570\u304b\u3089\u5024\u3092\u53d7\u3051\u53d6\u308b\u305f\u3081\uff0c\u30a2\u30c9\u30ec\u30b9\u3092\u53d7\u3051\u6e21\u3057\u3066\u3044\u308b) pyFunction.py import numpy as np def changeLen ( pVec1 , vec2 ): pVec1 [ 0 ] = np . append ( pVec1 [ 0 ], 4 ) # numpy # numpy is not able to add values without changing address of variables. so we need to treat as a pointer like objects (self inclusion list). vec2 . append ( 4 ) # built-in main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"echo 'import numpy as np \\n def changeLen(pVec1, vec2): \\n pVec1[0]=np.append(pVec1[0], 4) \\n vec2.append(4)' > ./tmp/pyFunction.py\" ); sstd :: c2py < void > changeLen ( \"./tmpDir\" , \"./tmp/pyFunction\" , \"changeLen\" , \"void, vec<int>*|*, vec<int>*|~\" ); std :: vector < int > vec1 = { 1 , 2 , 3 }, vec2 = { 1 , 2 , 3 }; changeLen ( & vec1 , & vec2 ); sstd :: printn ( vec1 ); sstd :: printn ( vec2 ); sstd :: rm ( \"./tmp\" ); return 0 ; } Execution result vec1 = [1 2 3 4] vec2 = [1 2 3 4]","title":"Sample5: Writing back with changing the length of std::vector&lt;T&gt;"},{"location":"src/c2py.html#sample6","text":"Receiving multiple return values from python side. (\u203b \"ret\" which is a symbol of return value, must be continuous in arg 4. Interrupted ret occurs error.) Python \u5074\u304b\u3089\u8907\u6570\u306e\u623b\u308a\u5024\u3092\u53d7\u3051\u53d6\u308b\uff0e(\u203b \u623b\u308a\u5024\u8a18\u53f7 \"ret\" \u306f\uff0c\u7b2c 4 \u5f15\u6570\u4e2d\u3067\u9023\u7d9a\u3057\u3066\u3044\u308b\u5fc5\u8981\u304c\u3042\u308b\uff0e\u4e0d\u9023\u7d9a\u306a ret \u306f\u30a8\u30e9\u30fc\u3092\u5f15\u304d\u8d77\u3053\u3059\uff0e) pyFunction.py def multiRet (): return ( 9 , 9 , [ 1 , 2 , 3 ], [ 4 , 5 , 6 ]) main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"echo 'def multiRet(): return (9, 9, [1,2,3], [4,5,6])' > ./tmp/pyFunction.py\" ); sstd :: c2py < int > multiRet ( \"./tmpDir\" , \"./tmp/pyFunction\" , \"multiRet\" , \"int, ret int*, ret int*, len, ret vec<int>*\" ); int ret0 = 0 ; int ret1 = 0 ; int ret2 [] = { 0 , 0 , 0 }; std :: vector < int > ret3 ; ret0 = multiRet ( & ret1 , & ret2 , 3 , & ret3 ); sstd :: printn ( ret0 ); sstd :: printn ( ret1 ); printf ( \"ret2[3] = [ \" ); for ( uint i = 0 ; i < 3 ; i ++ ){ printf ( \"%d \" , ret2 [ i ]); } printf ( \"] \\n \" ); sstd :: printn ( ret3 ); sstd :: rm ( \"./tmp\" ); return 0 ; } Execution result ret0 = 9 ret1 = 9 ret2[3] = [ 1 2 3 ] ret3 = [4 5 6]","title":"Sample6"},{"location":"src/c2py.html#appendix","text":"","title":"Appendix"},{"location":"src/c2py.html#application-sample-1","text":"As one of the most convenient application, c2py enable to call matplotlib which is a famous graph plot library in python from C++. In the code below, generate sin wave on C++ and write graph by matplotlib in Python. \u6700\u3082\u4fbf\u5229\u306a\u5fdc\u7528\u306e 1 \u3064\u3068\u3057\u3066\uff0cc2py \u3067\u306f\uff0cPython \u3067\u6709\u540d\u306a\u30b0\u30e9\u30d5\u30d7\u30ed\u30c3\u30c8\u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u3042\u308b matplotlib \u3092 C++ \u304b\u3089\u547c\u3073\u51fa\u3059\u3053\u3068\u304c\u3067\u304d\u308b\uff0e\u4e0b\u8a18\u306e\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u3067\u306f\uff0cC++ \u5074\u3067\u751f\u6210\u3057\u305f sin \u6ce2\u3092\uff0cPython \u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u3042\u308b matplotlib \u3067\u63cf\u753b\u3057\u3066\u3044\u308b\uff0e pyFunction.py import matplotlib as mpl # \"QXcbConnection: Could not connect to display\" \u3078\u306e\u5bfe\u7b56 mpl . use ( 'Agg' ) # \"QXcbConnection: Could not connect to display\" \u3078\u306e\u5bfe\u7b56 import matplotlib.pyplot as plt # \"QXcbConnection: Could not connect to display\" \u3078\u306e\u5bfe\u7b56 import matplotlib.ticker as tick def vec2graph ( writeName , vecX , vecY ): plt . clf () fig = plt . figure ( figsize = ( 9 , 3 )) # \u30a2\u30b9\u30da\u30af\u30c8\u6bd4\u306e\u8a2d\u5b9a ax1 = fig . add_subplot ( 111 ) ax1 . plot ( vecX , vecY , color = 'k' , linewidth = 0.5 ) title = \"An example of Plotting a figure of sin wave data generated on C++, \\n \" title += \"using matplotlib which is a famous graph plotting library of python. \\n \" title += \" \\\" sstd::c2py() \\\" convertes a type of std::vector<double> on C++ to \\n \" title += \"numpy array type on Python, and calling a Python function from \\n \" title += \"only 2 lines of C++ code. \" ax1 . set_title ( title ) ax1 . grid ( which = 'minor' , linewidth = 0.5 , linestyle = ':' , color = 'gainsboro' ) ax1 . grid ( which = 'major' , linewidth = 0.5 , linestyle = '-' , color = 'silver' ) ax1 . tick_params ( pad = 5 , which = 'major' , direction = 'in' , bottom = True , top = True , left = True , right = True , length = 4 ) # \u8ef8\u306e\u4f59\u767d # which: major tick \u3068 minor tick \u306b\u5bfe\u3057\u3066\u5909\u66f4\u3092\u9069\u7528 # tick \u3092\u5185\u5074\u65b9\u5411\u306b # tick \u3092 bottom, top, left, right \u306b\u4ed8\u52a0 # tick width # tick length ax1 . tick_params ( pad = 5 , which = 'minor' , direction = 'in' , bottom = True , top = True , left = True , right = True , length = 2 ) # \u8ef8\u306e\u4f59\u767d # which: major tick \u3068 minor tick \u306b\u5bfe\u3057\u3066\u5909\u66f4\u3092\u9069\u7528 # tick \u3092\u5185\u5074\u65b9\u5411\u306b # tick \u3092 bottom, top, left, right \u306b\u4ed8\u52a0 # tick width # tick length ax1 . set_xlabel ( \"Time [sec] \\n Fig 1. 0.1 Hz sin wave sampled by 10 Hz, 0-60 sec.\" ) ax1 . set_xlim ( 0 - 1 , 60 + 1 ) ax1 . xaxis . set_major_locator ( tick . MultipleLocator ( 5 )) ax1 . xaxis . set_minor_locator ( tick . MultipleLocator ( 1 )) ax1 . set_ylabel ( \"Amplitude\" ) ax1 . set_ylim ( - 1.1 , 1.1 ) ax1 . yaxis . set_major_locator ( tick . MultipleLocator ( 0.5 )) ax1 . yaxis . set_minor_locator ( tick . MultipleLocator ( 0.1 )) plt . savefig ( writeName , bbox_inches = \"tight\" ) main.cpp #include <sstd/sstd.hpp> int main (){ double freq2generate = 0.1 ; // 0.1 Hz sin wave double freq2sample = 10 ; // 10 Hz sampling uint len = 60 * 10 + 1 ; // 60 sec std :: vector < double > vecY = sstd :: sinWave ( freq2generate , freq2sample , len ); std :: vector < double > vecX ( len ); for ( uint i = 0 ; i < vecX . size (); i ++ ){ vecX [ i ] = ( double ) i * ( 1 / freq2sample ); } sstd :: c2py < void > vec2graph ( \"./tmpDir\" , \"pyFunctions\" , \"vec2graph\" , \"void, const char*, vec<double>*, vec<double>*\" ); vec2graph ( \"./sin.png\" , & vecX , & vecY ); return 0 ; } Execution result","title":"Application sample 1"},{"location":"src/c2py.html#application-sample-2","text":"An example of the additional implementation of vvec<T> . Currently, only vvec is available. \u8ffd\u52a0\u5b9f\u88c5\u3055\u308c\u305f vvec<T> \u306e\u4f7f\u7528\u4f8b\uff0e\u73fe\u72b6\u3067\u306f\uff0c vvec<double> \u306e\u307f\u5229\u7528\u53ef\u80fd\uff0e Python def vvec2graph ( writeName , vLabel , vvecX , vvecY ): plt . clf () fig = plt . figure ( figsize = ( 8.5 , 3 )) # \u30a2\u30b9\u30da\u30af\u30c8\u6bd4\u306e\u8a2d\u5b9a ax1 = fig . add_subplot ( 111 ) #cmap = plt.get_cmap(\"tab10\") vColor = [ 'black' , 'blue' , 'red' ] vLineStyle = [ 'solid' , 'solid' , 'solid' ] # solid, dashed, dashdot, dotted for i in range ( len ( vvecX )): #ax1.plot(vvecX[i], vvecY[i], linewidth=0.5, color=cmap(i), linestyle=vLineStyle[i], label=vLabel[i]) ax1 . plot ( vvecX [ i ], vvecY [ i ], linewidth = 0.5 , color = vColor [ i ], linestyle = vLineStyle [ i ], label = vLabel [ i ]) ax1 . legend ( loc = 'upper right' ) ax1 . grid ( which = 'minor' , linewidth = 0.5 , linestyle = ':' , color = 'gainsboro' ) ax1 . grid ( which = 'major' , linewidth = 0.5 , linestyle = '-' , color = 'silver' ) ax1 . tick_params ( pad = 5 , which = 'major' , direction = 'in' , bottom = True , top = True , left = True , right = True , length = 4 ) # \u8ef8\u306e\u4f59\u767d # which: major tick \u3068 minor tick \u306b\u5bfe\u3057\u3066\u5909\u66f4\u3092\u9069\u7528 # tick \u3092\u5185\u5074\u65b9\u5411\u306b # tick \u3092 bottom, top, left, right \u306b\u4ed8\u52a0 # tick width # tick length ax1 . tick_params ( pad = 5 , which = 'minor' , direction = 'in' , bottom = True , top = True , left = True , right = True , length = 2 ) # \u8ef8\u306e\u4f59\u767d # which: major tick \u3068 minor tick \u306b\u5bfe\u3057\u3066\u5909\u66f4\u3092\u9069\u7528 # tick \u3092\u5185\u5074\u65b9\u5411\u306b # tick \u3092 bottom, top, left, right \u306b\u4ed8\u52a0 # tick width # tick length ax1 . set_xlabel ( \"Time [sec] \\n Fig 2. 0.1 Hz sin, cos and -cos wave sampled by 10 Hz, 0-60 sec.\" ) ax1 . set_xlim ( 0 - 1 , 60 + 1 ) ax1 . xaxis . set_major_locator ( tick . MultipleLocator ( 5 )) ax1 . xaxis . set_minor_locator ( tick . MultipleLocator ( 1 )) ax1 . set_ylabel ( \"Amplitude\" ) ax1 . set_ylim ( - 1.1 , 1.1 ) ax1 . yaxis . set_major_locator ( tick . MultipleLocator ( 0.5 )) ax1 . yaxis . set_minor_locator ( tick . MultipleLocator ( 0.1 )) plt . legend ( loc = 'best' ) plt . savefig ( writeName , bbox_inches = \"tight\" ) # , dpi=100 main.cpp #include <sstd/sstd.hpp> int main (){ double freq_generate = 0.1 ; // 0.1 Hz sin wave double freq_sample = 10 ; // 10 Hz sampling uint len = 60 * 10 + 1 ; // 60 sec std :: vector < double > sinY = sstd :: sinWave ( freq_generate , freq_sample , len ); std :: vector < double > sinX ( len ); for ( uint i = 0 ; i < sinX . size (); i ++ ){ sinX [ i ] = ( double ) i * ( 1 / freq_sample ); } std :: vector < double > cosY = sstd :: cosWave ( freq_generate , freq_sample , len ); std :: vector < double > cosX ( len ); for ( uint i = 0 ; i < cosX . size (); i ++ ){ cosX [ i ] = ( double ) i * ( 1 / freq_sample ); } std :: vector < std :: string > vLabel = { \"sin\" , \"cos\" , \"-cos\" }; std :: vector < std :: vector < double >> vvecX = { sinX , cosX , cosX }; std :: vector < std :: vector < double >> vvecY = { sinY , cosY , -1 * cosY }; sstd :: c2py < void > vvec2graph ( tmpDir , fileName , \"vvec2graph\" , \"void, const char*, const vec<str>*, const vvec<double>*, const vvec<double>*\" ); vvec2graph ( \"./sin_cos.png\" , & vLabel , & vvecX , & vvecY ); return 0 ; } Execution result","title":"Application sample 2"},{"location":"src/c2py.html#application-sample-3","text":"In the code below, reading png image from Python, editing on C++ and writing to png file by Python again. Python \u95a2\u6570\u304b\u3089 png \u30d5\u30a1\u30a4\u30eb\u3092\u8aad\u307f\u8fbc\u307f\uff0cC++ \u3067\u8272\u3092\u7de8\u96c6\u3057\u305f\u5f8c\uff0c\u518d\u5ea6 Python \u95a2\u6570\u3067 png \u30d5\u30a1\u30a4\u30eb\u3078\u66f8\u304d\u51fa\u3059\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u3092\u793a\u3059\uff0e Python import numpy as np from PIL import Image def imgPath2mat_rRGB ( path ): imgRaw = Image . open ( path ) imgRGB = imgRaw . split () imgR = imgRGB [ 0 ] imgG = imgRGB [ 1 ] imgB = imgRGB [ 2 ] return ( imgR , imgG , imgB ) def mat_rRGB2img ( path , imgR , imgG , imgB ): imgCombined = np . dstack (( np . dstack (( imgR , imgG )), imgB )) imgPIL = Image . fromarray ( imgCombined ) imgPIL . save ( path ) main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: c2py < void > imgPath2mat_rRGB ( \"./tmpDir\" , \"pyFunctions\" , \"imgPath2mat_rRGB\" , \"void, ret mat_r<uint8>*, ret mat_r<uint8>*, ret mat_r<uint8>*, const char*\" ); sstd :: mat_r < uint8 > imgR , imgG , imgB ; imgPath2mat_rRGB ( & imgR , & imgG , & imgB , \"./sample.png\" ); for ( uint p = 0 ; p < imgG . rows (); p ++ ){ for ( uint q = 0 ; q < imgG . cols (); q ++ ){ imgG ( p , q ) = sstd :: round2even ( 0.5 * (( double ) imgG ( p , q ))); } } sstd :: c2py < void > mat_rRGB2img ( \"./tmpDir\" , \"pyFunctions\" , \"mat_rRGB2img\" , \"void, const char*, mat_r<uint8>*, mat_r<uint8>*, mat_r<uint8>*\" ); mat_rRGB2img ( \"./sample_reCombined.png\" , & imgR , & imgG , & imgB ); return 0 ; } Execution result Input image (sample.png) Output image (sample_reCombined.png)","title":"Application sample 3"},{"location":"src/c2py.html#implementation","text":"Source: sstd/src/c2py.cpp Header: sstd/src/c2py.hpp Python: sstd/src/c2py.py Test: test/c2py.hpp","title":"Implementation"},{"location":"src/encode_decode.html","text":"encode / decode Abstract encode_decode.hpp contains functions for encoding and decoding operations. encode_decode.hpp \u306f\u30a8\u30f3\u30b3\u30fc\u30c9\u30fb\u30c7\u30b3\u30fc\u30c9\u306b\u307e\u3064\u308f\u308b\u95a2\u6570\u3092\u53ce\u9332\u3057\u307e\u3059\uff0e Header file namespace sstd { std :: string base64_encode ( const uchar * str , size_t strLen ); std :: string base64_encode ( const uchar * str ); std :: string base64_encode ( const std :: string & str ); std :: string base64_decode ( const uchar * str , size_t strLen ); // when it was an error, 0 size std::string is returned. std :: string base64_decode ( const uchar * str ); // when it was an error, 0 size std::string is returned. std :: string base64_decode ( const std :: string & str ); // when it was an error, 0 size std::string is returned. void print_base64_decode_table (); // for developers extern const char bin2str_table [ 256 ][ 3 ]; std :: string url_encode ( const char * str , size_t strLen ); std :: string url_encode ( const char * str ); std :: string url_encode ( std :: string & str ); std :: string url_encode_type2 ( const char * str , size_t strLen ); // for developers void url_encode_compare_speed (); // for developers std :: string url_decode ( const char * str , size_t strLen ); // when it was an error, 0 size std::string is returned. std :: string url_decode ( const char * str ); // when it was an error, 0 size std::string is returned. std :: string url_decode ( std :: string & str ); // when it was an error, 0 size std::string is returned. void print_url_decode_table (); // for developers // std::u16string utf8_to_utf16(const std::string& str); // std::string utf16_to_utf8(const std::u16string& str); // utf functions are not checked yet. std :: u32string utf16_to_utf32 ( const std :: u16string & str ); std :: u16string utf32_to_utf16 ( const std :: u32string & str ); std :: string utf32_to_utf8 ( const std :: u32string & str ); std :: u32string utf8_to_utf32 ( const std :: string & str ); std :: u16string utf8_to_utf16 ( const std :: string & str ); std :: string utf16_to_utf8 ( const std :: u16string & str ); extern const uchar str2bin_table [ 256 ]; std :: string unicodeEscape_encode ( const std :: u16string & str ); std :: u16string unicodeEscape_decode ( const char * str , size_t strLen ); std :: u16string unicodeEscape_decode ( const char * str ); std :: u16string unicodeEscape_decode ( const std :: string & str ); std :: u16string unicodeEscape_decode_type2 ( const char * str , size_t strLen ); // for developers void unicodeEscape_compare_speed (); // for developers void print_unicodeEscape_decode_table (); }; Usage main.cpp #include <sstd/sstd.hpp> int main (){ return 0 ; } Execution result Implementation Source: sstd/src/encode_decode.cpp Header: sstd/src/encode_decode.hpp Test: test/encode_decode.hpp (Not implemented yet)","title":"encode / decode"},{"location":"src/encode_decode.html#encode-decode","text":"","title":"encode / decode"},{"location":"src/encode_decode.html#abstract","text":"encode_decode.hpp contains functions for encoding and decoding operations. encode_decode.hpp \u306f\u30a8\u30f3\u30b3\u30fc\u30c9\u30fb\u30c7\u30b3\u30fc\u30c9\u306b\u307e\u3064\u308f\u308b\u95a2\u6570\u3092\u53ce\u9332\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/encode_decode.html#header-file","text":"namespace sstd { std :: string base64_encode ( const uchar * str , size_t strLen ); std :: string base64_encode ( const uchar * str ); std :: string base64_encode ( const std :: string & str ); std :: string base64_decode ( const uchar * str , size_t strLen ); // when it was an error, 0 size std::string is returned. std :: string base64_decode ( const uchar * str ); // when it was an error, 0 size std::string is returned. std :: string base64_decode ( const std :: string & str ); // when it was an error, 0 size std::string is returned. void print_base64_decode_table (); // for developers extern const char bin2str_table [ 256 ][ 3 ]; std :: string url_encode ( const char * str , size_t strLen ); std :: string url_encode ( const char * str ); std :: string url_encode ( std :: string & str ); std :: string url_encode_type2 ( const char * str , size_t strLen ); // for developers void url_encode_compare_speed (); // for developers std :: string url_decode ( const char * str , size_t strLen ); // when it was an error, 0 size std::string is returned. std :: string url_decode ( const char * str ); // when it was an error, 0 size std::string is returned. std :: string url_decode ( std :: string & str ); // when it was an error, 0 size std::string is returned. void print_url_decode_table (); // for developers // std::u16string utf8_to_utf16(const std::string& str); // std::string utf16_to_utf8(const std::u16string& str); // utf functions are not checked yet. std :: u32string utf16_to_utf32 ( const std :: u16string & str ); std :: u16string utf32_to_utf16 ( const std :: u32string & str ); std :: string utf32_to_utf8 ( const std :: u32string & str ); std :: u32string utf8_to_utf32 ( const std :: string & str ); std :: u16string utf8_to_utf16 ( const std :: string & str ); std :: string utf16_to_utf8 ( const std :: u16string & str ); extern const uchar str2bin_table [ 256 ]; std :: string unicodeEscape_encode ( const std :: u16string & str ); std :: u16string unicodeEscape_decode ( const char * str , size_t strLen ); std :: u16string unicodeEscape_decode ( const char * str ); std :: u16string unicodeEscape_decode ( const std :: string & str ); std :: u16string unicodeEscape_decode_type2 ( const char * str , size_t strLen ); // for developers void unicodeEscape_compare_speed (); // for developers void print_unicodeEscape_decode_table (); };","title":"Header file"},{"location":"src/encode_decode.html#usage","text":"main.cpp #include <sstd/sstd.hpp> int main (){ return 0 ; } Execution result","title":"Usage"},{"location":"src/encode_decode.html#implementation","text":"Source: sstd/src/encode_decode.cpp Header: sstd/src/encode_decode.hpp Test: test/encode_decode.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/itr.html","text":"itr Abstract sstd::begin() and sstd::end() are the definitions for SSTD iterator. sstd::begin() \u3068 sstd::end() \u306f SSTD \u306e\u30a4\u30c6\u30ec\u30fc\u30bf\u306b\u5229\u7528\u3059\u308b\u305f\u3081\u306e\u5b9a\u7fa9\u3067\u3059\uff0e Header file namespace sstd { class begin ; class end ; } Usage main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced = v && sstd :: slice ( sstd :: begin (), sstd :: end ()); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } Execution result v = [1 2 3 4 5] v_sliced = [1 2 3 4 5] Implementation Header: sstd/src/itr.hpp","title":"itr"},{"location":"src/itr.html#itr","text":"","title":"itr"},{"location":"src/itr.html#abstract","text":"sstd::begin() and sstd::end() are the definitions for SSTD iterator. sstd::begin() \u3068 sstd::end() \u306f SSTD \u306e\u30a4\u30c6\u30ec\u30fc\u30bf\u306b\u5229\u7528\u3059\u308b\u305f\u3081\u306e\u5b9a\u7fa9\u3067\u3059\uff0e","title":"Abstract"},{"location":"src/itr.html#header-file","text":"namespace sstd { class begin ; class end ; }","title":"Header file"},{"location":"src/itr.html#usage","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced = v && sstd :: slice ( sstd :: begin (), sstd :: end ()); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } Execution result v = [1 2 3 4 5] v_sliced = [1 2 3 4 5]","title":"Usage"},{"location":"src/itr.html#implementation","text":"Header: sstd/src/itr.hpp","title":"Implementation"},{"location":"src/math.html","text":"math Abstract math.hpp contains functions for mathmatical and statistical calculations. math.hpp \u306f\u6570\u5b66\u30fb\u7d71\u8a08\u8a08\u7b97\u7528\u306e\u95a2\u6570\u3092\u53ce\u9332\u3057\u307e\u3059\uff0e Header file namespace sstd { float round2even ( float n ); double round2even ( double n ); float round2odd ( float n ); double round2odd ( double n ); template < typename T > T sum ( const std :: vector < T >& rhs ); template < typename T > T sum ( const std :: vector < T >& rhs , uint a , uint b ); template < class Itr > typename std :: iterator_traits < Itr >:: value_type sum ( const Itr first , const Itr last ); // using Pairwise summation algorithm. float sum ( const std :: vector < float >:: iterator first , const std :: vector < float >:: iterator last ); float sum ( const std :: vector < float >& rhs , uint a , uint b ); // \u914d\u5217\u306e a \u756a\u76ee\u304b\u3089 b \u756a\u76ee\u307e\u3067\u306e\u5408\u8a08. sum of the a th to b th of array. float sum ( const std :: vector < float >& rhs ); float sum_abs ( const std :: vector < float >& rhs ); float ave ( const std :: vector < float >& rhs ); // \u5e73\u5747\u5024: average float med ( std :: vector < float > rhs ); // \u4e2d\u592e\u5024: median // copy rhs // If rhs.size () is even, average of the two median values is returned. // float mod (const std::vector<float>& rhs); // \u6700\u983b\u5024: mode float var ( const std :: vector < float >& rhs ); // \u4e0d\u504f\u5206\u6563/\u6a19\u672c\u5206\u6563 (variance): u^2 = (1/(n-1))*\u03a3(x_i-\u03bc)^2 float var_p ( const std :: vector < float >& rhs ); // \u6bcd\u5206\u6563 (variance population): \u03c3^2 = (1/n)*\u03a3(x_i-\u03bc)^2 float stdev ( const std :: vector < float >& rhs ); // \u6a19\u672c\u6a19\u6e96\u504f\u5dee (sample standard deviation): u = SQRT( (1/(n-1))*\u03a3(x_i-\u03bc)^2 ) float stdev_p ( const std :: vector < float >& rhs ); // \u6a19\u6e96\u504f\u5dee (standard deviation): \u03c3 = SQRT( (1/n)*\u03a3(x_i-\u03bc)^2 ) double sum ( const std :: vector < double >:: iterator first , const std :: vector < double >:: iterator last ); double sum ( const std :: vector < double >& rhs , uint a , uint b ); // \u914d\u5217\u306e a \u756a\u76ee\u304b\u3089 b \u756a\u76ee\u307e\u3067\u306e\u5408\u8a08. sum of the a th to b th of array. double sum ( const std :: vector < double >& rhs ); double sum_abs ( const std :: vector < double >& rhs ); double ave ( const std :: vector < double >& rhs ); // \u5e73\u5747\u5024: average double med ( std :: vector < double > rhs ); // \u4e2d\u592e\u5024: median // copy rhs // If rhs.size () is even, average of the two median values is returned. // double mod (const std::vector<double>& rhs); // \u6700\u983b\u5024: mode double var ( const std :: vector < double >& rhs ); // \u4e0d\u504f\u5206\u6563/\u6a19\u672c\u5206\u6563 (variance): u^2 = (1/(n-1))*\u03a3(x_i-\u03bc)^2 double var_p ( const std :: vector < double >& rhs ); // \u6bcd\u5206\u6563 (variance population): \u03c3^2 = (1/n)*\u03a3(x_i-\u03bc)^2 double stdev ( const std :: vector < double >& rhs ); // \u6a19\u672c\u6a19\u6e96\u504f\u5dee (sample standard deviation): u = SQRT( (1/(n-1))*\u03a3(x_i-\u03bc)^2 ) double stdev_p ( const std :: vector < double >& rhs ); // \u6a19\u6e96\u504f\u5dee (standard deviation): \u03c3 = SQRT( (1/n)*\u03a3(x_i-\u03bc)^2 ) // K: using Kahan summation algorithm float sumK ( const std :: vector < float >& rhs , uint a , uint b ); // \u914d\u5217\u306e a \u756a\u76ee\u304b\u3089 b \u756a\u76ee\u307e\u3067\u306e\u5408\u8a08. sum of the a th to b th of array. float sumK ( const std :: vector < float >& rhs ); float sumK_abs ( const std :: vector < float >& rhs ); float aveK ( const std :: vector < float >& rhs ); // \u5e73\u5747\u5024: average float aveK ( const std :: vector < float >& rhs , uint num ); // \u5e73\u5747\u5024: average in the first num elements. float varK ( const std :: vector < float >& rhs ); // \u4e0d\u504f\u5206\u6563/\u6a19\u672c\u5206\u6563 (variance): u^2 = (1/(n-1))*\u03a3(x_i-\u03bc)^2 float varK_p ( const std :: vector < float >& rhs ); // \u6bcd\u5206\u6563 (variance population): \u03c3^2 = (1/n)*\u03a3(x_i-\u03bc)^2 float stdevK ( const std :: vector < float >& rhs ); // \u6a19\u672c\u6a19\u6e96\u504f\u5dee (sample standard deviation): u = SQRT( (1/(n-1))*\u03a3(x_i-\u03bc)^2 ) float stdevK_p ( const std :: vector < float >& rhs ); // \u6a19\u6e96\u504f\u5dee (standard deviation): \u03c3 = SQRT( (1/n)*\u03a3(x_i-\u03bc)^2 ) double sumK ( const std :: vector < double >& rhs ); double sumK ( const std :: vector < double >& rhs , uint a , uint b ); // \u914d\u5217\u306e a \u756a\u76ee\u304b\u3089 b \u756a\u76ee\u307e\u3067\u306e\u5408\u8a08. sum of the a th to b th of array. double sumK_abs ( const std :: vector < double >& rhs ); double aveK ( const std :: vector < double >& rhs ); // \u5e73\u5747\u5024: average double aveK ( const std :: vector < double >& rhs , uint num ); // \u5e73\u5747\u5024: average in the first num elements. double varK ( const std :: vector < double >& rhs ); // \u4e0d\u504f\u5206\u6563/\u6a19\u672c\u5206\u6563 (variance): u^2 = (1/(n-1))*\u03a3(x_i-\u03bc)^2 double varK_p ( const std :: vector < double >& rhs ); // \u6bcd\u5206\u6563 (variance population): \u03c3^2 = (1/n)*\u03a3(x_i-\u03bc)^2 double stdevK ( const std :: vector < double >& rhs ); // \u6a19\u672c\u6a19\u6e96\u504f\u5dee (sample standard deviation): u = SQRT( (1/(n-1))*\u03a3(x_i-\u03bc)^2 ) double stdevK_p ( const std :: vector < double >& rhs ); // \u6a19\u6e96\u504f\u5dee (standard deviation): \u03c3 = SQRT( (1/n)*\u03a3(x_i-\u03bc)^2 ) std :: vector < uint64 > prime ( uint64 rhs ); // get a list of prime number under rhs. struct fact { uint64 prime ; uint64 num ; }; std :: vector < struct fact > factor ( uint64 rhs ); // get a list of prime factorization std :: vector < uint64 > divisor ( const std :: vector < struct sstd :: fact >& rhs ); // get a list of all divisors std :: vector < uint64 > divisor ( uint64 rhs ); // get a list of all of the divisors. uint8 pow ( const uint8 & base , const uint8 & exp ); uint16 pow ( const uint16 & base , const uint16 & exp ); uint32 pow ( const uint32 & base , const uint32 & exp ); uint64 pow ( const uint64 & base , const uint64 & exp ); float pow ( const float & base , const float & exp ); double pow ( const double & base , const double & exp ); //----------------------------------------------------------------------------------------------------------------------------------------------- template < typename T > inline T min ( const std :: vector < T >& rhs ); template < typename T > inline T min_abs ( const std :: vector < T >& rhs ); template < typename T > inline T max ( const std :: vector < T >& rhs ); template < typename T > inline T max_abs ( const std :: vector < T >& rhs ); template < typename T > inline T min ( const sstd :: mat_c < T >& rhs ); template < typename T > inline T min_abs ( const sstd :: mat_c < T >& rhs ); template < typename T > inline T max ( const sstd :: mat_c < T >& rhs ); template < typename T > inline T max_abs ( const sstd :: mat_c < T >& rhs ); template < typename T > inline T min ( const sstd :: mat_r < T >& rhs ); template < typename T > inline T min_abs ( const sstd :: mat_r < T >& rhs ); template < typename T > inline T max ( const sstd :: mat_r < T >& rhs ); template < typename T > inline T max_abs ( const sstd :: mat_r < T >& rhs ); template < typename T > inline T min ( T && lhs , T && rhs ); template < typename T > inline T min ( T && head1 , T && head2 , T && tail ); template < typename Head , typename ... Tail > inline Head min ( Head && head1 , Head && head2 , Tail && ... tail ); template < typename T > inline T max ( T && lhs , T && rhs ); template < typename T > inline T max ( T && head1 , T && head2 , T && tail ); template < typename Head , typename ... Tail > inline Head max ( Head && head1 , Head && head2 , Tail && ... tail ); //----------------------------------------------------------------------------------------------------------------------------------------------- template < typename T > uint argmin ( const std :: vector < T >& rhs ); template < typename T > uint argmin_abs ( const std :: vector < T >& rhs ); template < typename T > uint argmax ( const std :: vector < T >& rhs ); template < typename T > uint argmax_abs ( const std :: vector < T >& rhs ); template < typename T > uint argmin ( const sstd :: mat_c < T >& rhs ); template < typename T > uint argmin_abs ( const sstd :: mat_c < T >& rhs ); template < typename T > uint argmax ( const sstd :: mat_c < T >& rhs ); template < typename T > uint argmax_abs ( const sstd :: mat_c < T >& rhs ); template < typename T > uint argmin ( const sstd :: mat_r < T >& rhs ); template < typename T > uint argmin_abs ( const sstd :: mat_r < T >& rhs ); template < typename T > uint argmax ( const sstd :: mat_r < T >& rhs ); template < typename T > uint argmax_abs ( const sstd :: mat_r < T >& rhs ); /* // TODO: argmin // TODO: argmax template<typename T> std::tuple<uint,uint> argminXY (const sstd::mat_c<T>& rhs); template<typename T> std::tuple<uint,uint> argminXY_abs(const sstd::mat_c<T>& rhs); template<typename T> std::tuple<uint,uint> argmaxXY (const sstd::mat_c<T>& rhs); template<typename T> std::tuple<uint,uint> argmaxXY_abs(const sstd::mat_c<T>& rhs); template<typename T> std::tuple<uint,uint> argminXY (const sstd::mat_r<T>& rhs); template<typename T> std::tuple<uint,uint> argminXY_abs(const sstd::mat_r<T>& rhs); template<typename T> std::tuple<uint,uint> argmaxXY (const sstd::mat_r<T>& rhs); template<typename T> std::tuple<uint,uint> argmaxXY_abs(const sstd::mat_r<T>& rhs); //*/ //----------------------------------------------------------------------------------------------------------------------------------------------- // binary search template < typename T > T nearest_down ( const std :: vector < T >& v , const T & value ); template < typename T > T nearest_up ( const std :: vector < T >& v , const T & value ); template < typename T > uint argnearest_down ( const std :: vector < T >& v , const T & value ); template < typename T > uint argnearest_up ( const std :: vector < T >& v , const T & value ); //----------------------------------------------------------------------------------------------------------------------------------------------- template < typename T > inline void sort ( std :: vector < T >& rhs ){ std :: sort ( rhs . begin (), rhs . end ()); } // Ascending: \u6607\u9806: 0, 1, 2, ... template < typename T > inline std :: vector < T > sorted ( const std :: vector < T >& rhs_in ){ std :: vector < T > rhs = rhs_in ; std :: sort ( rhs . begin (), rhs . end ()); return rhs ; } // Ascending: \u6607\u9806: 0, 1, 2, ... template < typename T > inline std :: vector < T > sorted ( std :: vector < T >&& rhs ){ std :: sort ( rhs . begin (), rhs . end ()); return rhs ; } // Ascending: \u6607\u9806: 0, 1, 2, ... template < typename T > inline void sort_gr ( std :: vector < T >& rhs ){ std :: sort ( rhs . begin (), rhs . end (), std :: greater < T > ()); } // Descending: \u964d\u9806: 9, 8, 7, ... template < typename T > inline std :: vector < T > sorted_gr ( const std :: vector < T >& rhs_in ){ std :: vector < T > rhs = rhs_in ; std :: sort ( rhs . begin (), rhs . end (), std :: greater < T > ()); return rhs ; } // Descending: \u964d\u9806: 9, 8, 7, ... template < typename T > inline std :: vector < T > sorted_gr ( std :: vector < T >&& rhs ){ std :: sort ( rhs . begin (), rhs . end (), std :: greater < T > ()); return rhs ; } // Descending: \u964d\u9806: 9, 8, 7, ... //----------------------------------------------------------------------------------------------------------------------------------------------- template < typename T > std :: vector < T > nonzero ( const std :: vector < T >& rhs ); // template <typename T> void padding (std::vector<T>& vecLhs, std::vector<T>& vecRhs); // <--> sstd::suppress(); // template <typename T> void suppress(std::vector<T>& vecLhs, std::vector<T>& vecRhs); // <--> sstd::padding(); or zfill template < typename ... Args > void suppress ( Args & ... args ); } Usage Rounding main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: round2even ( 1.5 ) ); sstd :: printn ( sstd :: round2even ( 2.5 ) ); sstd :: printn ( sstd :: round2odd ( 1.5 ) ); sstd :: printn ( sstd :: round2odd ( 2.5 ) ); } Execution result sstd::round2even(1.5) = 2. sstd::round2even(2.5) = 2. sstd::round2odd(1.5) = 1. sstd::round2odd(2.5) = 3. Statistical processing main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < double > v = { -5 , -4 , -3 , -2 , -1 , 0 , 1 , 2 , 3 , 4 }; sstd :: printn ( sstd :: sum ( v ) ); sstd :: printn ( sstd :: sum_abs ( v ) ); sstd :: printn ( sstd :: ave ( v ) ); sstd :: printn ( sstd :: med ( v ) ); sstd :: printn ( sstd :: var ( v ) ); sstd :: printn ( sstd :: var_p ( v ) ); sstd :: printn ( sstd :: stdev ( v ) ); sstd :: printn ( sstd :: stdev_p ( v ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: min ( v ) ); sstd :: printn ( sstd :: min_abs ( v ) ); sstd :: printn ( sstd :: max ( v ) ); sstd :: printn ( sstd :: max_abs ( v ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: argmin ( v ) ); sstd :: printn ( sstd :: argmin_abs ( v ) ); sstd :: printn ( sstd :: argmax ( v ) ); sstd :: printn ( sstd :: argmax_abs ( v ) ); } Execution result sstd::sum( v ) = -5. sstd::sum_abs( v ) = 25. sstd::ave( v ) = -0.5 sstd::med( v ) = -0.5 sstd::var( v ) = 9.16667 sstd::var_p( v ) = 8.25 sstd::stdev( v ) = 3.02765 sstd::stdev_p( v ) = 2.87228 sstd::min( v ) = -5. sstd::min_abs( v ) = 0. sstd::max( v ) = 4. sstd::max_abs( v ) = -5. sstd::argmin( v ) = 0 sstd::argmin_abs( v ) = 5 sstd::argmax( v ) = 9 sstd::argmax_abs( v ) = 0 Searching main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < double > v = { -5 , -4 , -3 , -2 , -1 , 0 , 1 , 2 , 3 , 4 }; sstd :: printn ( sstd :: nearest_down ( v , 0.5 ) ); sstd :: printn ( sstd :: nearest_up ( v , 0.5 ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: argnearest_down ( v , 0.5 ) ); sstd :: printn ( sstd :: argnearest_up ( v , 0.5 ) ); } Execution result sstd::nearest_down(v, 0.5) = 0. sstd::nearest_up(v, 0.5) = 1. sstd::argnearest_down(v, 0.5) = 5 sstd::argnearest_up(v, 0.5) = 6 Sorting main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < double > v_base = { -1 , -5 , 2 , -3 , 3 , 4 , -2 , 0 , 1 , -4 }; sstd :: printn ( sstd :: sorted ( v_base ) ); sstd :: printn ( sstd :: sorted_gr ( v_base ) ); printf ( \" \\n \" ); std :: vector < double > v = v_base ; sstd :: sort ( v ); sstd :: printn ( v ); std :: vector < double > v_gr = v_base ; sstd :: sort_gr ( v_gr ); sstd :: printn ( v_gr ); } Execution result sstd::sorted( v_base ) = [-5. -4. -3. -2. -1. 0. 1. 2. 3. 4.] sstd::sorted_gr( v_base ) = [4. 3. 2. 1. 0. -1. -2. -3. -4. -5.] v = [-5. -4. -3. -2. -1. 0. 1. 2. 3. 4.] v_gr = [4. 3. 2. 1. 0. -1. -2. -3. -4. -5.] Preprocessing main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < double > v = { 1 , 2 , 3 , 0 , 4 }; sstd :: printn ( sstd :: nonzero ( v ) ); // suppressing vector to the same length before 0. std :: vector < double > in1 = { 1 , 2 , 3 , 0 , 4 }; std :: vector < double > in2 = { 1 , 2 , 3 }; std :: vector < uint > in3 = { 1 , 2 , 3 }; std :: vector < double > in4 = { 1 , 2 , 3 , 4 }; sstd :: suppress ( in1 , in2 , in3 , in4 ); sstd :: printn ( in1 ); sstd :: printn ( in2 ); sstd :: printn ( in3 ); sstd :: printn ( in4 ); } Execution result sstd::nonzero(v) = [1. 2. 3.] in1 = [1. 2. 3.] in2 = [1. 2. 3.] in3 = [1 2 3] in4 = [1. 2. 3.] Implementation Source: sstd/src/math.cpp Header: sstd/src/math.hpp Test: test/math.hpp","title":"math"},{"location":"src/math.html#math","text":"","title":"math"},{"location":"src/math.html#abstract","text":"math.hpp contains functions for mathmatical and statistical calculations. math.hpp \u306f\u6570\u5b66\u30fb\u7d71\u8a08\u8a08\u7b97\u7528\u306e\u95a2\u6570\u3092\u53ce\u9332\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/math.html#header-file","text":"namespace sstd { float round2even ( float n ); double round2even ( double n ); float round2odd ( float n ); double round2odd ( double n ); template < typename T > T sum ( const std :: vector < T >& rhs ); template < typename T > T sum ( const std :: vector < T >& rhs , uint a , uint b ); template < class Itr > typename std :: iterator_traits < Itr >:: value_type sum ( const Itr first , const Itr last ); // using Pairwise summation algorithm. float sum ( const std :: vector < float >:: iterator first , const std :: vector < float >:: iterator last ); float sum ( const std :: vector < float >& rhs , uint a , uint b ); // \u914d\u5217\u306e a \u756a\u76ee\u304b\u3089 b \u756a\u76ee\u307e\u3067\u306e\u5408\u8a08. sum of the a th to b th of array. float sum ( const std :: vector < float >& rhs ); float sum_abs ( const std :: vector < float >& rhs ); float ave ( const std :: vector < float >& rhs ); // \u5e73\u5747\u5024: average float med ( std :: vector < float > rhs ); // \u4e2d\u592e\u5024: median // copy rhs // If rhs.size () is even, average of the two median values is returned. // float mod (const std::vector<float>& rhs); // \u6700\u983b\u5024: mode float var ( const std :: vector < float >& rhs ); // \u4e0d\u504f\u5206\u6563/\u6a19\u672c\u5206\u6563 (variance): u^2 = (1/(n-1))*\u03a3(x_i-\u03bc)^2 float var_p ( const std :: vector < float >& rhs ); // \u6bcd\u5206\u6563 (variance population): \u03c3^2 = (1/n)*\u03a3(x_i-\u03bc)^2 float stdev ( const std :: vector < float >& rhs ); // \u6a19\u672c\u6a19\u6e96\u504f\u5dee (sample standard deviation): u = SQRT( (1/(n-1))*\u03a3(x_i-\u03bc)^2 ) float stdev_p ( const std :: vector < float >& rhs ); // \u6a19\u6e96\u504f\u5dee (standard deviation): \u03c3 = SQRT( (1/n)*\u03a3(x_i-\u03bc)^2 ) double sum ( const std :: vector < double >:: iterator first , const std :: vector < double >:: iterator last ); double sum ( const std :: vector < double >& rhs , uint a , uint b ); // \u914d\u5217\u306e a \u756a\u76ee\u304b\u3089 b \u756a\u76ee\u307e\u3067\u306e\u5408\u8a08. sum of the a th to b th of array. double sum ( const std :: vector < double >& rhs ); double sum_abs ( const std :: vector < double >& rhs ); double ave ( const std :: vector < double >& rhs ); // \u5e73\u5747\u5024: average double med ( std :: vector < double > rhs ); // \u4e2d\u592e\u5024: median // copy rhs // If rhs.size () is even, average of the two median values is returned. // double mod (const std::vector<double>& rhs); // \u6700\u983b\u5024: mode double var ( const std :: vector < double >& rhs ); // \u4e0d\u504f\u5206\u6563/\u6a19\u672c\u5206\u6563 (variance): u^2 = (1/(n-1))*\u03a3(x_i-\u03bc)^2 double var_p ( const std :: vector < double >& rhs ); // \u6bcd\u5206\u6563 (variance population): \u03c3^2 = (1/n)*\u03a3(x_i-\u03bc)^2 double stdev ( const std :: vector < double >& rhs ); // \u6a19\u672c\u6a19\u6e96\u504f\u5dee (sample standard deviation): u = SQRT( (1/(n-1))*\u03a3(x_i-\u03bc)^2 ) double stdev_p ( const std :: vector < double >& rhs ); // \u6a19\u6e96\u504f\u5dee (standard deviation): \u03c3 = SQRT( (1/n)*\u03a3(x_i-\u03bc)^2 ) // K: using Kahan summation algorithm float sumK ( const std :: vector < float >& rhs , uint a , uint b ); // \u914d\u5217\u306e a \u756a\u76ee\u304b\u3089 b \u756a\u76ee\u307e\u3067\u306e\u5408\u8a08. sum of the a th to b th of array. float sumK ( const std :: vector < float >& rhs ); float sumK_abs ( const std :: vector < float >& rhs ); float aveK ( const std :: vector < float >& rhs ); // \u5e73\u5747\u5024: average float aveK ( const std :: vector < float >& rhs , uint num ); // \u5e73\u5747\u5024: average in the first num elements. float varK ( const std :: vector < float >& rhs ); // \u4e0d\u504f\u5206\u6563/\u6a19\u672c\u5206\u6563 (variance): u^2 = (1/(n-1))*\u03a3(x_i-\u03bc)^2 float varK_p ( const std :: vector < float >& rhs ); // \u6bcd\u5206\u6563 (variance population): \u03c3^2 = (1/n)*\u03a3(x_i-\u03bc)^2 float stdevK ( const std :: vector < float >& rhs ); // \u6a19\u672c\u6a19\u6e96\u504f\u5dee (sample standard deviation): u = SQRT( (1/(n-1))*\u03a3(x_i-\u03bc)^2 ) float stdevK_p ( const std :: vector < float >& rhs ); // \u6a19\u6e96\u504f\u5dee (standard deviation): \u03c3 = SQRT( (1/n)*\u03a3(x_i-\u03bc)^2 ) double sumK ( const std :: vector < double >& rhs ); double sumK ( const std :: vector < double >& rhs , uint a , uint b ); // \u914d\u5217\u306e a \u756a\u76ee\u304b\u3089 b \u756a\u76ee\u307e\u3067\u306e\u5408\u8a08. sum of the a th to b th of array. double sumK_abs ( const std :: vector < double >& rhs ); double aveK ( const std :: vector < double >& rhs ); // \u5e73\u5747\u5024: average double aveK ( const std :: vector < double >& rhs , uint num ); // \u5e73\u5747\u5024: average in the first num elements. double varK ( const std :: vector < double >& rhs ); // \u4e0d\u504f\u5206\u6563/\u6a19\u672c\u5206\u6563 (variance): u^2 = (1/(n-1))*\u03a3(x_i-\u03bc)^2 double varK_p ( const std :: vector < double >& rhs ); // \u6bcd\u5206\u6563 (variance population): \u03c3^2 = (1/n)*\u03a3(x_i-\u03bc)^2 double stdevK ( const std :: vector < double >& rhs ); // \u6a19\u672c\u6a19\u6e96\u504f\u5dee (sample standard deviation): u = SQRT( (1/(n-1))*\u03a3(x_i-\u03bc)^2 ) double stdevK_p ( const std :: vector < double >& rhs ); // \u6a19\u6e96\u504f\u5dee (standard deviation): \u03c3 = SQRT( (1/n)*\u03a3(x_i-\u03bc)^2 ) std :: vector < uint64 > prime ( uint64 rhs ); // get a list of prime number under rhs. struct fact { uint64 prime ; uint64 num ; }; std :: vector < struct fact > factor ( uint64 rhs ); // get a list of prime factorization std :: vector < uint64 > divisor ( const std :: vector < struct sstd :: fact >& rhs ); // get a list of all divisors std :: vector < uint64 > divisor ( uint64 rhs ); // get a list of all of the divisors. uint8 pow ( const uint8 & base , const uint8 & exp ); uint16 pow ( const uint16 & base , const uint16 & exp ); uint32 pow ( const uint32 & base , const uint32 & exp ); uint64 pow ( const uint64 & base , const uint64 & exp ); float pow ( const float & base , const float & exp ); double pow ( const double & base , const double & exp ); //----------------------------------------------------------------------------------------------------------------------------------------------- template < typename T > inline T min ( const std :: vector < T >& rhs ); template < typename T > inline T min_abs ( const std :: vector < T >& rhs ); template < typename T > inline T max ( const std :: vector < T >& rhs ); template < typename T > inline T max_abs ( const std :: vector < T >& rhs ); template < typename T > inline T min ( const sstd :: mat_c < T >& rhs ); template < typename T > inline T min_abs ( const sstd :: mat_c < T >& rhs ); template < typename T > inline T max ( const sstd :: mat_c < T >& rhs ); template < typename T > inline T max_abs ( const sstd :: mat_c < T >& rhs ); template < typename T > inline T min ( const sstd :: mat_r < T >& rhs ); template < typename T > inline T min_abs ( const sstd :: mat_r < T >& rhs ); template < typename T > inline T max ( const sstd :: mat_r < T >& rhs ); template < typename T > inline T max_abs ( const sstd :: mat_r < T >& rhs ); template < typename T > inline T min ( T && lhs , T && rhs ); template < typename T > inline T min ( T && head1 , T && head2 , T && tail ); template < typename Head , typename ... Tail > inline Head min ( Head && head1 , Head && head2 , Tail && ... tail ); template < typename T > inline T max ( T && lhs , T && rhs ); template < typename T > inline T max ( T && head1 , T && head2 , T && tail ); template < typename Head , typename ... Tail > inline Head max ( Head && head1 , Head && head2 , Tail && ... tail ); //----------------------------------------------------------------------------------------------------------------------------------------------- template < typename T > uint argmin ( const std :: vector < T >& rhs ); template < typename T > uint argmin_abs ( const std :: vector < T >& rhs ); template < typename T > uint argmax ( const std :: vector < T >& rhs ); template < typename T > uint argmax_abs ( const std :: vector < T >& rhs ); template < typename T > uint argmin ( const sstd :: mat_c < T >& rhs ); template < typename T > uint argmin_abs ( const sstd :: mat_c < T >& rhs ); template < typename T > uint argmax ( const sstd :: mat_c < T >& rhs ); template < typename T > uint argmax_abs ( const sstd :: mat_c < T >& rhs ); template < typename T > uint argmin ( const sstd :: mat_r < T >& rhs ); template < typename T > uint argmin_abs ( const sstd :: mat_r < T >& rhs ); template < typename T > uint argmax ( const sstd :: mat_r < T >& rhs ); template < typename T > uint argmax_abs ( const sstd :: mat_r < T >& rhs ); /* // TODO: argmin // TODO: argmax template<typename T> std::tuple<uint,uint> argminXY (const sstd::mat_c<T>& rhs); template<typename T> std::tuple<uint,uint> argminXY_abs(const sstd::mat_c<T>& rhs); template<typename T> std::tuple<uint,uint> argmaxXY (const sstd::mat_c<T>& rhs); template<typename T> std::tuple<uint,uint> argmaxXY_abs(const sstd::mat_c<T>& rhs); template<typename T> std::tuple<uint,uint> argminXY (const sstd::mat_r<T>& rhs); template<typename T> std::tuple<uint,uint> argminXY_abs(const sstd::mat_r<T>& rhs); template<typename T> std::tuple<uint,uint> argmaxXY (const sstd::mat_r<T>& rhs); template<typename T> std::tuple<uint,uint> argmaxXY_abs(const sstd::mat_r<T>& rhs); //*/ //----------------------------------------------------------------------------------------------------------------------------------------------- // binary search template < typename T > T nearest_down ( const std :: vector < T >& v , const T & value ); template < typename T > T nearest_up ( const std :: vector < T >& v , const T & value ); template < typename T > uint argnearest_down ( const std :: vector < T >& v , const T & value ); template < typename T > uint argnearest_up ( const std :: vector < T >& v , const T & value ); //----------------------------------------------------------------------------------------------------------------------------------------------- template < typename T > inline void sort ( std :: vector < T >& rhs ){ std :: sort ( rhs . begin (), rhs . end ()); } // Ascending: \u6607\u9806: 0, 1, 2, ... template < typename T > inline std :: vector < T > sorted ( const std :: vector < T >& rhs_in ){ std :: vector < T > rhs = rhs_in ; std :: sort ( rhs . begin (), rhs . end ()); return rhs ; } // Ascending: \u6607\u9806: 0, 1, 2, ... template < typename T > inline std :: vector < T > sorted ( std :: vector < T >&& rhs ){ std :: sort ( rhs . begin (), rhs . end ()); return rhs ; } // Ascending: \u6607\u9806: 0, 1, 2, ... template < typename T > inline void sort_gr ( std :: vector < T >& rhs ){ std :: sort ( rhs . begin (), rhs . end (), std :: greater < T > ()); } // Descending: \u964d\u9806: 9, 8, 7, ... template < typename T > inline std :: vector < T > sorted_gr ( const std :: vector < T >& rhs_in ){ std :: vector < T > rhs = rhs_in ; std :: sort ( rhs . begin (), rhs . end (), std :: greater < T > ()); return rhs ; } // Descending: \u964d\u9806: 9, 8, 7, ... template < typename T > inline std :: vector < T > sorted_gr ( std :: vector < T >&& rhs ){ std :: sort ( rhs . begin (), rhs . end (), std :: greater < T > ()); return rhs ; } // Descending: \u964d\u9806: 9, 8, 7, ... //----------------------------------------------------------------------------------------------------------------------------------------------- template < typename T > std :: vector < T > nonzero ( const std :: vector < T >& rhs ); // template <typename T> void padding (std::vector<T>& vecLhs, std::vector<T>& vecRhs); // <--> sstd::suppress(); // template <typename T> void suppress(std::vector<T>& vecLhs, std::vector<T>& vecRhs); // <--> sstd::padding(); or zfill template < typename ... Args > void suppress ( Args & ... args ); }","title":"Header file"},{"location":"src/math.html#usage","text":"","title":"Usage"},{"location":"src/math.html#rounding","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: round2even ( 1.5 ) ); sstd :: printn ( sstd :: round2even ( 2.5 ) ); sstd :: printn ( sstd :: round2odd ( 1.5 ) ); sstd :: printn ( sstd :: round2odd ( 2.5 ) ); } Execution result sstd::round2even(1.5) = 2. sstd::round2even(2.5) = 2. sstd::round2odd(1.5) = 1. sstd::round2odd(2.5) = 3.","title":"Rounding"},{"location":"src/math.html#statistical-processing","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < double > v = { -5 , -4 , -3 , -2 , -1 , 0 , 1 , 2 , 3 , 4 }; sstd :: printn ( sstd :: sum ( v ) ); sstd :: printn ( sstd :: sum_abs ( v ) ); sstd :: printn ( sstd :: ave ( v ) ); sstd :: printn ( sstd :: med ( v ) ); sstd :: printn ( sstd :: var ( v ) ); sstd :: printn ( sstd :: var_p ( v ) ); sstd :: printn ( sstd :: stdev ( v ) ); sstd :: printn ( sstd :: stdev_p ( v ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: min ( v ) ); sstd :: printn ( sstd :: min_abs ( v ) ); sstd :: printn ( sstd :: max ( v ) ); sstd :: printn ( sstd :: max_abs ( v ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: argmin ( v ) ); sstd :: printn ( sstd :: argmin_abs ( v ) ); sstd :: printn ( sstd :: argmax ( v ) ); sstd :: printn ( sstd :: argmax_abs ( v ) ); } Execution result sstd::sum( v ) = -5. sstd::sum_abs( v ) = 25. sstd::ave( v ) = -0.5 sstd::med( v ) = -0.5 sstd::var( v ) = 9.16667 sstd::var_p( v ) = 8.25 sstd::stdev( v ) = 3.02765 sstd::stdev_p( v ) = 2.87228 sstd::min( v ) = -5. sstd::min_abs( v ) = 0. sstd::max( v ) = 4. sstd::max_abs( v ) = -5. sstd::argmin( v ) = 0 sstd::argmin_abs( v ) = 5 sstd::argmax( v ) = 9 sstd::argmax_abs( v ) = 0","title":"Statistical processing"},{"location":"src/math.html#searching","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < double > v = { -5 , -4 , -3 , -2 , -1 , 0 , 1 , 2 , 3 , 4 }; sstd :: printn ( sstd :: nearest_down ( v , 0.5 ) ); sstd :: printn ( sstd :: nearest_up ( v , 0.5 ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: argnearest_down ( v , 0.5 ) ); sstd :: printn ( sstd :: argnearest_up ( v , 0.5 ) ); } Execution result sstd::nearest_down(v, 0.5) = 0. sstd::nearest_up(v, 0.5) = 1. sstd::argnearest_down(v, 0.5) = 5 sstd::argnearest_up(v, 0.5) = 6","title":"Searching"},{"location":"src/math.html#sorting","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < double > v_base = { -1 , -5 , 2 , -3 , 3 , 4 , -2 , 0 , 1 , -4 }; sstd :: printn ( sstd :: sorted ( v_base ) ); sstd :: printn ( sstd :: sorted_gr ( v_base ) ); printf ( \" \\n \" ); std :: vector < double > v = v_base ; sstd :: sort ( v ); sstd :: printn ( v ); std :: vector < double > v_gr = v_base ; sstd :: sort_gr ( v_gr ); sstd :: printn ( v_gr ); } Execution result sstd::sorted( v_base ) = [-5. -4. -3. -2. -1. 0. 1. 2. 3. 4.] sstd::sorted_gr( v_base ) = [4. 3. 2. 1. 0. -1. -2. -3. -4. -5.] v = [-5. -4. -3. -2. -1. 0. 1. 2. 3. 4.] v_gr = [4. 3. 2. 1. 0. -1. -2. -3. -4. -5.]","title":"Sorting"},{"location":"src/math.html#preprocessing","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < double > v = { 1 , 2 , 3 , 0 , 4 }; sstd :: printn ( sstd :: nonzero ( v ) ); // suppressing vector to the same length before 0. std :: vector < double > in1 = { 1 , 2 , 3 , 0 , 4 }; std :: vector < double > in2 = { 1 , 2 , 3 }; std :: vector < uint > in3 = { 1 , 2 , 3 }; std :: vector < double > in4 = { 1 , 2 , 3 , 4 }; sstd :: suppress ( in1 , in2 , in3 , in4 ); sstd :: printn ( in1 ); sstd :: printn ( in2 ); sstd :: printn ( in3 ); sstd :: printn ( in4 ); } Execution result sstd::nonzero(v) = [1. 2. 3.] in1 = [1. 2. 3.] in2 = [1. 2. 3.] in3 = [1 2 3] in4 = [1. 2. 3.]","title":"Preprocessing"},{"location":"src/math.html#implementation","text":"Source: sstd/src/math.cpp Header: sstd/src/math.hpp Test: test/math.hpp","title":"Implementation"},{"location":"src/pdbg.html","text":"pdbg Abstract pdbg prints debug information. pdbg \u306f\u30c7\u30d0\u30c3\u30b0\u60c5\u5831\u3092\u51fa\u529b\u3057\u307e\u3059\uff0e Header file namespace sstd { inline void pdbg (...){} inline void pdbg_if (...){} inline void pdbg_if_exit (...){} inline void pdbg_if_stop_exit (...){} inline void dbg (...){} inline void ndbg (...){} } Usage main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: pdbg ( \"ERROR: printing error reasons. \\n \" ); printf ( \" \\n \" ); printf ( \"True: \" ); sstd :: pdbg_if ( true , \"ERROR: printing error reasons. \\n \" ); printf ( \"False: \" ); sstd :: pdbg_if ( false , \"ERROR: printing error reasons. \\n \" ); printf ( \" \\n \" ); return 0 ; } Execution result .././tmp/.._._docs_src_docs_src_pdbg.md_32.cpp/.._._docs_src_docs_src_pdbg.md_32.cpp: main(4): \u001b[31mERROR: printing error reasons. \u001b[0m True: .././tmp/.._._docs_src_docs_src_pdbg.md_32.cpp/.._._docs_src_docs_src_pdbg.md_32.cpp: main(7): \u001b[31mERROR: printing error reasons. \u001b[0mFalse: Implementation Source: header only Header: sstd/src/pdbg.hpp Test: test/XXXXXX.hpp (Not implemented yet)","title":"pdbg"},{"location":"src/pdbg.html#pdbg","text":"","title":"pdbg"},{"location":"src/pdbg.html#abstract","text":"pdbg prints debug information. pdbg \u306f\u30c7\u30d0\u30c3\u30b0\u60c5\u5831\u3092\u51fa\u529b\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/pdbg.html#header-file","text":"namespace sstd { inline void pdbg (...){} inline void pdbg_if (...){} inline void pdbg_if_exit (...){} inline void pdbg_if_stop_exit (...){} inline void dbg (...){} inline void ndbg (...){} }","title":"Header file"},{"location":"src/pdbg.html#usage","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: pdbg ( \"ERROR: printing error reasons. \\n \" ); printf ( \" \\n \" ); printf ( \"True: \" ); sstd :: pdbg_if ( true , \"ERROR: printing error reasons. \\n \" ); printf ( \"False: \" ); sstd :: pdbg_if ( false , \"ERROR: printing error reasons. \\n \" ); printf ( \" \\n \" ); return 0 ; } Execution result .././tmp/.._._docs_src_docs_src_pdbg.md_32.cpp/.._._docs_src_docs_src_pdbg.md_32.cpp: main(4): \u001b[31mERROR: printing error reasons. \u001b[0m True: .././tmp/.._._docs_src_docs_src_pdbg.md_32.cpp/.._._docs_src_docs_src_pdbg.md_32.cpp: main(7): \u001b[31mERROR: printing error reasons. \u001b[0mFalse:","title":"Usage"},{"location":"src/pdbg.html#implementation","text":"Source: header only Header: sstd/src/pdbg.hpp Test: test/XXXXXX.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/pid.html","text":"pid Abstract getpid returns the PID of its own process. getpid \u306f\u81ea\u30d7\u30ed\u30bb\u30b9\u306e PID \u3092\u8fd4\u3057\u307e\u3059\uff0e Header file namespace sstd { int32 getpid (); } Usage main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: getpid () ); } Execution result sstd::getpid() = 1042 Implementation Source: sstd/src/pid.cpp Header: sstd/src/pid.hpp Test: test/pid.hpp (Not implemented yet)","title":"pid"},{"location":"src/pid.html#pid","text":"","title":"pid"},{"location":"src/pid.html#abstract","text":"getpid returns the PID of its own process. getpid \u306f\u81ea\u30d7\u30ed\u30bb\u30b9\u306e PID \u3092\u8fd4\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/pid.html#header-file","text":"namespace sstd { int32 getpid (); }","title":"Header file"},{"location":"src/pid.html#usage","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: getpid () ); } Execution result sstd::getpid() = 1042","title":"Usage"},{"location":"src/pid.html#implementation","text":"Source: sstd/src/pid.cpp Header: sstd/src/pid.hpp Test: test/pid.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/print.html","text":"print / printn Abstract print() , printn() , printn_all() and printn_fflv() print values of variable. printn() , printn_all() and printn_fflv() are macro functions and able to apply variables can print by for_printn() . print() , printn() , printn_all() and printn_fflv() \u306f\u5909\u6570\u306e\u5024\u3092\u8868\u793a\u3059\u308b\uff0e printn() , printn_all() and printn_fflv() \u306f\u30de\u30af\u30ed\u95a2\u6570\u3067\uff0c for_printn() \u3067\u8868\u793a\u3067\u304d\u308b\u5909\u6570\u306b\u9069\u7528\u3067\u304d\u308b\uff0e name of macro function descriptions print() print values of variable. \u5909\u6570\u306e\u5024\u3092\u51fa\u529b\u3057\u307e\u3059\uff0e printn() print values of variable with variable name. \u5909\u6570\u306e\u5024\u3092\uff0c\u5909\u6570\u540d\u3092\u4ed8\u4e0e\u3057\u3066\u51fa\u529b\u3057\u307e\u3059\uff0e printn_all() print values of variable with variable name, function name and function line number. \u5909\u6570\u306e\u5024\u3092\uff0c\u5909\u6570\u540d\u3068\u95a2\u6570\u540d\uff0c\u95a2\u6570\u306e\u884c\u756a\u53f7\u3092\u4ed8\u4e0e\u3057\u3066\u51fa\u529b\u3057\u307e\u3059\uff0e printn_fflv() print values of variable with variable name, function name, function line number, path to the function and implimented file name. \u5909\u6570\u306e\u5024\u3092\uff0c\u5909\u6570\u540d\u3068\u95a2\u6570\u540d\uff0c\u95a2\u6570\u306e\u884c\u756a\u53f7\uff0c\u5b9f\u88c5\u306e\u30d5\u30a1\u30a4\u30eb\u306e\u30d5\u30a1\u30a4\u30eb\u540d\u3068\u30d1\u30b9\uff0c\u3092\u4ed8\u4e0e\u3057\u3066\u51fa\u529b\u3057\u307e\u3059\uff0e Header file namespace sstd { void print ( const bool rhs ); void print ( const char rhs ); void print ( const int8 rhs ); void print ( const int16 rhs ); void print ( const int32 rhs ); void print ( const int64 rhs ); void print ( const uint8 rhs ); void print ( const uint16 rhs ); void print ( const uint32 rhs ); void print ( const uint64 rhs ); void print ( const float rhs ); void print ( const double rhs ); void print ( const char * rhs ); void print ( const std :: string & rhs ); template < typename T > void print ( const std :: vector < T >& rhs ); template < typename T_lhs , typename T_rhs > void print ( const std :: unordered_map < T_lhs , T_rhs >& rhs ); void for_printn ( bool rhs ); void for_printn ( char rhs ); void for_printn ( int8 rhs ); void for_printn ( int16 rhs ); void for_printn ( int32 rhs ); void for_printn ( int64 rhs ); void for_printn ( uint8 rhs ); void for_printn ( uint16 rhs ); void for_printn ( uint32 rhs ); void for_printn ( uint64 rhs ); void for_printn ( float rhs ); void for_printn ( double rhs ); void for_printn ( const char * rhs ); void for_printn ( const std :: string & rhs ); template < typename T > void for_printn ( const std :: vector < T >& rhs ); template < typename T_lhs , typename T_rhs > void for_printn ( const std :: unordered_map < T_lhs , T_rhs >& rhs ); //--- // for #define inline void printn_dummy (){} inline void printn (...){} inline void printn_all (...){} } #define printn(var) printn_dummy();{printf(\"%s\", #var);sstd::for_printn(var);} #define printn_all(var) printn_dummy();{printf(\"%s(%d): %s\", __func__, __LINE__, #var);sstd::for_printn(var);} #define printn_fflv(var) printn_dummy();{printf(\"%s: %s(%d): %s\", __FILE__, __func__, __LINE__, #var);sstd::for_printn(var);} Usage print(), printn(), printn_all(), printn_fflv() main.cpp #include <sstd/sstd.hpp> int main (){ int i = 0 ; sstd :: print ( i ); sstd :: printn ( i ); sstd :: printn_all ( i ); sstd :: printn_fflv ( i ); } Execution result 0 i = 0 main(7): i = 0 .././tmp/.._._docs_src_docs_src_print.md_84.cpp/.._._docs_src_docs_src_print.md_84.cpp: main(8): i = 0 print bool type main.cpp #include <sstd/sstd.hpp> int main (){ bool TF_t = true ; sstd :: printn ( TF_t ); bool TF_f = false ; sstd :: printn ( TF_f ); } Execution result TF_t = true TF_f = false print std::vector<T> type main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > vS = { \"a\" , \"b\" , \"c\" }; sstd :: printn ( vS ); std :: vector < std :: vector < std :: string >> vvS = {{ \"a\" , \"b\" , \"c\" }, { \"d\" , \"e\" , \"f\" }}; sstd :: printn ( vvS ); printf ( \" \\n \" ); // any depth vector<T>. T is bool, char, (u)int8-16-32-64, float, double, char* and std::string. std :: vector < std :: vector < std :: vector < std :: vector < int >>>> v4_int = {{{{ 1 , 2 }, { 3 , 4 }}, {{ 5 , 6 }, { 7 , 8 }}}, {{{ 9 , 10 }, { 11 , 12 }}, {{ 13 , 14 }, { 15 , 16 }}}}; sstd :: printn ( v4_int ); } Execution result vS = [\"a\" \"b\" \"c\"] vvS = [[\"a\" \"b\" \"c\"] [\"d\" \"e\" \"f\"]] v4_int = [[[[1 2] [3 4]] [[5 6] [7 8]]] [[[9 10] [11 12]] [[13 14] [15 16]]]] print std::unordered_map<T_lhs, T_rhs> type main.cpp #include <sstd/sstd.hpp> int main (){ std :: unordered_map < std :: string , std :: vector < uint >> table ; table [ \"abc\" ] = { 123 , 456 }; table [ \"def\" ] = { 456 , 789 }; sstd :: printn ( table ); } Execution result table = [ [key: \"def\", value: [456 789]], [key: \"abc\", value: [123 456]] ] print sstd::mat_r<T> type main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m = {{ 1 , 2 , 3 }, { 4 , 5 , 6 }, { 7 , 8 , 9 }}; sstd :: printn ( m ); } Execution result m = 1.000000 2.000000 3.000000 4.000000 5.000000 6.000000 7.000000 8.000000 9.000000 Implementation Source: sstd/src/print.cpp Header: sstd/src/print.hpp Test: test/print_printn_printn_all.hpp","title":"print / printn"},{"location":"src/print.html#print-printn","text":"","title":"print / printn"},{"location":"src/print.html#abstract","text":"print() , printn() , printn_all() and printn_fflv() print values of variable. printn() , printn_all() and printn_fflv() are macro functions and able to apply variables can print by for_printn() . print() , printn() , printn_all() and printn_fflv() \u306f\u5909\u6570\u306e\u5024\u3092\u8868\u793a\u3059\u308b\uff0e printn() , printn_all() and printn_fflv() \u306f\u30de\u30af\u30ed\u95a2\u6570\u3067\uff0c for_printn() \u3067\u8868\u793a\u3067\u304d\u308b\u5909\u6570\u306b\u9069\u7528\u3067\u304d\u308b\uff0e name of macro function descriptions print() print values of variable. \u5909\u6570\u306e\u5024\u3092\u51fa\u529b\u3057\u307e\u3059\uff0e printn() print values of variable with variable name. \u5909\u6570\u306e\u5024\u3092\uff0c\u5909\u6570\u540d\u3092\u4ed8\u4e0e\u3057\u3066\u51fa\u529b\u3057\u307e\u3059\uff0e printn_all() print values of variable with variable name, function name and function line number. \u5909\u6570\u306e\u5024\u3092\uff0c\u5909\u6570\u540d\u3068\u95a2\u6570\u540d\uff0c\u95a2\u6570\u306e\u884c\u756a\u53f7\u3092\u4ed8\u4e0e\u3057\u3066\u51fa\u529b\u3057\u307e\u3059\uff0e printn_fflv() print values of variable with variable name, function name, function line number, path to the function and implimented file name. \u5909\u6570\u306e\u5024\u3092\uff0c\u5909\u6570\u540d\u3068\u95a2\u6570\u540d\uff0c\u95a2\u6570\u306e\u884c\u756a\u53f7\uff0c\u5b9f\u88c5\u306e\u30d5\u30a1\u30a4\u30eb\u306e\u30d5\u30a1\u30a4\u30eb\u540d\u3068\u30d1\u30b9\uff0c\u3092\u4ed8\u4e0e\u3057\u3066\u51fa\u529b\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/print.html#header-file","text":"namespace sstd { void print ( const bool rhs ); void print ( const char rhs ); void print ( const int8 rhs ); void print ( const int16 rhs ); void print ( const int32 rhs ); void print ( const int64 rhs ); void print ( const uint8 rhs ); void print ( const uint16 rhs ); void print ( const uint32 rhs ); void print ( const uint64 rhs ); void print ( const float rhs ); void print ( const double rhs ); void print ( const char * rhs ); void print ( const std :: string & rhs ); template < typename T > void print ( const std :: vector < T >& rhs ); template < typename T_lhs , typename T_rhs > void print ( const std :: unordered_map < T_lhs , T_rhs >& rhs ); void for_printn ( bool rhs ); void for_printn ( char rhs ); void for_printn ( int8 rhs ); void for_printn ( int16 rhs ); void for_printn ( int32 rhs ); void for_printn ( int64 rhs ); void for_printn ( uint8 rhs ); void for_printn ( uint16 rhs ); void for_printn ( uint32 rhs ); void for_printn ( uint64 rhs ); void for_printn ( float rhs ); void for_printn ( double rhs ); void for_printn ( const char * rhs ); void for_printn ( const std :: string & rhs ); template < typename T > void for_printn ( const std :: vector < T >& rhs ); template < typename T_lhs , typename T_rhs > void for_printn ( const std :: unordered_map < T_lhs , T_rhs >& rhs ); //--- // for #define inline void printn_dummy (){} inline void printn (...){} inline void printn_all (...){} } #define printn(var) printn_dummy();{printf(\"%s\", #var);sstd::for_printn(var);} #define printn_all(var) printn_dummy();{printf(\"%s(%d): %s\", __func__, __LINE__, #var);sstd::for_printn(var);} #define printn_fflv(var) printn_dummy();{printf(\"%s: %s(%d): %s\", __FILE__, __func__, __LINE__, #var);sstd::for_printn(var);}","title":"Header file"},{"location":"src/print.html#usage","text":"","title":"Usage"},{"location":"src/print.html#print-printn-printn_all-printn_fflv","text":"main.cpp #include <sstd/sstd.hpp> int main (){ int i = 0 ; sstd :: print ( i ); sstd :: printn ( i ); sstd :: printn_all ( i ); sstd :: printn_fflv ( i ); } Execution result 0 i = 0 main(7): i = 0 .././tmp/.._._docs_src_docs_src_print.md_84.cpp/.._._docs_src_docs_src_print.md_84.cpp: main(8): i = 0","title":"print(), printn(), printn_all(), printn_fflv()"},{"location":"src/print.html#print-bool-type","text":"main.cpp #include <sstd/sstd.hpp> int main (){ bool TF_t = true ; sstd :: printn ( TF_t ); bool TF_f = false ; sstd :: printn ( TF_f ); } Execution result TF_t = true TF_f = false","title":"print bool type"},{"location":"src/print.html#print-stdvectort-type","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > vS = { \"a\" , \"b\" , \"c\" }; sstd :: printn ( vS ); std :: vector < std :: vector < std :: string >> vvS = {{ \"a\" , \"b\" , \"c\" }, { \"d\" , \"e\" , \"f\" }}; sstd :: printn ( vvS ); printf ( \" \\n \" ); // any depth vector<T>. T is bool, char, (u)int8-16-32-64, float, double, char* and std::string. std :: vector < std :: vector < std :: vector < std :: vector < int >>>> v4_int = {{{{ 1 , 2 }, { 3 , 4 }}, {{ 5 , 6 }, { 7 , 8 }}}, {{{ 9 , 10 }, { 11 , 12 }}, {{ 13 , 14 }, { 15 , 16 }}}}; sstd :: printn ( v4_int ); } Execution result vS = [\"a\" \"b\" \"c\"] vvS = [[\"a\" \"b\" \"c\"] [\"d\" \"e\" \"f\"]] v4_int = [[[[1 2] [3 4]] [[5 6] [7 8]]] [[[9 10] [11 12]] [[13 14] [15 16]]]]","title":"print std::vector&lt;T&gt; type"},{"location":"src/print.html#print-stdunordered_mapt_lhs-t_rhs-type","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: unordered_map < std :: string , std :: vector < uint >> table ; table [ \"abc\" ] = { 123 , 456 }; table [ \"def\" ] = { 456 , 789 }; sstd :: printn ( table ); } Execution result table = [ [key: \"def\", value: [456 789]], [key: \"abc\", value: [123 456]] ]","title":"print std::unordered_map&lt;T_lhs, T_rhs&gt; type"},{"location":"src/print.html#print-sstdmat_rt-type","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m = {{ 1 , 2 , 3 }, { 4 , 5 , 6 }, { 7 , 8 , 9 }}; sstd :: printn ( m ); } Execution result m = 1.000000 2.000000 3.000000 4.000000 5.000000 6.000000 7.000000 8.000000 9.000000","title":"print sstd::mat_r&lt;T&gt; type"},{"location":"src/print.html#implementation","text":"Source: sstd/src/print.cpp Header: sstd/src/print.hpp Test: test/print_printn_printn_all.hpp","title":"Implementation"},{"location":"src/typeDef.h.html","text":"typeDef.h Abstract Type definitions on SSTD. These definitions are read by #include <sstd/sstd.hpp> . SSTD \u306b\u304a\u3051\u308b\u578b\u306e\u5b9a\u7fa9\uff0e #include <sstd/sstd.hpp> \u306b\u3088\u308a\u5b9a\u7fa9\u304c\u8aad\u307f\u8fbc\u307e\u308c\u308b\uff0e Header file #pragma once #ifdef _WIN32 typedef unsigned char uchar ; typedef __int8 int8 ; typedef __int16 int16 ; typedef __int32 int32 ; typedef __int64 int64 ; typedef unsigned __int8 uint8 ; typedef unsigned __int16 uint16 ; typedef unsigned __int32 uint32 ; typedef unsigned __int64 uint64 ; #else #include <stdint.h> // intXX_t, uintXX_t \u304c\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b typedef unsigned char uchar ; typedef int8_t int8 ; typedef int16_t int16 ; typedef int32_t int32 ; typedef int64_t int64 ; typedef uint8_t uint8 ; typedef uint16_t uint16 ; typedef uint32_t uint32 ; typedef uint64_t uint64 ; #endif #ifndef uint typedef unsigned int uint ; #endif Implementation Header: sstd/src/typeDef.hpp","title":"typeDef.h"},{"location":"src/typeDef.h.html#typedefh","text":"","title":"typeDef.h"},{"location":"src/typeDef.h.html#abstract","text":"Type definitions on SSTD. These definitions are read by #include <sstd/sstd.hpp> . SSTD \u306b\u304a\u3051\u308b\u578b\u306e\u5b9a\u7fa9\uff0e #include <sstd/sstd.hpp> \u306b\u3088\u308a\u5b9a\u7fa9\u304c\u8aad\u307f\u8fbc\u307e\u308c\u308b\uff0e","title":"Abstract"},{"location":"src/typeDef.h.html#header-file","text":"#pragma once #ifdef _WIN32 typedef unsigned char uchar ; typedef __int8 int8 ; typedef __int16 int16 ; typedef __int32 int32 ; typedef __int64 int64 ; typedef unsigned __int8 uint8 ; typedef unsigned __int16 uint16 ; typedef unsigned __int32 uint32 ; typedef unsigned __int64 uint64 ; #else #include <stdint.h> // intXX_t, uintXX_t \u304c\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b typedef unsigned char uchar ; typedef int8_t int8 ; typedef int16_t int16 ; typedef int32_t int32 ; typedef int64_t int64 ; typedef uint8_t uint8 ; typedef uint16_t uint16 ; typedef uint32_t uint32 ; typedef uint64_t uint64 ; #endif #ifndef uint typedef unsigned int uint ; #endif","title":"Header file"},{"location":"src/typeDef.h.html#implementation","text":"Header: sstd/src/typeDef.hpp","title":"Implementation"},{"location":"src/file/csv.html","text":"csv Abstract csv2vvec() Parseing CSV file to std::vector<std::vector<std::string>> . CSV \u30d5\u30a1\u30a4\u30eb\u3092\u30d1\u30fc\u30b9\u3057\u3066 std::vector<std::vector<std::string>> \u306b\u5909\u63db\u3057\u307e\u3059. vvec2csv() Converting std::vector<std::vector<std::string>> to CSV file. std::vector<std::vector<std::string>> \u3092 CSV \u30d5\u30a1\u30a4\u30eb\u306b\u5909\u63db\u3057\u307e\u3059. Header file namespace sstd { std :: vector < std :: vector < std :: string >> csv2vvec ( const char * pReadFile ); std :: vector < std :: vector < std :: string >> csv2vvec ( const std :: string & readFile ); bool vvec2csv ( const char * pSavePath , const std :: vector < std :: vector < std :: string >>& vecCSV ); bool vvec2csv ( const std :: string & savePath , const std :: vector < std :: vector < std :: string >>& vecCSV ); } Usage csv2vvec() example.csv a, bcd \"hello, world\", \"efg\" main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < std :: string >> vv = sstd :: csv2vvec ( \"example.csv\" ); sstd :: printn ( vv ); } Execution result vv = [[\"a\" \"bcd\"] [\"hello, world\" \"efg\"]] vvec2csv() main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); std :: vector < std :: vector < std :: string >> vv = {{ \"a\" , \"bcd\" }, { \"hello, world\" , \"efg\" }}; sstd :: vvec2csv ( \"./tmp/example.csv\" , vv ); printf ( \"$ cat ./tmp/example.csv \\n \" ); fflush ( stdout ); sstd :: system ( \"cat ./tmp/example.csv\" ); sstd :: rm ( \"./tmp\" ); } Execution result $ cat ./tmp/example.csv \"a\",\"bcd\", \"hello, world\",\"efg\", Appendix CSV with header (string) Below C++ code gets string CSV data removing header descriptions. \u4e0b\u8a18\u306e C++ \u30b3\u30fc\u30c9\u306f\uff0c\u8aac\u660e\u30d8\u30c3\u30c0\u3092\u53d6\u308a\u9664\u3044\u305f\u6587\u5b57\u5217\u306e CSV \u30c7\u30fc\u30bf\u3092\u53d6\u5f97\u3057\u307e\u3059\uff0e CSV example Range of Integers Type name Bytes Range of values int8_t 1 -128 ~ 127 int16_t 2 -32,768 ~ 32,767 int32_t 4 -2,147,483,648 ~ 2,147,483,647 int64_t 8 -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); { // write to CSV sstd :: vvec < std :: string > header = { // sstd::vvec<T> is same as a std::vector<std::vector<T>>. { \"Type name\" , \"Bytes\" , \"Range of values\" } }; sstd :: vvec < std :: string > vvTable = { { \"int8_t\" , \"1\" , \"-128 ~ 127\" }, { \"int16_t\" , \"2\" , \"-32,768 ~ 32,767\" }, { \"int32_t\" , \"4\" , \"-2,147,483,648 ~ 2,147,483,647\" }, { \"int64_t\" , \"8\" , \"-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807\" } }; sstd :: vvec < std :: string > vv = header << vvTable ; sstd :: vvec2csv ( \"./tmp/example.csv\" , vv ); } { // Read from CSV sstd :: vvec < std :: string > vvecOrig = sstd :: csv2vvec ( \"./tmp/example.csv\" ); sstd :: vvec < std :: string > header = vvecOrig && sstd :: slice_mv ( sstd :: begin (), 1 ); sstd :: vvec < std :: string > vvS = vvecOrig && sstd :: slice_mv ( 1 , sstd :: end ()); sstd :: printn ( vvS ); } sstd :: rm ( \"./tmp\" ); } Execution result vvS = [[\"int8_t\" \"1\" \"-128 ~ 127\"] [\"int16_t\" \"2\" \"-32,768 ~ 32,767\"] [\"int32_t\" \"4\" \"-2,147,483,648 ~ 2,147,483,647\"] [\"int64_t\" \"8\" \"-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807\"]] CSV with header (double) Below C++ code gets floating points CSV data removing header descriptions. \u4e0b\u8a18\u306e C++ \u30b3\u30fc\u30c9\u306f\uff0c\u8aac\u660e\u30d8\u30c3\u30c0\u3092\u53d6\u308a\u9664\u3044\u305f\u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u306e CSV \u30c7\u30fc\u30bf\u3092\u53d6\u5f97\u3057\u307e\u3059\uff0e CSV example sin(\u03a0x) and cos(\u03a0x) x sin(\u03c0x) cos(\u03c0x) 0.00 0.00 1.00 0.10 0.31 0.95 0.20 0.59 0.81 0.30 0.81 0.59 0.40 0.95 0.31 0.50 1.00 0.00 0.60 0.95 -0.31 0.70 0.81 -0.59 0.80 0.59 -0.81 0.90 0.31 -0.95 1.00 0.00 -1.00 1.10 -0.31 -0.95 1.20 -0.59 -0.81 1.30 -0.81 -0.59 1.40 -0.95 -0.31 1.50 -1.00 0.00 1.60 -0.95 0.31 1.70 -0.81 0.59 1.80 -0.59 0.81 1.90 -0.31 0.95 2.00 0.00 1.00 main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); { // write to CSV sstd :: vvec < std :: string > header = { // sstd::vvec<T> is same as a std::vector<std::vector<T>>. { \"x\" , \"sin(\u03c0x)\" , \"cos(\u03c0x)\" } }; std :: vector < double > vX = { 0.00 , 0.10 , 0.20 , 0.30 , 0.40 , 0.50 , 0.60 , 0.70 , 0.80 , 0.90 , 1.00 , 1.10 , 1.20 , 1.30 , 1.40 , 1.50 , 1.60 , 1.70 , 1.80 , 1.90 , 2.00 }; std :: vector < double > vSin = { 0.00 , 0.31 , 0.59 , 0.81 , 0.95 , 1.00 , 0.95 , 0.81 , 0.59 , 0.31 , 0.00 , -0.31 , -0.59 , -0.81 , -0.95 , -1.00 , -0.95 , -0.81 , -0.59 , -0.31 , 0.00 }; std :: vector < double > vCos = { 1.00 , 0.95 , 0.81 , 0.59 , 0.31 , 0.00 , -0.31 , -0.59 , -0.81 , -0.95 , -1.00 , -0.95 , -0.81 , -0.59 , -0.31 , 0.00 , 0.31 , 0.59 , 0.81 , 0.95 , 1.00 }; sstd :: vvec < double > vvD = {{ vX }, { vSin }, { vCos }}; sstd :: vvec < double > vvTable = sstd :: Tr ( vvD ); /* // up is same as a below. sstd::vvec<double> vvTable = { {0.00, 0.00, 1.00}, {0.10, 0.31, 0.95}, {0.20, 0.59, 0.81}, {0.30, 0.81, 0.59}, {0.40, 0.95, 0.31}, {0.50, 1.00, 0.00}, {0.60, 0.95, -0.31}, {0.70, 0.81, -0.59}, {0.80, 0.59, -0.81}, {0.90, 0.31, -0.95}, {1.00, 0.00, -1.00}, {1.10, -0.31, -0.95}, {1.20, -0.59, -0.81}, {1.30, -0.81, -0.59}, {1.40, -0.95, -0.31}, {1.50, -1.00, 0.00}, {1.60, -0.95, 0.31}, {1.70, -0.81, 0.59}, {1.80, -0.59, 0.81}, {1.90, -0.31, 0.95}, {2.00, 0.00, 1.00} };*/ sstd :: vvec < std :: string > vv = header << sstd :: double2str ( vvTable ); sstd :: vvec2csv ( \"./tmp/example.csv\" , vv ); } { // Read from CSV sstd :: vvec < std :: string > vvecOrig = sstd :: csv2vvec ( \"./tmp/example.csv\" ); sstd :: vvec < std :: string > header = vvecOrig && sstd :: slice_mv ( sstd :: begin (), 1 ); sstd :: vvec < std :: string > vvS = vvecOrig && sstd :: slice_mv ( 1 , sstd :: end ()); sstd :: vvec < double > vvD = sstd :: Tr ( sstd :: str2double ( vvS )); sstd :: printn ( header ); sstd :: printn ( vvD [ 0 ]); sstd :: printn ( vvD [ 1 ]); sstd :: printn ( vvD [ 2 ]); } sstd :: rm ( \"./tmp\" ); } Execution result header = [[\"x\" \"sin(\u03c0x)\" \"cos(\u03c0x)\"]] vvD[0] = [0. 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1. 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.] vvD[1] = [0. 0.31 0.59 0.81 0.95 1. 0.95 0.81 0.59 0.31 0. -0.31 -0.59 -0.81 -0.95 -1. -0.95 -0.81 -0.59 -0.31 0.] vvD[2] = [1. 0.95 0.81 0.59 0.31 0. -0.31 -0.59 -0.81 -0.95 -1. -0.95 -0.81 -0.59 -0.31 0. 0.31 0.59 0.81 0.95 1.] Implementation Source: sstd/src/file/csv.cpp Header: sstd/src/file/csv.hpp Test: test/file/csv.hpp (Not implemented yet)","title":"csv"},{"location":"src/file/csv.html#csv","text":"","title":"csv"},{"location":"src/file/csv.html#abstract","text":"csv2vvec() Parseing CSV file to std::vector<std::vector<std::string>> . CSV \u30d5\u30a1\u30a4\u30eb\u3092\u30d1\u30fc\u30b9\u3057\u3066 std::vector<std::vector<std::string>> \u306b\u5909\u63db\u3057\u307e\u3059. vvec2csv() Converting std::vector<std::vector<std::string>> to CSV file. std::vector<std::vector<std::string>> \u3092 CSV \u30d5\u30a1\u30a4\u30eb\u306b\u5909\u63db\u3057\u307e\u3059.","title":"Abstract"},{"location":"src/file/csv.html#header-file","text":"namespace sstd { std :: vector < std :: vector < std :: string >> csv2vvec ( const char * pReadFile ); std :: vector < std :: vector < std :: string >> csv2vvec ( const std :: string & readFile ); bool vvec2csv ( const char * pSavePath , const std :: vector < std :: vector < std :: string >>& vecCSV ); bool vvec2csv ( const std :: string & savePath , const std :: vector < std :: vector < std :: string >>& vecCSV ); }","title":"Header file"},{"location":"src/file/csv.html#usage","text":"","title":"Usage"},{"location":"src/file/csv.html#csv2vvec","text":"example.csv a, bcd \"hello, world\", \"efg\" main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < std :: string >> vv = sstd :: csv2vvec ( \"example.csv\" ); sstd :: printn ( vv ); } Execution result vv = [[\"a\" \"bcd\"] [\"hello, world\" \"efg\"]]","title":"csv2vvec()"},{"location":"src/file/csv.html#vvec2csv","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); std :: vector < std :: vector < std :: string >> vv = {{ \"a\" , \"bcd\" }, { \"hello, world\" , \"efg\" }}; sstd :: vvec2csv ( \"./tmp/example.csv\" , vv ); printf ( \"$ cat ./tmp/example.csv \\n \" ); fflush ( stdout ); sstd :: system ( \"cat ./tmp/example.csv\" ); sstd :: rm ( \"./tmp\" ); } Execution result $ cat ./tmp/example.csv \"a\",\"bcd\", \"hello, world\",\"efg\",","title":"vvec2csv()"},{"location":"src/file/csv.html#appendix","text":"","title":"Appendix"},{"location":"src/file/csv.html#csv-with-header-string","text":"Below C++ code gets string CSV data removing header descriptions. \u4e0b\u8a18\u306e C++ \u30b3\u30fc\u30c9\u306f\uff0c\u8aac\u660e\u30d8\u30c3\u30c0\u3092\u53d6\u308a\u9664\u3044\u305f\u6587\u5b57\u5217\u306e CSV \u30c7\u30fc\u30bf\u3092\u53d6\u5f97\u3057\u307e\u3059\uff0e","title":"CSV with header (string)"},{"location":"src/file/csv.html#csv-example","text":"Range of Integers Type name Bytes Range of values int8_t 1 -128 ~ 127 int16_t 2 -32,768 ~ 32,767 int32_t 4 -2,147,483,648 ~ 2,147,483,647 int64_t 8 -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); { // write to CSV sstd :: vvec < std :: string > header = { // sstd::vvec<T> is same as a std::vector<std::vector<T>>. { \"Type name\" , \"Bytes\" , \"Range of values\" } }; sstd :: vvec < std :: string > vvTable = { { \"int8_t\" , \"1\" , \"-128 ~ 127\" }, { \"int16_t\" , \"2\" , \"-32,768 ~ 32,767\" }, { \"int32_t\" , \"4\" , \"-2,147,483,648 ~ 2,147,483,647\" }, { \"int64_t\" , \"8\" , \"-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807\" } }; sstd :: vvec < std :: string > vv = header << vvTable ; sstd :: vvec2csv ( \"./tmp/example.csv\" , vv ); } { // Read from CSV sstd :: vvec < std :: string > vvecOrig = sstd :: csv2vvec ( \"./tmp/example.csv\" ); sstd :: vvec < std :: string > header = vvecOrig && sstd :: slice_mv ( sstd :: begin (), 1 ); sstd :: vvec < std :: string > vvS = vvecOrig && sstd :: slice_mv ( 1 , sstd :: end ()); sstd :: printn ( vvS ); } sstd :: rm ( \"./tmp\" ); } Execution result vvS = [[\"int8_t\" \"1\" \"-128 ~ 127\"] [\"int16_t\" \"2\" \"-32,768 ~ 32,767\"] [\"int32_t\" \"4\" \"-2,147,483,648 ~ 2,147,483,647\"] [\"int64_t\" \"8\" \"-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807\"]]","title":"CSV example"},{"location":"src/file/csv.html#csv-with-header-double","text":"Below C++ code gets floating points CSV data removing header descriptions. \u4e0b\u8a18\u306e C++ \u30b3\u30fc\u30c9\u306f\uff0c\u8aac\u660e\u30d8\u30c3\u30c0\u3092\u53d6\u308a\u9664\u3044\u305f\u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u306e CSV \u30c7\u30fc\u30bf\u3092\u53d6\u5f97\u3057\u307e\u3059\uff0e","title":"CSV with header (double)"},{"location":"src/file/csv.html#csv-example_1","text":"sin(\u03a0x) and cos(\u03a0x) x sin(\u03c0x) cos(\u03c0x) 0.00 0.00 1.00 0.10 0.31 0.95 0.20 0.59 0.81 0.30 0.81 0.59 0.40 0.95 0.31 0.50 1.00 0.00 0.60 0.95 -0.31 0.70 0.81 -0.59 0.80 0.59 -0.81 0.90 0.31 -0.95 1.00 0.00 -1.00 1.10 -0.31 -0.95 1.20 -0.59 -0.81 1.30 -0.81 -0.59 1.40 -0.95 -0.31 1.50 -1.00 0.00 1.60 -0.95 0.31 1.70 -0.81 0.59 1.80 -0.59 0.81 1.90 -0.31 0.95 2.00 0.00 1.00 main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); { // write to CSV sstd :: vvec < std :: string > header = { // sstd::vvec<T> is same as a std::vector<std::vector<T>>. { \"x\" , \"sin(\u03c0x)\" , \"cos(\u03c0x)\" } }; std :: vector < double > vX = { 0.00 , 0.10 , 0.20 , 0.30 , 0.40 , 0.50 , 0.60 , 0.70 , 0.80 , 0.90 , 1.00 , 1.10 , 1.20 , 1.30 , 1.40 , 1.50 , 1.60 , 1.70 , 1.80 , 1.90 , 2.00 }; std :: vector < double > vSin = { 0.00 , 0.31 , 0.59 , 0.81 , 0.95 , 1.00 , 0.95 , 0.81 , 0.59 , 0.31 , 0.00 , -0.31 , -0.59 , -0.81 , -0.95 , -1.00 , -0.95 , -0.81 , -0.59 , -0.31 , 0.00 }; std :: vector < double > vCos = { 1.00 , 0.95 , 0.81 , 0.59 , 0.31 , 0.00 , -0.31 , -0.59 , -0.81 , -0.95 , -1.00 , -0.95 , -0.81 , -0.59 , -0.31 , 0.00 , 0.31 , 0.59 , 0.81 , 0.95 , 1.00 }; sstd :: vvec < double > vvD = {{ vX }, { vSin }, { vCos }}; sstd :: vvec < double > vvTable = sstd :: Tr ( vvD ); /* // up is same as a below. sstd::vvec<double> vvTable = { {0.00, 0.00, 1.00}, {0.10, 0.31, 0.95}, {0.20, 0.59, 0.81}, {0.30, 0.81, 0.59}, {0.40, 0.95, 0.31}, {0.50, 1.00, 0.00}, {0.60, 0.95, -0.31}, {0.70, 0.81, -0.59}, {0.80, 0.59, -0.81}, {0.90, 0.31, -0.95}, {1.00, 0.00, -1.00}, {1.10, -0.31, -0.95}, {1.20, -0.59, -0.81}, {1.30, -0.81, -0.59}, {1.40, -0.95, -0.31}, {1.50, -1.00, 0.00}, {1.60, -0.95, 0.31}, {1.70, -0.81, 0.59}, {1.80, -0.59, 0.81}, {1.90, -0.31, 0.95}, {2.00, 0.00, 1.00} };*/ sstd :: vvec < std :: string > vv = header << sstd :: double2str ( vvTable ); sstd :: vvec2csv ( \"./tmp/example.csv\" , vv ); } { // Read from CSV sstd :: vvec < std :: string > vvecOrig = sstd :: csv2vvec ( \"./tmp/example.csv\" ); sstd :: vvec < std :: string > header = vvecOrig && sstd :: slice_mv ( sstd :: begin (), 1 ); sstd :: vvec < std :: string > vvS = vvecOrig && sstd :: slice_mv ( 1 , sstd :: end ()); sstd :: vvec < double > vvD = sstd :: Tr ( sstd :: str2double ( vvS )); sstd :: printn ( header ); sstd :: printn ( vvD [ 0 ]); sstd :: printn ( vvD [ 1 ]); sstd :: printn ( vvD [ 2 ]); } sstd :: rm ( \"./tmp\" ); } Execution result header = [[\"x\" \"sin(\u03c0x)\" \"cos(\u03c0x)\"]] vvD[0] = [0. 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1. 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.] vvD[1] = [0. 0.31 0.59 0.81 0.95 1. 0.95 0.81 0.59 0.31 0. -0.31 -0.59 -0.81 -0.95 -1. -0.95 -0.81 -0.59 -0.31 0.] vvD[2] = [1. 0.95 0.81 0.59 0.31 0. -0.31 -0.59 -0.81 -0.95 -1. -0.95 -0.81 -0.59 -0.31 0. 0.31 0.59 0.81 0.95 1.]","title":"CSV example"},{"location":"src/file/csv.html#implementation","text":"Source: sstd/src/file/csv.cpp Header: sstd/src/file/csv.hpp Test: test/file/csv.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/file/file.html","text":"file Abstract The file class is used to manage file pointers. file \u30af\u30e9\u30b9\u306f\uff0cfile \u30dd\u30a4\u30f3\u30bf\u306e\u7ba1\u7406\u306b\u5229\u7528\u3057\u307e\u3059\uff0e Header file namespace sstd { class file ; } class sstd :: file { private : FILE * fp ; int type ; // 0: fopen(), 1: popen(). public : file (); ~ file (); bool fopen ( const char * fileName , const char * mode ); bool fopen ( const std :: string & fileName , const char * mode ); bool popen ( const char * fileName , const char * mode ); bool popen ( const std :: string & fileName , const char * mode ); bool close (); char * fgets ( char * s , int size ); size_t fread ( void * ptr , const size_t & size , const size_t & nmemb ); template < typename ... Args > int fscanf ( const char * format , Args const & ... args ){ return :: fscanf ( this -> fp , format , args ...); } int fseek ( const long & offset , const int & whence ); size_t fsize (); long ftell (); size_t fwrite ( const void * ptr , const size_t & size , const size_t & nmemb ); }; Usage example.txt abc def main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: file fp ; if ( ! fp . fopen ( \"example.txt\" , \"rb\" )){ sstd :: pdbg ( \"ERROR: fopen was failed. \\n \" ); return -1 ; } size_t size = fp . fsize (); std :: vector < char > raw ( size + 1 , 0 ); if ( fp . fread (( uchar * ) & raw [ 0 ], sizeof ( char ), size ) != size ){ sstd :: pdbg ( \"ERROR: fread was failed. \\n \" ); return -1 ; } printf ( \"&raw[0] = %s \\n \" , & raw [ 0 ]); return 0 ; // fp is automatically closed by RAII. } Execution result &raw[0] = abc def Implementation Source: sstd/src/file/file.cpp Header: sstd/src/file/file.hpp Test: test/file/file.hpp","title":"file"},{"location":"src/file/file.html#file","text":"","title":"file"},{"location":"src/file/file.html#abstract","text":"The file class is used to manage file pointers. file \u30af\u30e9\u30b9\u306f\uff0cfile \u30dd\u30a4\u30f3\u30bf\u306e\u7ba1\u7406\u306b\u5229\u7528\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/file/file.html#header-file","text":"namespace sstd { class file ; } class sstd :: file { private : FILE * fp ; int type ; // 0: fopen(), 1: popen(). public : file (); ~ file (); bool fopen ( const char * fileName , const char * mode ); bool fopen ( const std :: string & fileName , const char * mode ); bool popen ( const char * fileName , const char * mode ); bool popen ( const std :: string & fileName , const char * mode ); bool close (); char * fgets ( char * s , int size ); size_t fread ( void * ptr , const size_t & size , const size_t & nmemb ); template < typename ... Args > int fscanf ( const char * format , Args const & ... args ){ return :: fscanf ( this -> fp , format , args ...); } int fseek ( const long & offset , const int & whence ); size_t fsize (); long ftell (); size_t fwrite ( const void * ptr , const size_t & size , const size_t & nmemb ); };","title":"Header file"},{"location":"src/file/file.html#usage","text":"example.txt abc def main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: file fp ; if ( ! fp . fopen ( \"example.txt\" , \"rb\" )){ sstd :: pdbg ( \"ERROR: fopen was failed. \\n \" ); return -1 ; } size_t size = fp . fsize (); std :: vector < char > raw ( size + 1 , 0 ); if ( fp . fread (( uchar * ) & raw [ 0 ], sizeof ( char ), size ) != size ){ sstd :: pdbg ( \"ERROR: fread was failed. \\n \" ); return -1 ; } printf ( \"&raw[0] = %s \\n \" , & raw [ 0 ]); return 0 ; // fp is automatically closed by RAII. } Execution result &raw[0] = abc def","title":"Usage"},{"location":"src/file/file.html#implementation","text":"Source: sstd/src/file/file.cpp Header: sstd/src/file/file.hpp Test: test/file/file.hpp","title":"Implementation"},{"location":"src/file/glob.html","text":"glob Abstract glob can search file and directory with * and ? . (The other regular expressions are not implimented). And glob_pt is a type of glob with a variable indicating the file type in the returning value. glob \u306f\uff0c\u6b63\u898f\u8868\u73fe * \u3084 ? \u306b\u3088\u308a\uff0c\u30d5\u30a1\u30a4\u30eb\u3084\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u63a2\u7d22\u3057\u307e\u3059\uff0e\uff08\u203b\u305d\u306e\u4ed6\u306e\u6b63\u898f\u8868\u73fe\u306b\u3064\u3044\u3066\u306f\uff0c\u73fe\u72b6\u672a\u5b9f\u88c5\u3067\u3059\uff09\uff0e \u307e\u305f\uff0c glob_pt \u306f\uff0c glob \u306e\u623b\u308a\u5024\u306b\u30d5\u30a1\u30a4\u30eb\u30bf\u30a4\u30d7\u3092\u793a\u3059\u5909\u6570\u304c\u8ffd\u52a0\u3055\u308c\u305f\u30d0\u30fc\u30b8\u30e7\u30f3\u3067\u3059\uff0e Options can take d , f and r . There options can be specified independently in no particular order. \u30aa\u30d7\u30b7\u30e7\u30f3\u306b\u306f d , f , r \u304c\u3042\u308a\uff0c\u305d\u308c\u305e\u308c\u72ec\u7acb\u306b\uff0c\u9806\u4e0d\u540c\u3067\u6307\u5b9a\u3067\u304d\u307e\u3059\uff0e Options d : getting directory name option f : getting file name option r : recursive directory option Header file namespace sstd { struct pathAndType { std :: string path ; char type ; // 'f': file, 'd': directory bool operator < ( const struct pathAndType & rhs ){ return ( * this ). path < rhs . path ; } }; std :: vector < std :: string > glob ( const char * path , const char * opt ); std :: vector < std :: string > glob ( const std :: string & path , const char * opt ); std :: vector < std :: string > glob ( const char * path ); std :: vector < std :: string > glob ( const std :: string & path ); std :: vector < struct pathAndType > glob_pt ( const char * path , const char * opt ); // _pt: with path type std :: vector < struct pathAndType > glob_pt ( const std :: string & path , const char * opt ); std :: vector < struct pathAndType > glob_pt ( const char * path ); std :: vector < struct pathAndType > glob_pt ( const std :: string & path ); } Usage01: getting only file without recursive option main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"touch ./tmp/a.txt\" ); sstd :: system ( \"touch ./tmp/b.csv\" ); sstd :: system ( \"touch ./tmp/c.txt\" ); std :: vector < std :: string > vStr = sstd :: glob ( \"./tmp/*.txt\" ); sstd :: printn ( vStr ); std :: vector < struct sstd :: pathAndType > vPt = sstd :: glob_pt ( \"./tmp/*.txt\" ); sstd :: printn ( vPt ); sstd :: rm ( \"./tmp\" ); } example.txt vStr = [\"./tmp/a.txt\" \"./tmp/c.txt\"] vPt = [\"path: ./tmp/a.txt, type: file\" \"path: ./tmp/c.txt, type: file\"] Usage02: getting file and directory with recursive option main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: mkdir ( \"./tmp/a\" ); sstd :: mkdir ( \"./tmp/b\" ); sstd :: mkdir ( \"./tmp/c\" ); sstd :: system ( \"touch ./tmp/a.txt\" ); sstd :: system ( \"touch ./tmp/b.csv\" ); sstd :: system ( \"touch ./tmp/c.txt\" ); std :: vector < std :: string > vStr = sstd :: glob ( \"./tmp/*\" , \"dfr\" ); sstd :: printn ( vStr ); std :: vector < struct sstd :: pathAndType > vPt = sstd :: glob_pt ( \"./tmp/*\" , \"dfr\" ); sstd :: printn ( vPt ); sstd :: rm ( \"./tmp\" ); } example.txt vStr = [\"./tmp/a\" \"./tmp/a.txt\" \"./tmp/b\" \"./tmp/b.csv\" \"./tmp/c\" \"./tmp/c.txt\"] vPt = [\"path: ./tmp/a, type: directory\" \"path: ./tmp/a.txt, type: file\" \"path: ./tmp/b, type: directory\" \"path: ./tmp/b.csv, type: file\" \"path: ./tmp/c, type: directory\" \"path: ./tmp/c.txt, type: file\"] Implementation Source: sstd/src/file/glob.cpp Header: sstd/src/file/glob.hpp Test: test/file/glob.hpp","title":"glob"},{"location":"src/file/glob.html#glob","text":"","title":"glob"},{"location":"src/file/glob.html#abstract","text":"glob can search file and directory with * and ? . (The other regular expressions are not implimented). And glob_pt is a type of glob with a variable indicating the file type in the returning value. glob \u306f\uff0c\u6b63\u898f\u8868\u73fe * \u3084 ? \u306b\u3088\u308a\uff0c\u30d5\u30a1\u30a4\u30eb\u3084\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u63a2\u7d22\u3057\u307e\u3059\uff0e\uff08\u203b\u305d\u306e\u4ed6\u306e\u6b63\u898f\u8868\u73fe\u306b\u3064\u3044\u3066\u306f\uff0c\u73fe\u72b6\u672a\u5b9f\u88c5\u3067\u3059\uff09\uff0e \u307e\u305f\uff0c glob_pt \u306f\uff0c glob \u306e\u623b\u308a\u5024\u306b\u30d5\u30a1\u30a4\u30eb\u30bf\u30a4\u30d7\u3092\u793a\u3059\u5909\u6570\u304c\u8ffd\u52a0\u3055\u308c\u305f\u30d0\u30fc\u30b8\u30e7\u30f3\u3067\u3059\uff0e Options can take d , f and r . There options can be specified independently in no particular order. \u30aa\u30d7\u30b7\u30e7\u30f3\u306b\u306f d , f , r \u304c\u3042\u308a\uff0c\u305d\u308c\u305e\u308c\u72ec\u7acb\u306b\uff0c\u9806\u4e0d\u540c\u3067\u6307\u5b9a\u3067\u304d\u307e\u3059\uff0e Options d : getting directory name option f : getting file name option r : recursive directory option","title":"Abstract"},{"location":"src/file/glob.html#header-file","text":"namespace sstd { struct pathAndType { std :: string path ; char type ; // 'f': file, 'd': directory bool operator < ( const struct pathAndType & rhs ){ return ( * this ). path < rhs . path ; } }; std :: vector < std :: string > glob ( const char * path , const char * opt ); std :: vector < std :: string > glob ( const std :: string & path , const char * opt ); std :: vector < std :: string > glob ( const char * path ); std :: vector < std :: string > glob ( const std :: string & path ); std :: vector < struct pathAndType > glob_pt ( const char * path , const char * opt ); // _pt: with path type std :: vector < struct pathAndType > glob_pt ( const std :: string & path , const char * opt ); std :: vector < struct pathAndType > glob_pt ( const char * path ); std :: vector < struct pathAndType > glob_pt ( const std :: string & path ); }","title":"Header file"},{"location":"src/file/glob.html#usage01-getting-only-file-without-recursive-option","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"touch ./tmp/a.txt\" ); sstd :: system ( \"touch ./tmp/b.csv\" ); sstd :: system ( \"touch ./tmp/c.txt\" ); std :: vector < std :: string > vStr = sstd :: glob ( \"./tmp/*.txt\" ); sstd :: printn ( vStr ); std :: vector < struct sstd :: pathAndType > vPt = sstd :: glob_pt ( \"./tmp/*.txt\" ); sstd :: printn ( vPt ); sstd :: rm ( \"./tmp\" ); } example.txt vStr = [\"./tmp/a.txt\" \"./tmp/c.txt\"] vPt = [\"path: ./tmp/a.txt, type: file\" \"path: ./tmp/c.txt, type: file\"]","title":"Usage01: getting only file without recursive option"},{"location":"src/file/glob.html#usage02-getting-file-and-directory-with-recursive-option","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: mkdir ( \"./tmp/a\" ); sstd :: mkdir ( \"./tmp/b\" ); sstd :: mkdir ( \"./tmp/c\" ); sstd :: system ( \"touch ./tmp/a.txt\" ); sstd :: system ( \"touch ./tmp/b.csv\" ); sstd :: system ( \"touch ./tmp/c.txt\" ); std :: vector < std :: string > vStr = sstd :: glob ( \"./tmp/*\" , \"dfr\" ); sstd :: printn ( vStr ); std :: vector < struct sstd :: pathAndType > vPt = sstd :: glob_pt ( \"./tmp/*\" , \"dfr\" ); sstd :: printn ( vPt ); sstd :: rm ( \"./tmp\" ); } example.txt vStr = [\"./tmp/a\" \"./tmp/a.txt\" \"./tmp/b\" \"./tmp/b.csv\" \"./tmp/c\" \"./tmp/c.txt\"] vPt = [\"path: ./tmp/a, type: directory\" \"path: ./tmp/a.txt, type: file\" \"path: ./tmp/b, type: directory\" \"path: ./tmp/b.csv, type: file\" \"path: ./tmp/c, type: directory\" \"path: ./tmp/c.txt, type: file\"]","title":"Usage02: getting file and directory with recursive option"},{"location":"src/file/glob.html#implementation","text":"Source: sstd/src/file/glob.cpp Header: sstd/src/file/glob.hpp Test: test/file/glob.hpp","title":"Implementation"},{"location":"src/file/mkdir.html","text":"mkdir Abstract mkdir creates directories recursively. mkdir \u306f\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u518d\u5e30\u7684\u306b\u4f5c\u6210\u3057\u307e\u3059\uff0e Header file namespace sstd { void mkdir ( const char * pPath ); void mkdir ( const std :: string & path ); } Usage main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp/a/b/c/\" ); sstd :: system ( \"tree ./tmp\" ); sstd :: rm ( \"./tmp\" ); } Execution result sh: tree: not found Implementation Source: sstd/src/mkdir.cpp Header: sstd/src/mkdir.hpp Test: test/mkdir.hpp (Not implemented yet)","title":"mkdir"},{"location":"src/file/mkdir.html#mkdir","text":"","title":"mkdir"},{"location":"src/file/mkdir.html#abstract","text":"mkdir creates directories recursively. mkdir \u306f\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u518d\u5e30\u7684\u306b\u4f5c\u6210\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/file/mkdir.html#header-file","text":"namespace sstd { void mkdir ( const char * pPath ); void mkdir ( const std :: string & path ); }","title":"Header file"},{"location":"src/file/mkdir.html#usage","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp/a/b/c/\" ); sstd :: system ( \"tree ./tmp\" ); sstd :: rm ( \"./tmp\" ); } Execution result sh: tree: not found","title":"Usage"},{"location":"src/file/mkdir.html#implementation","text":"Source: sstd/src/mkdir.cpp Header: sstd/src/mkdir.hpp Test: test/mkdir.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/file/path.html","text":"path Abstract path.hpp contains functions for path editing. path.hpp \u306f\u30d1\u30b9\u7de8\u96c6\u7528\u306e\u95a2\u6570\u3092\u53ce\u9332\u3057\u307e\u3059\uff0e Header file namespace sstd { std :: string getPath ( const char * pPath ); char * getFileName ( const char * pPath ); std :: string getFileName_withoutExtension ( const char * pPath ); char * getExtension ( const char * pPath ); std :: vector < std :: string > parsePath ( const char * pPath ); std :: vector < std :: string > parsePath_withBase ( const char * pPath ); bool isFile ( const char * pPath ); bool isFile ( const std :: string & path ); bool isDir ( const char * pPath ); bool isDir ( const std :: string & path ); bool fileExist ( const char * pPath ); bool fileExist ( const std :: string & path ); bool dirExist ( const char * pPath ); bool dirExist ( const std :: string & path ); bool pathExist ( const char * pPath ); bool pathExist ( const std :: string & path ); } Usage main.cpp #include <sstd/sstd.hpp> int main (){ std :: string path = \"./abc/DEF/example.txt\" ; sstd :: printn ( sstd :: getPath ( path . c_str ()) ); sstd :: printn ( sstd :: getFileName ( path . c_str ()) ); sstd :: printn ( sstd :: getFileName_withoutExtension ( path . c_str ()) ); sstd :: printn ( sstd :: getExtension ( path . c_str ()) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: parsePath ( path . c_str ()) ); sstd :: printn ( sstd :: parsePath_withBase ( path . c_str ()) ); printf ( \" \\n \" ); std :: string path_dir = \"./tmp\" ; std :: string path_file = \"./tmp/example.txt\" ; sstd :: system ( sstd :: ssprintf ( \"mkdir %s\" , path_dir . c_str ())); sstd :: system ( sstd :: ssprintf ( \"touch %s\" , path_file . c_str ())); sstd :: printn ( sstd :: isFile ( path_dir . c_str ()) ); sstd :: printn ( sstd :: isFile ( path_file . c_str ()) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isDir ( path_dir . c_str ()) ); sstd :: printn ( sstd :: isDir ( path_file . c_str ()) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: fileExist ( path_file . c_str ()) ); sstd :: printn ( sstd :: dirExist ( path_dir . c_str ()) ); printf ( \" \\n \" ); sstd :: rm ( path_dir ); sstd :: printn ( sstd :: fileExist ( path_file . c_str ()) ); sstd :: printn ( sstd :: dirExist ( path_dir . c_str ()) ); } Execution result sstd::getPath(path.c_str()) = \"./abc/DEF/\" sstd::getFileName(path.c_str()) = \"example.txt\" sstd::getFileName_withoutExtension(path.c_str()) = \"example\" sstd::getExtension(path.c_str()) = \"txt\" sstd::parsePath(path.c_str()) = [\".\" \"abc\" \"DEF\" \"example.txt\"] sstd::parsePath_withBase(path.c_str()) = [\".\" \"./abc\" \"./abc/DEF\" \"./abc/DEF/example.txt\"] sstd::isFile(path_dir.c_str()) = false sstd::isFile(path_file.c_str()) = true sstd::isDir(path_dir.c_str()) = true sstd::isDir(path_file.c_str()) = false sstd::fileExist(path_file.c_str()) = true sstd::dirExist(path_dir.c_str()) = true sstd::fileExist(path_file.c_str()) = false sstd::dirExist(path_dir.c_str()) = false Implementation Source: sstd/src/path.cpp Header: sstd/src/path.hpp Test: test/path.hpp (Not implemented yet)","title":"path"},{"location":"src/file/path.html#path","text":"","title":"path"},{"location":"src/file/path.html#abstract","text":"path.hpp contains functions for path editing. path.hpp \u306f\u30d1\u30b9\u7de8\u96c6\u7528\u306e\u95a2\u6570\u3092\u53ce\u9332\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/file/path.html#header-file","text":"namespace sstd { std :: string getPath ( const char * pPath ); char * getFileName ( const char * pPath ); std :: string getFileName_withoutExtension ( const char * pPath ); char * getExtension ( const char * pPath ); std :: vector < std :: string > parsePath ( const char * pPath ); std :: vector < std :: string > parsePath_withBase ( const char * pPath ); bool isFile ( const char * pPath ); bool isFile ( const std :: string & path ); bool isDir ( const char * pPath ); bool isDir ( const std :: string & path ); bool fileExist ( const char * pPath ); bool fileExist ( const std :: string & path ); bool dirExist ( const char * pPath ); bool dirExist ( const std :: string & path ); bool pathExist ( const char * pPath ); bool pathExist ( const std :: string & path ); }","title":"Header file"},{"location":"src/file/path.html#usage","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: string path = \"./abc/DEF/example.txt\" ; sstd :: printn ( sstd :: getPath ( path . c_str ()) ); sstd :: printn ( sstd :: getFileName ( path . c_str ()) ); sstd :: printn ( sstd :: getFileName_withoutExtension ( path . c_str ()) ); sstd :: printn ( sstd :: getExtension ( path . c_str ()) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: parsePath ( path . c_str ()) ); sstd :: printn ( sstd :: parsePath_withBase ( path . c_str ()) ); printf ( \" \\n \" ); std :: string path_dir = \"./tmp\" ; std :: string path_file = \"./tmp/example.txt\" ; sstd :: system ( sstd :: ssprintf ( \"mkdir %s\" , path_dir . c_str ())); sstd :: system ( sstd :: ssprintf ( \"touch %s\" , path_file . c_str ())); sstd :: printn ( sstd :: isFile ( path_dir . c_str ()) ); sstd :: printn ( sstd :: isFile ( path_file . c_str ()) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isDir ( path_dir . c_str ()) ); sstd :: printn ( sstd :: isDir ( path_file . c_str ()) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: fileExist ( path_file . c_str ()) ); sstd :: printn ( sstd :: dirExist ( path_dir . c_str ()) ); printf ( \" \\n \" ); sstd :: rm ( path_dir ); sstd :: printn ( sstd :: fileExist ( path_file . c_str ()) ); sstd :: printn ( sstd :: dirExist ( path_dir . c_str ()) ); } Execution result sstd::getPath(path.c_str()) = \"./abc/DEF/\" sstd::getFileName(path.c_str()) = \"example.txt\" sstd::getFileName_withoutExtension(path.c_str()) = \"example\" sstd::getExtension(path.c_str()) = \"txt\" sstd::parsePath(path.c_str()) = [\".\" \"abc\" \"DEF\" \"example.txt\"] sstd::parsePath_withBase(path.c_str()) = [\".\" \"./abc\" \"./abc/DEF\" \"./abc/DEF/example.txt\"] sstd::isFile(path_dir.c_str()) = false sstd::isFile(path_file.c_str()) = true sstd::isDir(path_dir.c_str()) = true sstd::isDir(path_file.c_str()) = false sstd::fileExist(path_file.c_str()) = true sstd::dirExist(path_dir.c_str()) = true sstd::fileExist(path_file.c_str()) = false sstd::dirExist(path_dir.c_str()) = false","title":"Usage"},{"location":"src/file/path.html#implementation","text":"Source: sstd/src/path.cpp Header: sstd/src/path.hpp Test: test/path.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/file/read_write.html","text":"read / write Abstract Functions for reading and writing files. \u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u66f8\u304d\u306b\u5229\u7528\u3059\u308b\u95a2\u6570\uff0e Header file namespace sstd { std :: vector < uint8 > read_bin ( const char * path ); std :: vector < uint8 > read_bin ( const std :: string & path ); bool write_bin ( const char * path , std :: vector < uint8 >& rhs ); bool write_bin ( const std :: string & path , std :: vector < uint8 >& rhs ); std :: string read ( const char * path ); std :: string read ( const std :: string & path ); std :: string read_withoutBOM ( const char * path ); std :: string read_withoutBOM ( const std :: string & path ); size_t write ( const char * path , const void * ptr , const size_t type_size , const size_t num ); // (1) size_t write ( const std :: string & path , const void * ptr , const size_t type_size , const size_t num ); // (2) size_t write ( const char * path , const std :: string & s ); // (3) size_t write ( const std :: string & path , const char * s ); // (4) size_t write ( const std :: string & path , const std :: string & s ); // (5) } Usage main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); std :: string f_path = \"./tmp/test_read_write.txt\" ; std :: string s = \"abcdef \\n GHIJK\" ; size_t w_size = sstd :: write ( f_path , s ); sstd :: printn ( w_size ); std :: string s_read = sstd :: read ( f_path ); sstd :: printn ( s_read . size ()); sstd :: printn ( s_read ); sstd :: rm ( \"./tmp\" ); } Execution result w_size = 12 s_read.size() = 12 s_read = \"abcdef GHIJK\" Implementation Source: sstd/src/file/read_write.cpp Header: sstd/src/file/read_write.hpp Test: test/file/read_write.hpp (Not implemented yet)","title":"read / write"},{"location":"src/file/read_write.html#read-write","text":"","title":"read / write"},{"location":"src/file/read_write.html#abstract","text":"Functions for reading and writing files. \u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u66f8\u304d\u306b\u5229\u7528\u3059\u308b\u95a2\u6570\uff0e","title":"Abstract"},{"location":"src/file/read_write.html#header-file","text":"namespace sstd { std :: vector < uint8 > read_bin ( const char * path ); std :: vector < uint8 > read_bin ( const std :: string & path ); bool write_bin ( const char * path , std :: vector < uint8 >& rhs ); bool write_bin ( const std :: string & path , std :: vector < uint8 >& rhs ); std :: string read ( const char * path ); std :: string read ( const std :: string & path ); std :: string read_withoutBOM ( const char * path ); std :: string read_withoutBOM ( const std :: string & path ); size_t write ( const char * path , const void * ptr , const size_t type_size , const size_t num ); // (1) size_t write ( const std :: string & path , const void * ptr , const size_t type_size , const size_t num ); // (2) size_t write ( const char * path , const std :: string & s ); // (3) size_t write ( const std :: string & path , const char * s ); // (4) size_t write ( const std :: string & path , const std :: string & s ); // (5) }","title":"Header file"},{"location":"src/file/read_write.html#usage","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); std :: string f_path = \"./tmp/test_read_write.txt\" ; std :: string s = \"abcdef \\n GHIJK\" ; size_t w_size = sstd :: write ( f_path , s ); sstd :: printn ( w_size ); std :: string s_read = sstd :: read ( f_path ); sstd :: printn ( s_read . size ()); sstd :: printn ( s_read ); sstd :: rm ( \"./tmp\" ); } Execution result w_size = 12 s_read.size() = 12 s_read = \"abcdef GHIJK\"","title":"Usage"},{"location":"src/file/read_write.html#implementation","text":"Source: sstd/src/file/read_write.cpp Header: sstd/src/file/read_write.hpp Test: test/file/read_write.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/file/rm.html","text":"rm Abstract rm.cpp / rm.hpp contains the processing related to deletion. rm.cpp / rm.hpp \u306b\u306f\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u524a\u9664\u306b\u95a2\u3059\u308b\u51e6\u7406\u3092\u53ce\u9332\u3057\u307e\u3059\uff0e Header file namespace sstd { struct pathAndType { std :: string path ; char type ; // 'f': file, 'd': directory }; bool unlink ( const char * pPath ); // delete file bool unlink ( const std :: string & path ); // delete file bool rmdir ( const char * pPath ); // delete empty directory bool rmdir ( const std :: string & path ); // delete empty directory bool rm ( const char * pPath ); // delete all under the pPath bool rm ( const std :: string & path ); // delete all under the path } Usage Removing directories recursively (\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306e\u518d\u5e30\u7684\u306a\u524a\u9664) main.cpp #include <sstd/sstd.hpp> int main (){ printf ( \"--- mkdir --- \\n \" ); fflush ( stdout ); sstd :: mkdir ( \"./tmp/a/b/c\" ); sstd :: system ( \"tree ./tmp\" ); printf ( \" \\n\\n \" ); printf ( \"--- rm --- \\n \" ); fflush ( stdout ); sstd :: rm ( \"./tmp\" ); sstd :: system ( \"tree ./tmp\" ); } Execution result --- mkdir --- sh: tree: not found --- rm --- sh: tree: not found Implementation Source: sstd/src/rm.cpp Header: sstd/src/rm.hpp Test: test/rm.hpp (Not implemented yet)","title":"rm"},{"location":"src/file/rm.html#rm","text":"","title":"rm"},{"location":"src/file/rm.html#abstract","text":"rm.cpp / rm.hpp contains the processing related to deletion. rm.cpp / rm.hpp \u306b\u306f\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u524a\u9664\u306b\u95a2\u3059\u308b\u51e6\u7406\u3092\u53ce\u9332\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/file/rm.html#header-file","text":"namespace sstd { struct pathAndType { std :: string path ; char type ; // 'f': file, 'd': directory }; bool unlink ( const char * pPath ); // delete file bool unlink ( const std :: string & path ); // delete file bool rmdir ( const char * pPath ); // delete empty directory bool rmdir ( const std :: string & path ); // delete empty directory bool rm ( const char * pPath ); // delete all under the pPath bool rm ( const std :: string & path ); // delete all under the path }","title":"Header file"},{"location":"src/file/rm.html#usage","text":"","title":"Usage"},{"location":"src/file/rm.html#removing-directories-recursively","text":"main.cpp #include <sstd/sstd.hpp> int main (){ printf ( \"--- mkdir --- \\n \" ); fflush ( stdout ); sstd :: mkdir ( \"./tmp/a/b/c\" ); sstd :: system ( \"tree ./tmp\" ); printf ( \" \\n\\n \" ); printf ( \"--- rm --- \\n \" ); fflush ( stdout ); sstd :: rm ( \"./tmp\" ); sstd :: system ( \"tree ./tmp\" ); } Execution result --- mkdir --- sh: tree: not found --- rm --- sh: tree: not found","title":"Removing directories recursively (\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306e\u518d\u5e30\u7684\u306a\u524a\u9664)"},{"location":"src/file/rm.html#implementation","text":"Source: sstd/src/rm.cpp Header: sstd/src/rm.hpp Test: test/rm.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/file/tinyInterpreter.html","text":"tinyInterpreter Abstract getCommandList() read text file, defineing middle of /*~*/ and before // as a commnet. And up to ; is considered as one command list. The returning the value is formed as a list of command. getCommandList() \u306f txt \u30d5\u30a1\u30a4\u30eb\u3092\u8aad\u307f\u8fbc\u307f\u307e\u3059\uff0e\u3053\u306e\u969b\u306b\uff0c /*~*/ \u3067\u56f2\u307e\u308c\u305f\u533a\u9593\u3084\uff0c\u540c\u4e00\u884c\u4e2d\u3067 // \u3088\u308a\u5f8c\u308d\u306e\u6587\u5b57\u5217\u3092\u30b3\u30e1\u30f3\u30c8\u3068\u307f\u306a\u3057\u53d6\u308a\u9664\u304d\u307e\u3059\uff0e \u307e\u305f\uff0c ; \u307e\u3067\u3092\u4e00\u3064\u306e\u30b3\u30de\u30f3\u30c9\u30ea\u30b9\u30c8\u307f\u306a\u3057\u307e\u3059\uff0e\u623b\u308a\u5024\u306f\u30b3\u30de\u30f3\u30c9\u306e\u30ea\u30b9\u30c8\u306e\u5f62\u5f0f\u3068\u306a\u308a\u307e\u3059\uff0e Header file namespace sstd { std :: vector < std :: string > getCommandList ( const char * pReadFile ); std :: vector < std :: string > splitByComma ( const std :: string & str ); } Usage tinyInterpreter.txt // - In this file, middle of \"/*~*/\" and before \"//\" mean commnets. // And a \";\" means the end of command. // comment /* comment */ /* comment comment comment */ cmd01, cmd02, , cmd04; // comment cmd05, cmd06, cmd07; // comment cmd09, cmd10, cmd11, cmd12; main.cpp #include <sstd/sstd.hpp> int main (){ // reading \"tinyInterpreter.txt\" to vv_ret std :: vector < std :: string > v_line = sstd :: getCommandList ( R \" ( ./tinyInterpreter.txt ) \" ); sstd :: vvec < std :: string > vv_ret ( v_line . size ()); for ( uint i = 0 ; i < v_line . size (); ++ i ){ std :: vector < std :: string > v_cmd = sstd :: splitByComma ( v_line [ i ]); for ( uint n = 0 ; n < v_cmd . size (); ++ n ){ vv_ret [ i ] <<= v_cmd [ n ]; } } sstd :: printn ( vv_ret ); } Execution result vv_ret = [[\"cmd01\" \"cmd02\" \"\" \"cmd04\"] [\"cmd05\" \"cmd06\" \"cmd07\"] [\"cmd09\" \"cmd10\" \"cmd11\" \"cmd12\"]] Implementation Source: sstd/src/file/tinyInterpreter.cpp Header: sstd/src/file/tinyInterpreter.hpp Test: test/file/tinyInterpreter.hpp","title":"tinyInterpreter"},{"location":"src/file/tinyInterpreter.html#tinyinterpreter","text":"","title":"tinyInterpreter"},{"location":"src/file/tinyInterpreter.html#abstract","text":"getCommandList() read text file, defineing middle of /*~*/ and before // as a commnet. And up to ; is considered as one command list. The returning the value is formed as a list of command. getCommandList() \u306f txt \u30d5\u30a1\u30a4\u30eb\u3092\u8aad\u307f\u8fbc\u307f\u307e\u3059\uff0e\u3053\u306e\u969b\u306b\uff0c /*~*/ \u3067\u56f2\u307e\u308c\u305f\u533a\u9593\u3084\uff0c\u540c\u4e00\u884c\u4e2d\u3067 // \u3088\u308a\u5f8c\u308d\u306e\u6587\u5b57\u5217\u3092\u30b3\u30e1\u30f3\u30c8\u3068\u307f\u306a\u3057\u53d6\u308a\u9664\u304d\u307e\u3059\uff0e \u307e\u305f\uff0c ; \u307e\u3067\u3092\u4e00\u3064\u306e\u30b3\u30de\u30f3\u30c9\u30ea\u30b9\u30c8\u307f\u306a\u3057\u307e\u3059\uff0e\u623b\u308a\u5024\u306f\u30b3\u30de\u30f3\u30c9\u306e\u30ea\u30b9\u30c8\u306e\u5f62\u5f0f\u3068\u306a\u308a\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/file/tinyInterpreter.html#header-file","text":"namespace sstd { std :: vector < std :: string > getCommandList ( const char * pReadFile ); std :: vector < std :: string > splitByComma ( const std :: string & str ); }","title":"Header file"},{"location":"src/file/tinyInterpreter.html#usage","text":"tinyInterpreter.txt // - In this file, middle of \"/*~*/\" and before \"//\" mean commnets. // And a \";\" means the end of command. // comment /* comment */ /* comment comment comment */ cmd01, cmd02, , cmd04; // comment cmd05, cmd06, cmd07; // comment cmd09, cmd10, cmd11, cmd12; main.cpp #include <sstd/sstd.hpp> int main (){ // reading \"tinyInterpreter.txt\" to vv_ret std :: vector < std :: string > v_line = sstd :: getCommandList ( R \" ( ./tinyInterpreter.txt ) \" ); sstd :: vvec < std :: string > vv_ret ( v_line . size ()); for ( uint i = 0 ; i < v_line . size (); ++ i ){ std :: vector < std :: string > v_cmd = sstd :: splitByComma ( v_line [ i ]); for ( uint n = 0 ; n < v_cmd . size (); ++ n ){ vv_ret [ i ] <<= v_cmd [ n ]; } } sstd :: printn ( vv_ret ); } Execution result vv_ret = [[\"cmd01\" \"cmd02\" \"\" \"cmd04\"] [\"cmd05\" \"cmd06\" \"cmd07\"] [\"cmd09\" \"cmd10\" \"cmd11\" \"cmd12\"]]","title":"Usage"},{"location":"src/file/tinyInterpreter.html#implementation","text":"Source: sstd/src/file/tinyInterpreter.cpp Header: sstd/src/file/tinyInterpreter.hpp Test: test/file/tinyInterpreter.hpp","title":"Implementation"},{"location":"src/hashFunction/md5.html","text":"MD5 Abstract md5() calculate MD5 cryptographic hash function. md5() \u306f\u6697\u53f7\u5b66\u7684\u30cf\u30c3\u30b7\u30e5\u95a2\u6570\u3067\u3042\u308b MD5 \u3092\u8a08\u7b97\u3057\u307e\u3059\uff0e Header file namespace sstd { std :: vector < uint8 > md5 ( const uchar * in , size_t in_len ); std :: vector < uint8 > md5 ( const std :: vector < uint8 >& in ); } Usage main.cpp #include <sstd/sstd.hpp> std :: string uint8_to_str ( const std :: vector < uint8 >& v ){ std :: string s ; for ( uint i = 0 ; i < v . size (); ++ i ){ s += sstd :: ssprintf ( \"%02x\" , ( int ) v [ i ]); } return s ; } int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"head -c 5m /dev/urandom > ./tmp/rand.txt\" ); // generate 5 MB random file sstd :: system ( \"md5sum ./tmp/rand.txt\" ); std :: vector < uint8 > vBin = sstd :: read_bin ( \"./tmp/rand.txt\" ); // read all as a binary std :: string md5_str = uint8_to_str ( sstd :: md5 ( vBin ) ); sstd :: printn ( md5_str ); sstd :: rm ( \"./tmp\" ); } Execution result 5cc93054308d752afad0a7232248da45 ./tmp/rand.txt md5_str = \"5cc93054308d752afad0a7232248da45\" Implementation Source: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.cpp Header: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp Test: test/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp (Not implemented yet)","title":"MD5"},{"location":"src/hashFunction/md5.html#md5","text":"","title":"MD5"},{"location":"src/hashFunction/md5.html#abstract","text":"md5() calculate MD5 cryptographic hash function. md5() \u306f\u6697\u53f7\u5b66\u7684\u30cf\u30c3\u30b7\u30e5\u95a2\u6570\u3067\u3042\u308b MD5 \u3092\u8a08\u7b97\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/hashFunction/md5.html#header-file","text":"namespace sstd { std :: vector < uint8 > md5 ( const uchar * in , size_t in_len ); std :: vector < uint8 > md5 ( const std :: vector < uint8 >& in ); }","title":"Header file"},{"location":"src/hashFunction/md5.html#usage","text":"main.cpp #include <sstd/sstd.hpp> std :: string uint8_to_str ( const std :: vector < uint8 >& v ){ std :: string s ; for ( uint i = 0 ; i < v . size (); ++ i ){ s += sstd :: ssprintf ( \"%02x\" , ( int ) v [ i ]); } return s ; } int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"head -c 5m /dev/urandom > ./tmp/rand.txt\" ); // generate 5 MB random file sstd :: system ( \"md5sum ./tmp/rand.txt\" ); std :: vector < uint8 > vBin = sstd :: read_bin ( \"./tmp/rand.txt\" ); // read all as a binary std :: string md5_str = uint8_to_str ( sstd :: md5 ( vBin ) ); sstd :: printn ( md5_str ); sstd :: rm ( \"./tmp\" ); } Execution result 5cc93054308d752afad0a7232248da45 ./tmp/rand.txt md5_str = \"5cc93054308d752afad0a7232248da45\"","title":"Usage"},{"location":"src/hashFunction/md5.html#implementation","text":"Source: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.cpp Header: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp Test: test/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/hashFunction/sha1.html","text":"SHA-1 Abstract sha1() calculate SHA-1 cryptographic hash function. sha1() \u306f\u6697\u53f7\u5b66\u7684\u30cf\u30c3\u30b7\u30e5\u95a2\u6570\u3067\u3042\u308b SHA-1 \u3092\u8a08\u7b97\u3057\u307e\u3059\uff0e Header file namespace sstd { std :: vector < uint8 > sha1 ( const uchar * in , size_t in_len ); std :: vector < uint8 > sha1 ( const std :: vector < uint8 >& in ); } Usage main.cpp #include <sstd/sstd.hpp> std :: string uint8_to_str ( const std :: vector < uint8 >& v ){ std :: string s ; for ( uint i = 0 ; i < v . size (); ++ i ){ s += sstd :: ssprintf ( \"%02x\" , ( int ) v [ i ]); } return s ; } int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"head -c 5m /dev/urandom > ./tmp/rand.txt\" ); // generate 5 MB random file sstd :: system ( \"sha1sum ./tmp/rand.txt\" ); std :: vector < uint8 > vBin = sstd :: read_bin ( \"./tmp/rand.txt\" ); // read all as a binary std :: string md5_str = uint8_to_str ( sstd :: sha1 ( vBin ) ); sstd :: printn ( md5_str ); sstd :: rm ( \"./tmp\" ); } Execution result dc06cade999ee6728e1615600dc3f35d11bbbd9c ./tmp/rand.txt md5_str = \"dc06cade999ee6728e1615600dc3f35d11bbbd9c\" Implementation Source: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.cpp Header: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp Test: test/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp (Not implemented yet)","title":"SHA-1"},{"location":"src/hashFunction/sha1.html#sha-1","text":"","title":"SHA-1"},{"location":"src/hashFunction/sha1.html#abstract","text":"sha1() calculate SHA-1 cryptographic hash function. sha1() \u306f\u6697\u53f7\u5b66\u7684\u30cf\u30c3\u30b7\u30e5\u95a2\u6570\u3067\u3042\u308b SHA-1 \u3092\u8a08\u7b97\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/hashFunction/sha1.html#header-file","text":"namespace sstd { std :: vector < uint8 > sha1 ( const uchar * in , size_t in_len ); std :: vector < uint8 > sha1 ( const std :: vector < uint8 >& in ); }","title":"Header file"},{"location":"src/hashFunction/sha1.html#usage","text":"main.cpp #include <sstd/sstd.hpp> std :: string uint8_to_str ( const std :: vector < uint8 >& v ){ std :: string s ; for ( uint i = 0 ; i < v . size (); ++ i ){ s += sstd :: ssprintf ( \"%02x\" , ( int ) v [ i ]); } return s ; } int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"head -c 5m /dev/urandom > ./tmp/rand.txt\" ); // generate 5 MB random file sstd :: system ( \"sha1sum ./tmp/rand.txt\" ); std :: vector < uint8 > vBin = sstd :: read_bin ( \"./tmp/rand.txt\" ); // read all as a binary std :: string md5_str = uint8_to_str ( sstd :: sha1 ( vBin ) ); sstd :: printn ( md5_str ); sstd :: rm ( \"./tmp\" ); } Execution result dc06cade999ee6728e1615600dc3f35d11bbbd9c ./tmp/rand.txt md5_str = \"dc06cade999ee6728e1615600dc3f35d11bbbd9c\"","title":"Usage"},{"location":"src/hashFunction/sha1.html#implementation","text":"Source: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.cpp Header: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp Test: test/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/hashFunction/sha2.html","text":"SHA-2 (224, 256, 384, 512 bits) Abstract sha224() , sha256() , sha384() and sha512() calculate SHA-2 cryptographic hash function. sha224() , sha256() , sha384() \u304a\u3088\u3073 sha512() \u306f\u6697\u53f7\u5b66\u7684\u30cf\u30c3\u30b7\u30e5\u95a2\u6570\u3067\u3042\u308b SHA-2 \u3092\u8a08\u7b97\u3057\u307e\u3059\uff0e Header file namespace sstd { std :: vector < uint8 > sha224 ( const uchar * in , size_t in_len ); std :: vector < uint8 > sha256 ( const uchar * in , size_t in_len ); std :: vector < uint8 > sha384 ( const uchar * in , size_t in_len ); std :: vector < uint8 > sha512 ( const uchar * in , size_t in_len ); std :: vector < uint8 > sha224 ( const std :: vector < uint8 >& in ); std :: vector < uint8 > sha256 ( const std :: vector < uint8 >& in ); std :: vector < uint8 > sha384 ( const std :: vector < uint8 >& in ); std :: vector < uint8 > sha512 ( const std :: vector < uint8 >& in ); } Usage main.cpp #include <sstd/sstd.hpp> std :: string uint8_to_str ( const std :: vector < uint8 >& v ){ std :: string s ; for ( uint i = 0 ; i < v . size (); ++ i ){ s += sstd :: ssprintf ( \"%02x\" , ( int ) v [ i ]); } return s ; } int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"head -c 5m /dev/urandom > ./tmp/rand.txt\" ); // generate 5 MB random file sstd :: system ( \"sha224sum ./tmp/rand.txt\" ); std :: vector < uint8 > vBin = sstd :: read_bin ( \"./tmp/rand.txt\" ); // read all as a binary std :: string sha224_str = uint8_to_str ( sstd :: sha224 ( vBin ) ); sstd :: printn ( sha224_str ); sstd :: rm ( \"./tmp\" ); } Execution result sh: sha224sum: not found sha224_str = \"33cddf3ae786a6c45d743b7708c6c8b9816244786bd1419a96c51c6c\" Implementation Source: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.cpp Header: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp Test: test/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp (Not implemented yet)","title":"SHA-2<br/>(224, 256, 384, 512 bits)"},{"location":"src/hashFunction/sha2.html#sha-2224-256-384-512-bits","text":"","title":"SHA-2(224, 256, 384, 512 bits)"},{"location":"src/hashFunction/sha2.html#abstract","text":"sha224() , sha256() , sha384() and sha512() calculate SHA-2 cryptographic hash function. sha224() , sha256() , sha384() \u304a\u3088\u3073 sha512() \u306f\u6697\u53f7\u5b66\u7684\u30cf\u30c3\u30b7\u30e5\u95a2\u6570\u3067\u3042\u308b SHA-2 \u3092\u8a08\u7b97\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/hashFunction/sha2.html#header-file","text":"namespace sstd { std :: vector < uint8 > sha224 ( const uchar * in , size_t in_len ); std :: vector < uint8 > sha256 ( const uchar * in , size_t in_len ); std :: vector < uint8 > sha384 ( const uchar * in , size_t in_len ); std :: vector < uint8 > sha512 ( const uchar * in , size_t in_len ); std :: vector < uint8 > sha224 ( const std :: vector < uint8 >& in ); std :: vector < uint8 > sha256 ( const std :: vector < uint8 >& in ); std :: vector < uint8 > sha384 ( const std :: vector < uint8 >& in ); std :: vector < uint8 > sha512 ( const std :: vector < uint8 >& in ); }","title":"Header file"},{"location":"src/hashFunction/sha2.html#usage","text":"main.cpp #include <sstd/sstd.hpp> std :: string uint8_to_str ( const std :: vector < uint8 >& v ){ std :: string s ; for ( uint i = 0 ; i < v . size (); ++ i ){ s += sstd :: ssprintf ( \"%02x\" , ( int ) v [ i ]); } return s ; } int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"head -c 5m /dev/urandom > ./tmp/rand.txt\" ); // generate 5 MB random file sstd :: system ( \"sha224sum ./tmp/rand.txt\" ); std :: vector < uint8 > vBin = sstd :: read_bin ( \"./tmp/rand.txt\" ); // read all as a binary std :: string sha224_str = uint8_to_str ( sstd :: sha224 ( vBin ) ); sstd :: printn ( sha224_str ); sstd :: rm ( \"./tmp\" ); } Execution result sh: sha224sum: not found sha224_str = \"33cddf3ae786a6c45d743b7708c6c8b9816244786bd1419a96c51c6c\"","title":"Usage"},{"location":"src/hashFunction/sha2.html#implementation","text":"Source: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.cpp Header: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp Test: test/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/matrix/bmat.html","text":"bmat (binary-matrix) Abstract bmat is a binary matrix calculation container. bmat \u306f\u30d0\u30a4\u30ca\u30ea\u884c\u5217\u8a08\u7b97\u30b3\u30f3\u30c6\u30ca\u3067\u3059\uff0e Header file namespace sstd { class bmat ; void copy ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); void move ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); void eye ( class sstd :: bmat & bMat ); void ones ( class sstd :: bmat & bMat ); void zeros ( class sstd :: bmat & bMat ); class sstd :: bmat eye ( const uint & row , const uint & col ); // \u3053\u306e\u3042\u305f\u308a\uff0c\u623b\u308a\u5024\u3067\u95a2\u6570\u306f\u30aa\u30fc\u30d0\u30fc\u30ed\u30fc\u30c9\u3067\u304d\u306a\u3044\u306e\u3067\uff0c\u4ed6\u306e\u578b\u306b\u3064\u3044\u3066\u3082\u5b9f\u88c5\u3059\u308b\u3068\uff0c\u885d\u7a81\u3059\u308b\u5371\u967a\u304c\u3042\u308b\uff0e(\u66f8\u304d\u76f4\u3057\uff0e class sstd :: bmat ones ( const uint & row , const uint & col ); class sstd :: bmat zeros ( const uint & row , const uint & col ); class sstd :: bmat eye ( const uint & size ); class sstd :: bmat ones ( const uint & size ); class sstd :: bmat zeros ( const uint & size ); class sstd :: bmat LxShiftMat ( uint size , uint xShift ); // square matrix [size x size] class sstd :: bmat RxShiftMat ( uint size , uint xShift ); // square matrix [size x size] class sstd :: bmat Tr ( class sstd :: bmat & rhs ); // lhs = Transpose(rhs) void Tr_myself ( class sstd :: bmat & rhs ); // Transpose(rhs) class sstd :: bmat add ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs + rhs (XOR) class sstd :: bmat mul ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs * rhs class sstd :: bmat pow ( class sstd :: bmat base , uint64 exponent ); // base^{exponent} void add_myself ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs += rhs (XOR) void mul_myself ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs *= rhs void pow_myself ( class sstd :: bmat & base , uint64 exponent ); // lhs ^= exponent class sstd :: bmat and_ ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs & rhs (AND) class sstd :: bmat or_ ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs | rhs (OR) class sstd :: bmat not_ ( class sstd :: bmat & rhs ); // ~rhs (NOT) class sstd :: bmat xor_ ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs + rhs (XOR) void and_myself ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs & rhs (AND) void or_myself ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs | rhs (OR) bool eq ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs == rhs bool ne ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs != rhs class sstd :: bmat REShift ( class sstd :: bmat & rhs , uint ShiftNum ); // RightExpansionShift // \u884c\u5217\u62e1\u5927\u53f3\u30b7\u30d5\u30c8 class sstd :: bmat DEShift ( class sstd :: bmat & rhs , uint ShiftNum ); // DownExpansionShift // \u884c\u5217\u62e1\u5927\u4e0b\u30b7\u30d5\u30c8 class sstd :: bmat horzcat2 ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs << rhs class sstd :: bmat vertcat2 ( class sstd :: bmat & us , class sstd :: bmat & ds ); // us && ds // upside, downside. }; class sstd :: bmat { private : uint rowNum ; // \u884c\u6570 uint colNum ; // \u5217\u6570 sstd :: mat_c < uint64 > binMat8x8 ; // 8x8 \u306e BinMartix \u884c\u5217\u306e\u96c6\u5408 public : bmat (); bmat ( const uint & row , const uint & col ); bmat ( class bmat & rhs ); bmat ( class bmat && rhs ); ~ bmat (){} // inline sstd::mat_c<uint64> bMat8x8(){ return binMat8x8; } // Do not do this to avoid object copy inline const sstd :: mat_c < uint64 >& bMat8x8_R () const { return binMat8x8 ; } inline const uint rows () const ; inline const uint cols () const ; // RW: read and write inline sstd :: mat_c < uint64 >& bMat8x8_RW (); inline uint & rows_RW (); inline uint & cols_RW (); class bmat & operator = ( const class bmat & rhs ); // called by \"lhs = sstd::add(A, B);\". class bmat operator + ( const class bmat & rhs ); // called by \"lhs + rhs;\". // XOR class bmat operator * ( const class bmat & rhs ); // called by \"lhs * rhs;\". // mul class bmat operator ^ ( const uint64 & rhs ); // called by \"lhs ^ rhs;\". // pow (not XOR) class bmat operator & ( const class bmat & rhs ); // called by \"lhs & rhs;\". // AND class bmat operator | ( const class bmat & rhs ); // called by \"lhs | rhs;\". // OR class bmat operator ~ () // called by \"~rhs;\". // NOT class bmat & operator += ( const class bmat & rhs ); // called by \"lhs += rhs;\". class bmat & operator *= ( const class bmat & rhs ); // called by \"lhs *= rhs;\". class bmat & operator ^= ( const uint64 & rhs ); // called by \"lhs ^= rhs;\". class bmat & operator &= ( const class bmat & rhs ); // called by \"lhs &= rhs;\". class bmat & operator |= ( const class bmat & rhs ); // called by \"lhs |= rhs;\". bool operator == ( const class bmat & rhs ); // called by \"sstd::bmat bMatA, bMatB; if(bMatA == bMatB){printf(\"same\\n\");}else{printf(\"different\\n\");}\". bool operator != ( const class bmat & rhs ); // called by \"sstd::bmat bMatA, bMatB; if(bMatA == bMatB){printf(\"same\\n\");}else{printf(\"different\\n\");}\". class bmat operator << ( const class bmat & rhs ); // called by \"sstd::bmat bMatA, bMatB, bMatC; bMatC = bMatA << bMatB;\". // Horizontal connection of matrix. class bmat operator && ( const class bmat & ds ); // called by \"sstd::bmat bMatA, bMatB, bMatC; bMatC = bMatA && bMatB;\". // Vertical connection of matrix. class SwapByOneIndex operator []( const uint & p ); // col-major order // called by \"sstd::bmat bMat; bool buf = bMat[0]; bool bMat[0] = buf;\". class SwapByOneIndex operator []( const int & p ); // col-major order // called by \"sstd::bmat bMat; bool buf = bMat[0]; bool bMat[0] = buf;\". class SwapByTwoIndex operator ()( const uint & p , const uint & q ); // called by \"sstd::bmat bMat; bool buf = bMat(0, 0); bool bMat(0, 0) = buf;\". class SwapByTwoIndex operator ()( const int & p , const uint & q ); // called by \"sstd::bmat bMat; bool buf = bMat(0, 0); bool bMat(0, 0) = buf;\". class SwapByTwoIndex operator ()( const uint & p , const int & q ); // called by \"sstd::bmat bMat; bool buf = bMat(0, 0); bool bMat(0, 0) = buf;\". class SwapByTwoIndex operator ()( const int & p , const int & q ); // called by \"sstd::bmat bMat; bool buf = bMat(0, 0); bool bMat(0, 0) = buf;\". }; Usage Execution result #include <sstd/sstd.hpp> bool isFullPeriod_LRL ( std :: vector < uint64 >& divs , uint N , uint a , uint b , uint c ){ sstd :: bmat I = sstd :: eye ( N , N ); sstd :: bmat La = sstd :: LxShiftMat ( N , a ); sstd :: bmat Rb = sstd :: RxShiftMat ( N , b ); sstd :: bmat Lc = sstd :: LxShiftMat ( N , c ); sstd :: bmat T = ( I + La ) * ( I + Rb ) * ( I + Lc ); // sstd::printn(T); for ( uint i = 0 ; i < divs . size () -1 ; i ++ ){ sstd :: bmat Tp = T ^ ( divs [ i ]); // XORSHIFT if ( Tp == I ){ return false ; } } sstd :: bmat Tp = T ^ ( divs [ divs . size () -1 ]); // XORSHIFT if ( Tp == I ){ return true ; } else { return false ; } } void T_LRL ( std :: vector < uint64 >& divs , uint N ){ uint num = 0 ; printf ( \" a, b, c \\n \" ); for ( uint a = 0 ; a < N ; a ++ ){ for ( uint b = 0 ; b < N ; b ++ ){ for ( uint c = 0 ; c < N ; c ++ ){ if ( a < c && isFullPeriod_LRL ( divs , N , a , b , c )){ printf ( \"|%2u, %2u, %2u\" , a , b , c ); num ++ ; if ( num % 9 == 0 ){ printf ( \"| \\n \" ); } } } } } } int main (){ printf ( \"\u25a0 measureTime_start--------------- \\n\\n \" ); time_m timem ; sstd :: measureTime_start ( timem ); // calculate divisors of 2^32-1. // std::vector<uint64> divs32 = sstd::divisor(4294967296-1); // Below line returns the same result of this line, but took a little time to run everytime and takes a little heavy memory (about 2 GByte). // std::vector<uint64> divs32 = {1, 3, 5, 15, 17, 51, 85, 255, 257, 771, 1285, 3855, 4369, 13107, 21845, 65535, 65537, 196611, 327685, 983055, 1114129, 3342387, 5570645, 16711935, 16843009, 50529027, 84215045, 252645135, 286331153, 858993459, 1431655765, 4294967295}; std :: vector < uint64 > divs32 = { 1ull * 5ull * 17ull * 257ull * 65537ull , 3ull * 1ull * 17ull * 257ull * 65537ull , 3ull * 5ull * 1ull * 257ull * 65537ull , 3ull * 5ull * 17ull * 1ull * 65537ull , 3ull * 5ull * 17ull * 257ull * 1ull , 3ull * 5ull * 17ull * 257ull * 65537ull }; printf ( \"\u25a1 calculate LRL 32bits \\n \" ); T_LRL ( divs32 , 32 ); printf ( \" \\n \" ); printf ( \" \\n \u25a0 measureTime_stop---------------- \\n \" ); sstd :: measureTime_stop_print ( timem ); return 0 ; } Execution result \u25a0 measureTime_start--------------- \u25a1 calculate LRL 32bits a, b, c | 1, 3, 10| 1, 5, 16| 1, 5, 19| 1, 9, 29| 1, 11, 6| 1, 11, 16| 1, 19, 3| 1, 21, 20| 1, 27, 27| | 2, 5, 15| 2, 5, 21| 2, 7, 7| 2, 7, 9| 2, 7, 25| 2, 9, 15| 2, 15, 17| 2, 15, 25| 2, 21, 9| | 3, 1, 14| 3, 3, 26| 3, 3, 28| 3, 3, 29| 3, 5, 20| 3, 5, 22| 3, 5, 25| 3, 7, 29| 3, 13, 7| | 3, 23, 25| 3, 25, 24| 3, 27, 11| 4, 3, 17| 4, 3, 27| 4, 5, 15| 5, 3, 21| 5, 7, 22| 5, 9, 7| | 5, 9, 28| 5, 9, 31| 5, 13, 6| 5, 15, 17| 5, 17, 13| 5, 21, 12| 5, 27, 8| 5, 27, 21| 5, 27, 25| | 5, 27, 28| 6, 1, 11| 6, 3, 17| 6, 17, 9| 6, 21, 7| 6, 21, 13| 7, 1, 9| 7, 1, 18| 7, 1, 25| | 7, 13, 25| 7, 17, 21| 7, 25, 12| 7, 25, 20| 8, 7, 23| 8, 9, 23| 9, 5, 14| 9, 5, 25| 9, 11, 19| | 9, 21, 16|10, 9, 21|10, 9, 25|11, 7, 12|11, 7, 16|11, 17, 13|11, 21, 13|12, 9, 23|13, 3, 17| |13, 3, 27|13, 5, 19|13, 17, 15|14, 1, 15|14, 13, 15|15, 1, 29|17, 15, 20|17, 15, 23|17, 15, 26| \u25a0 measureTime_stop---------------- -------------------------------- Execution time: 2. 941 sec -------------------------------- Implementation Source: sstd/src/matrixContainer_binary/bmat.cpp Header: sstd/src/matrixContainer_binary/bmat.hpp Test: test/bmat.hpp (Not implemented yet)","title":"bmat (binary-matrix)"},{"location":"src/matrix/bmat.html#bmat-binary-matrix","text":"","title":"bmat (binary-matrix)"},{"location":"src/matrix/bmat.html#abstract","text":"bmat is a binary matrix calculation container. bmat \u306f\u30d0\u30a4\u30ca\u30ea\u884c\u5217\u8a08\u7b97\u30b3\u30f3\u30c6\u30ca\u3067\u3059\uff0e","title":"Abstract"},{"location":"src/matrix/bmat.html#header-file","text":"namespace sstd { class bmat ; void copy ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); void move ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); void eye ( class sstd :: bmat & bMat ); void ones ( class sstd :: bmat & bMat ); void zeros ( class sstd :: bmat & bMat ); class sstd :: bmat eye ( const uint & row , const uint & col ); // \u3053\u306e\u3042\u305f\u308a\uff0c\u623b\u308a\u5024\u3067\u95a2\u6570\u306f\u30aa\u30fc\u30d0\u30fc\u30ed\u30fc\u30c9\u3067\u304d\u306a\u3044\u306e\u3067\uff0c\u4ed6\u306e\u578b\u306b\u3064\u3044\u3066\u3082\u5b9f\u88c5\u3059\u308b\u3068\uff0c\u885d\u7a81\u3059\u308b\u5371\u967a\u304c\u3042\u308b\uff0e(\u66f8\u304d\u76f4\u3057\uff0e class sstd :: bmat ones ( const uint & row , const uint & col ); class sstd :: bmat zeros ( const uint & row , const uint & col ); class sstd :: bmat eye ( const uint & size ); class sstd :: bmat ones ( const uint & size ); class sstd :: bmat zeros ( const uint & size ); class sstd :: bmat LxShiftMat ( uint size , uint xShift ); // square matrix [size x size] class sstd :: bmat RxShiftMat ( uint size , uint xShift ); // square matrix [size x size] class sstd :: bmat Tr ( class sstd :: bmat & rhs ); // lhs = Transpose(rhs) void Tr_myself ( class sstd :: bmat & rhs ); // Transpose(rhs) class sstd :: bmat add ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs + rhs (XOR) class sstd :: bmat mul ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs * rhs class sstd :: bmat pow ( class sstd :: bmat base , uint64 exponent ); // base^{exponent} void add_myself ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs += rhs (XOR) void mul_myself ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs *= rhs void pow_myself ( class sstd :: bmat & base , uint64 exponent ); // lhs ^= exponent class sstd :: bmat and_ ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs & rhs (AND) class sstd :: bmat or_ ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs | rhs (OR) class sstd :: bmat not_ ( class sstd :: bmat & rhs ); // ~rhs (NOT) class sstd :: bmat xor_ ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs + rhs (XOR) void and_myself ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs & rhs (AND) void or_myself ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs | rhs (OR) bool eq ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs == rhs bool ne ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs != rhs class sstd :: bmat REShift ( class sstd :: bmat & rhs , uint ShiftNum ); // RightExpansionShift // \u884c\u5217\u62e1\u5927\u53f3\u30b7\u30d5\u30c8 class sstd :: bmat DEShift ( class sstd :: bmat & rhs , uint ShiftNum ); // DownExpansionShift // \u884c\u5217\u62e1\u5927\u4e0b\u30b7\u30d5\u30c8 class sstd :: bmat horzcat2 ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs << rhs class sstd :: bmat vertcat2 ( class sstd :: bmat & us , class sstd :: bmat & ds ); // us && ds // upside, downside. }; class sstd :: bmat { private : uint rowNum ; // \u884c\u6570 uint colNum ; // \u5217\u6570 sstd :: mat_c < uint64 > binMat8x8 ; // 8x8 \u306e BinMartix \u884c\u5217\u306e\u96c6\u5408 public : bmat (); bmat ( const uint & row , const uint & col ); bmat ( class bmat & rhs ); bmat ( class bmat && rhs ); ~ bmat (){} // inline sstd::mat_c<uint64> bMat8x8(){ return binMat8x8; } // Do not do this to avoid object copy inline const sstd :: mat_c < uint64 >& bMat8x8_R () const { return binMat8x8 ; } inline const uint rows () const ; inline const uint cols () const ; // RW: read and write inline sstd :: mat_c < uint64 >& bMat8x8_RW (); inline uint & rows_RW (); inline uint & cols_RW (); class bmat & operator = ( const class bmat & rhs ); // called by \"lhs = sstd::add(A, B);\". class bmat operator + ( const class bmat & rhs ); // called by \"lhs + rhs;\". // XOR class bmat operator * ( const class bmat & rhs ); // called by \"lhs * rhs;\". // mul class bmat operator ^ ( const uint64 & rhs ); // called by \"lhs ^ rhs;\". // pow (not XOR) class bmat operator & ( const class bmat & rhs ); // called by \"lhs & rhs;\". // AND class bmat operator | ( const class bmat & rhs ); // called by \"lhs | rhs;\". // OR class bmat operator ~ () // called by \"~rhs;\". // NOT class bmat & operator += ( const class bmat & rhs ); // called by \"lhs += rhs;\". class bmat & operator *= ( const class bmat & rhs ); // called by \"lhs *= rhs;\". class bmat & operator ^= ( const uint64 & rhs ); // called by \"lhs ^= rhs;\". class bmat & operator &= ( const class bmat & rhs ); // called by \"lhs &= rhs;\". class bmat & operator |= ( const class bmat & rhs ); // called by \"lhs |= rhs;\". bool operator == ( const class bmat & rhs ); // called by \"sstd::bmat bMatA, bMatB; if(bMatA == bMatB){printf(\"same\\n\");}else{printf(\"different\\n\");}\". bool operator != ( const class bmat & rhs ); // called by \"sstd::bmat bMatA, bMatB; if(bMatA == bMatB){printf(\"same\\n\");}else{printf(\"different\\n\");}\". class bmat operator << ( const class bmat & rhs ); // called by \"sstd::bmat bMatA, bMatB, bMatC; bMatC = bMatA << bMatB;\". // Horizontal connection of matrix. class bmat operator && ( const class bmat & ds ); // called by \"sstd::bmat bMatA, bMatB, bMatC; bMatC = bMatA && bMatB;\". // Vertical connection of matrix. class SwapByOneIndex operator []( const uint & p ); // col-major order // called by \"sstd::bmat bMat; bool buf = bMat[0]; bool bMat[0] = buf;\". class SwapByOneIndex operator []( const int & p ); // col-major order // called by \"sstd::bmat bMat; bool buf = bMat[0]; bool bMat[0] = buf;\". class SwapByTwoIndex operator ()( const uint & p , const uint & q ); // called by \"sstd::bmat bMat; bool buf = bMat(0, 0); bool bMat(0, 0) = buf;\". class SwapByTwoIndex operator ()( const int & p , const uint & q ); // called by \"sstd::bmat bMat; bool buf = bMat(0, 0); bool bMat(0, 0) = buf;\". class SwapByTwoIndex operator ()( const uint & p , const int & q ); // called by \"sstd::bmat bMat; bool buf = bMat(0, 0); bool bMat(0, 0) = buf;\". class SwapByTwoIndex operator ()( const int & p , const int & q ); // called by \"sstd::bmat bMat; bool buf = bMat(0, 0); bool bMat(0, 0) = buf;\". };","title":"Header file"},{"location":"src/matrix/bmat.html#usage","text":"Execution result #include <sstd/sstd.hpp> bool isFullPeriod_LRL ( std :: vector < uint64 >& divs , uint N , uint a , uint b , uint c ){ sstd :: bmat I = sstd :: eye ( N , N ); sstd :: bmat La = sstd :: LxShiftMat ( N , a ); sstd :: bmat Rb = sstd :: RxShiftMat ( N , b ); sstd :: bmat Lc = sstd :: LxShiftMat ( N , c ); sstd :: bmat T = ( I + La ) * ( I + Rb ) * ( I + Lc ); // sstd::printn(T); for ( uint i = 0 ; i < divs . size () -1 ; i ++ ){ sstd :: bmat Tp = T ^ ( divs [ i ]); // XORSHIFT if ( Tp == I ){ return false ; } } sstd :: bmat Tp = T ^ ( divs [ divs . size () -1 ]); // XORSHIFT if ( Tp == I ){ return true ; } else { return false ; } } void T_LRL ( std :: vector < uint64 >& divs , uint N ){ uint num = 0 ; printf ( \" a, b, c \\n \" ); for ( uint a = 0 ; a < N ; a ++ ){ for ( uint b = 0 ; b < N ; b ++ ){ for ( uint c = 0 ; c < N ; c ++ ){ if ( a < c && isFullPeriod_LRL ( divs , N , a , b , c )){ printf ( \"|%2u, %2u, %2u\" , a , b , c ); num ++ ; if ( num % 9 == 0 ){ printf ( \"| \\n \" ); } } } } } } int main (){ printf ( \"\u25a0 measureTime_start--------------- \\n\\n \" ); time_m timem ; sstd :: measureTime_start ( timem ); // calculate divisors of 2^32-1. // std::vector<uint64> divs32 = sstd::divisor(4294967296-1); // Below line returns the same result of this line, but took a little time to run everytime and takes a little heavy memory (about 2 GByte). // std::vector<uint64> divs32 = {1, 3, 5, 15, 17, 51, 85, 255, 257, 771, 1285, 3855, 4369, 13107, 21845, 65535, 65537, 196611, 327685, 983055, 1114129, 3342387, 5570645, 16711935, 16843009, 50529027, 84215045, 252645135, 286331153, 858993459, 1431655765, 4294967295}; std :: vector < uint64 > divs32 = { 1ull * 5ull * 17ull * 257ull * 65537ull , 3ull * 1ull * 17ull * 257ull * 65537ull , 3ull * 5ull * 1ull * 257ull * 65537ull , 3ull * 5ull * 17ull * 1ull * 65537ull , 3ull * 5ull * 17ull * 257ull * 1ull , 3ull * 5ull * 17ull * 257ull * 65537ull }; printf ( \"\u25a1 calculate LRL 32bits \\n \" ); T_LRL ( divs32 , 32 ); printf ( \" \\n \" ); printf ( \" \\n \u25a0 measureTime_stop---------------- \\n \" ); sstd :: measureTime_stop_print ( timem ); return 0 ; } Execution result \u25a0 measureTime_start--------------- \u25a1 calculate LRL 32bits a, b, c | 1, 3, 10| 1, 5, 16| 1, 5, 19| 1, 9, 29| 1, 11, 6| 1, 11, 16| 1, 19, 3| 1, 21, 20| 1, 27, 27| | 2, 5, 15| 2, 5, 21| 2, 7, 7| 2, 7, 9| 2, 7, 25| 2, 9, 15| 2, 15, 17| 2, 15, 25| 2, 21, 9| | 3, 1, 14| 3, 3, 26| 3, 3, 28| 3, 3, 29| 3, 5, 20| 3, 5, 22| 3, 5, 25| 3, 7, 29| 3, 13, 7| | 3, 23, 25| 3, 25, 24| 3, 27, 11| 4, 3, 17| 4, 3, 27| 4, 5, 15| 5, 3, 21| 5, 7, 22| 5, 9, 7| | 5, 9, 28| 5, 9, 31| 5, 13, 6| 5, 15, 17| 5, 17, 13| 5, 21, 12| 5, 27, 8| 5, 27, 21| 5, 27, 25| | 5, 27, 28| 6, 1, 11| 6, 3, 17| 6, 17, 9| 6, 21, 7| 6, 21, 13| 7, 1, 9| 7, 1, 18| 7, 1, 25| | 7, 13, 25| 7, 17, 21| 7, 25, 12| 7, 25, 20| 8, 7, 23| 8, 9, 23| 9, 5, 14| 9, 5, 25| 9, 11, 19| | 9, 21, 16|10, 9, 21|10, 9, 25|11, 7, 12|11, 7, 16|11, 17, 13|11, 21, 13|12, 9, 23|13, 3, 17| |13, 3, 27|13, 5, 19|13, 17, 15|14, 1, 15|14, 13, 15|15, 1, 29|17, 15, 20|17, 15, 23|17, 15, 26| \u25a0 measureTime_stop---------------- -------------------------------- Execution time: 2. 941 sec --------------------------------","title":"Usage"},{"location":"src/matrix/bmat.html#implementation","text":"Source: sstd/src/matrixContainer_binary/bmat.cpp Header: sstd/src/matrixContainer_binary/bmat.hpp Test: test/bmat.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/matrix/mat_colMajor.html","text":"mat_c (Col-major) Abstract mat_c is a column-major matrix container. mat_c \u306f\u5217\u512a\u5148\u306e\u884c\u5217\u30b3\u30f3\u30c6\u30ca\u3067\u3059. Header file namespace sstd { template < typename T > class mat_c ; template < typename T > void copy ( sstd :: mat_c < T >& lhs , const sstd :: mat_c < T >& rhs ); template < typename T > void move ( sstd :: mat_c < T >& lhs , sstd :: mat_c < T >& rhs ); template < typename T > void swap ( sstd :: mat_c < T >& lhs , sstd :: mat_c < T >& rhs ); template < typename T > void eye ( sstd :: mat_c < T >& rhs ); template < typename T > void ones ( sstd :: mat_c < T >& rhs ); template < typename T > void zeros ( sstd :: mat_c < T >& Mat ); template < typename T > sstd :: mat_c < T > Tr ( const sstd :: mat_c < T >& rhs ); // lhs = Transpose(rhs) template < typename T > void Tr_myself ( sstd :: mat_c < T >& rhs ); // Transpose(rhs) } template < typename T > class sstd :: mat_c { private : T * _pMatT ; uint _rows ; // row size uint _cols ; // column size uint _size ; // number of element public : inline mat_c (); inline mat_c ( const std :: initializer_list < std :: initializer_list < T >>& rhs ); // called by \"sstd::mat_c<T> mat = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\". inline mat_c ( const class mat_c & rhs ); // called by \"sstd::mat_c<T> buf1(N, N); sstd::mat_c<T> buf2(buf1);\" inline mat_c ( class mat_c && rhs ); // called by \"return std::move(rhs);\" or \"std::swap(buf1, buf2)\". inline mat_c ( const uint & rowSize , const uint & colSize ); inline ~ mat_c (); // Read only: R inline const uint rows () const ; inline const uint cols () const ; inline const uint size () const ; // Read and Write: RW inline T *& pMatT_RW (); inline uint & rows_RW (); inline uint & cols_RW (); inline uint & size_RW (); class mat_c & operator = ( const class mat_c & rhs ); // called by \"lhs = sstd::mat_c<T>(3, 3);\". inline T & operator []( const uint i ); inline T & operator []( const int i ); inline const T & operator []( const uint i ) const ; inline const T & operator []( const int i ) const ; inline T & operator ()( const uint p , const uint q ); inline T & operator ()( const int p , const uint q ); inline T & operator ()( const uint p , const int q ); inline T & operator ()( const int p , const int q ); inline const T & operator ()( const uint p , const uint q ) const ; inline const T & operator ()( const int p , const uint q ) const ; inline const T & operator ()( const uint p , const int q ) const ; inline const T & operator ()( const int p , const int q ) const ; // for element operations (elements multiplication) inline sstd :: mat_c_elements < T > operator ()(); inline sstd :: mat_c_elements < T > vec (); }; Usage Init main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m = {{ 1 , 2 }, { 3 , 4 }}; sstd :: mat_c < double > m_eye ( 2 , 2 ); sstd :: eye ( m_eye ); sstd :: mat_c < double > m_ones ( 2 , 2 ); sstd :: ones ( m_ones ); sstd :: mat_c < double > m_zeros ( 2 , 2 ); sstd :: zeros ( m_zeros ); sstd :: printn ( m ); printf ( \" \\n \" ); sstd :: printn ( m_eye ); printf ( \" \\n \" ); sstd :: printn ( m_ones ); printf ( \" \\n \" ); sstd :: printn ( m_zeros ); } Execution result m = 1.000000 2.000000 3.000000 4.000000 m_eye = 1.000000 0.000000 0.000000 1.000000 m_ones = 1.000000 1.000000 1.000000 1.000000 m_zeros = 0.000000 0.000000 0.000000 0.000000 Access to elements As a matrix main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m ( 2 , 2 ); uint i = 0 ; for ( uint c = 0 ; c < m . cols (); ++ c ){ for ( uint r = 0 ; r < m . rows (); ++ r ){ m ( r , c ) = i ; ++ i ; } } sstd :: printn ( m ); } Execution result m = 0.000000 2.000000 1.000000 3.000000 As a vector main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m ( 2 , 2 ); for ( uint i = 0 ; i < m . size (); ++ i ){ m [ i ] = i ; } sstd :: printn ( m ); } Execution result m = 0.000000 2.000000 1.000000 3.000000 Tr (Transpose) main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m1 = {{ 1 , 2 }, { 3 , 4 }}; sstd :: printn ( m1 ); sstd :: printn ( sstd :: Tr ( m1 ) ); printf ( \" \\n \" ); sstd :: mat_c < double > m2 = {{ 1 , 2 }, { 3 , 4 }}; sstd :: printn ( m2 ); sstd :: Tr_myself ( m2 ); sstd :: printn ( m2 ); } Execution result m1 = 1.000000 2.000000 3.000000 4.000000 sstd::Tr( m1 ) = 1.000000 3.000000 2.000000 4.000000 m2 = 1.000000 2.000000 3.000000 4.000000 m2 = 1.000000 3.000000 2.000000 4.000000 Operator matrix \u00d7 scalar main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m ( 2 , 2 ); for ( uint i = 0 ; i < m . size (); ++ i ){ m [ i ] = i ; } sstd :: printn ( m ); printf ( \" \\n \" ); sstd :: printn ( m * 2 ); } Execution result m = 0.000000 2.000000 1.000000 3.000000 m * 2 = 0.000000 4.000000 2.000000 6.000000 matrix \u00d7 matrix main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m1 ( 2 , 2 ); for ( uint i = 0 ; i < m1 . size (); ++ i ){ m1 [ i ] = i ; } sstd :: mat_c < double > m2 ( 2 , 2 ); for ( uint i = 0 ; i < m2 . size (); ++ i ){ m2 [ i ] = i + 1 ; } sstd :: printn ( m1 ); printf ( \" \\n \" ); sstd :: printn ( m2 ); printf ( \" \\n \" ); sstd :: printn ( m1 * m2 ); } Execution result m1 = 0.000000 2.000000 1.000000 3.000000 m2 = 1.000000 3.000000 2.000000 4.000000 m1 * m2 = 4.000000 8.000000 7.000000 15.000000 matrix (as a vector) \u00d7 matrix (as a vector) main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m1 ( 2 , 2 ); for ( uint i = 0 ; i < m1 . size (); ++ i ){ m1 [ i ] = i ; } sstd :: mat_c < double > m2 ( 2 , 2 ); for ( uint i = 0 ; i < m2 . size (); ++ i ){ m2 [ i ] = i + 1 ; } sstd :: printn ( m1 ); printf ( \" \\n \" ); sstd :: printn ( m2 ); printf ( \" \\n \" ); sstd :: printn ( m1 () * m2 () ); } Execution result m1 = 0.000000 2.000000 1.000000 3.000000 m2 = 1.000000 3.000000 2.000000 4.000000 m1() * m2() = 0.000000 6.000000 2.000000 12.000000 Implementation Source: sstd/src/matrixContainer_rowMajor/mat_c.cpp Header: sstd/src/matrixContainer_rowMajor/mat_c.hpp Test: test/mat_c.hpp (Not implemented yet)","title":"mat_c (Col-major)"},{"location":"src/matrix/mat_colMajor.html#mat_c-col-major","text":"","title":"mat_c (Col-major)"},{"location":"src/matrix/mat_colMajor.html#abstract","text":"mat_c is a column-major matrix container. mat_c \u306f\u5217\u512a\u5148\u306e\u884c\u5217\u30b3\u30f3\u30c6\u30ca\u3067\u3059.","title":"Abstract"},{"location":"src/matrix/mat_colMajor.html#header-file","text":"namespace sstd { template < typename T > class mat_c ; template < typename T > void copy ( sstd :: mat_c < T >& lhs , const sstd :: mat_c < T >& rhs ); template < typename T > void move ( sstd :: mat_c < T >& lhs , sstd :: mat_c < T >& rhs ); template < typename T > void swap ( sstd :: mat_c < T >& lhs , sstd :: mat_c < T >& rhs ); template < typename T > void eye ( sstd :: mat_c < T >& rhs ); template < typename T > void ones ( sstd :: mat_c < T >& rhs ); template < typename T > void zeros ( sstd :: mat_c < T >& Mat ); template < typename T > sstd :: mat_c < T > Tr ( const sstd :: mat_c < T >& rhs ); // lhs = Transpose(rhs) template < typename T > void Tr_myself ( sstd :: mat_c < T >& rhs ); // Transpose(rhs) } template < typename T > class sstd :: mat_c { private : T * _pMatT ; uint _rows ; // row size uint _cols ; // column size uint _size ; // number of element public : inline mat_c (); inline mat_c ( const std :: initializer_list < std :: initializer_list < T >>& rhs ); // called by \"sstd::mat_c<T> mat = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\". inline mat_c ( const class mat_c & rhs ); // called by \"sstd::mat_c<T> buf1(N, N); sstd::mat_c<T> buf2(buf1);\" inline mat_c ( class mat_c && rhs ); // called by \"return std::move(rhs);\" or \"std::swap(buf1, buf2)\". inline mat_c ( const uint & rowSize , const uint & colSize ); inline ~ mat_c (); // Read only: R inline const uint rows () const ; inline const uint cols () const ; inline const uint size () const ; // Read and Write: RW inline T *& pMatT_RW (); inline uint & rows_RW (); inline uint & cols_RW (); inline uint & size_RW (); class mat_c & operator = ( const class mat_c & rhs ); // called by \"lhs = sstd::mat_c<T>(3, 3);\". inline T & operator []( const uint i ); inline T & operator []( const int i ); inline const T & operator []( const uint i ) const ; inline const T & operator []( const int i ) const ; inline T & operator ()( const uint p , const uint q ); inline T & operator ()( const int p , const uint q ); inline T & operator ()( const uint p , const int q ); inline T & operator ()( const int p , const int q ); inline const T & operator ()( const uint p , const uint q ) const ; inline const T & operator ()( const int p , const uint q ) const ; inline const T & operator ()( const uint p , const int q ) const ; inline const T & operator ()( const int p , const int q ) const ; // for element operations (elements multiplication) inline sstd :: mat_c_elements < T > operator ()(); inline sstd :: mat_c_elements < T > vec (); };","title":"Header file"},{"location":"src/matrix/mat_colMajor.html#usage","text":"","title":"Usage"},{"location":"src/matrix/mat_colMajor.html#init","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m = {{ 1 , 2 }, { 3 , 4 }}; sstd :: mat_c < double > m_eye ( 2 , 2 ); sstd :: eye ( m_eye ); sstd :: mat_c < double > m_ones ( 2 , 2 ); sstd :: ones ( m_ones ); sstd :: mat_c < double > m_zeros ( 2 , 2 ); sstd :: zeros ( m_zeros ); sstd :: printn ( m ); printf ( \" \\n \" ); sstd :: printn ( m_eye ); printf ( \" \\n \" ); sstd :: printn ( m_ones ); printf ( \" \\n \" ); sstd :: printn ( m_zeros ); } Execution result m = 1.000000 2.000000 3.000000 4.000000 m_eye = 1.000000 0.000000 0.000000 1.000000 m_ones = 1.000000 1.000000 1.000000 1.000000 m_zeros = 0.000000 0.000000 0.000000 0.000000","title":"Init"},{"location":"src/matrix/mat_colMajor.html#access-to-elements","text":"","title":"Access to elements"},{"location":"src/matrix/mat_colMajor.html#as-a-matrix","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m ( 2 , 2 ); uint i = 0 ; for ( uint c = 0 ; c < m . cols (); ++ c ){ for ( uint r = 0 ; r < m . rows (); ++ r ){ m ( r , c ) = i ; ++ i ; } } sstd :: printn ( m ); } Execution result m = 0.000000 2.000000 1.000000 3.000000","title":"As a matrix"},{"location":"src/matrix/mat_colMajor.html#as-a-vector","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m ( 2 , 2 ); for ( uint i = 0 ; i < m . size (); ++ i ){ m [ i ] = i ; } sstd :: printn ( m ); } Execution result m = 0.000000 2.000000 1.000000 3.000000","title":"As a vector"},{"location":"src/matrix/mat_colMajor.html#tr-transpose","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m1 = {{ 1 , 2 }, { 3 , 4 }}; sstd :: printn ( m1 ); sstd :: printn ( sstd :: Tr ( m1 ) ); printf ( \" \\n \" ); sstd :: mat_c < double > m2 = {{ 1 , 2 }, { 3 , 4 }}; sstd :: printn ( m2 ); sstd :: Tr_myself ( m2 ); sstd :: printn ( m2 ); } Execution result m1 = 1.000000 2.000000 3.000000 4.000000 sstd::Tr( m1 ) = 1.000000 3.000000 2.000000 4.000000 m2 = 1.000000 2.000000 3.000000 4.000000 m2 = 1.000000 3.000000 2.000000 4.000000","title":"Tr (Transpose)"},{"location":"src/matrix/mat_colMajor.html#operator","text":"","title":"Operator"},{"location":"src/matrix/mat_colMajor.html#matrix-scalar","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m ( 2 , 2 ); for ( uint i = 0 ; i < m . size (); ++ i ){ m [ i ] = i ; } sstd :: printn ( m ); printf ( \" \\n \" ); sstd :: printn ( m * 2 ); } Execution result m = 0.000000 2.000000 1.000000 3.000000 m * 2 = 0.000000 4.000000 2.000000 6.000000","title":"matrix \u00d7 scalar"},{"location":"src/matrix/mat_colMajor.html#matrix-matrix","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m1 ( 2 , 2 ); for ( uint i = 0 ; i < m1 . size (); ++ i ){ m1 [ i ] = i ; } sstd :: mat_c < double > m2 ( 2 , 2 ); for ( uint i = 0 ; i < m2 . size (); ++ i ){ m2 [ i ] = i + 1 ; } sstd :: printn ( m1 ); printf ( \" \\n \" ); sstd :: printn ( m2 ); printf ( \" \\n \" ); sstd :: printn ( m1 * m2 ); } Execution result m1 = 0.000000 2.000000 1.000000 3.000000 m2 = 1.000000 3.000000 2.000000 4.000000 m1 * m2 = 4.000000 8.000000 7.000000 15.000000","title":"matrix \u00d7 matrix"},{"location":"src/matrix/mat_colMajor.html#matrix-as-a-vector-matrix-as-a-vector","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m1 ( 2 , 2 ); for ( uint i = 0 ; i < m1 . size (); ++ i ){ m1 [ i ] = i ; } sstd :: mat_c < double > m2 ( 2 , 2 ); for ( uint i = 0 ; i < m2 . size (); ++ i ){ m2 [ i ] = i + 1 ; } sstd :: printn ( m1 ); printf ( \" \\n \" ); sstd :: printn ( m2 ); printf ( \" \\n \" ); sstd :: printn ( m1 () * m2 () ); } Execution result m1 = 0.000000 2.000000 1.000000 3.000000 m2 = 1.000000 3.000000 2.000000 4.000000 m1() * m2() = 0.000000 6.000000 2.000000 12.000000","title":"matrix (as a vector) \u00d7 matrix (as a vector)"},{"location":"src/matrix/mat_colMajor.html#implementation","text":"Source: sstd/src/matrixContainer_rowMajor/mat_c.cpp Header: sstd/src/matrixContainer_rowMajor/mat_c.hpp Test: test/mat_c.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/matrix/mat_rowMajor.html","text":"mat_r (Row-major) Abstract mat_r is a row-major matrix container. mat_r \u306f\u884c\u512a\u5148\u306e\u884c\u5217\u30b3\u30f3\u30c6\u30ca\u3067\u3059. Header file namespace sstd { template < typename T > class mat_r ; template < typename T > void copy ( sstd :: mat_r < T >& lhs , const sstd :: mat_r < T >& rhs ); template < typename T > void move ( sstd :: mat_r < T >& lhs , sstd :: mat_r < T >& rhs ); template < typename T > void swap ( sstd :: mat_r < T >& lhs , sstd :: mat_r < T >& rhs ); template < typename T > void eye ( sstd :: mat_r < T >& rhs ); template < typename T > void ones ( sstd :: mat_r < T >& rhs ); template < typename T > void zeros ( sstd :: mat_r < T >& Mat ); template < typename T > sstd :: mat_r < T > Tr ( const sstd :: mat_r < T >& rhs ); // lhs = Transpose(rhs) template < typename T > void Tr_myself ( sstd :: mat_r < T >& rhs ); // Transpose(rhs) } template < typename T > class sstd :: mat_r { private : T * _pMatT ; uint _rows ; // row size uint _cols ; // column size uint _size ; // number of element public : inline mat_r (); inline mat_r ( const std :: initializer_list < std :: initializer_list < T >>& rhs ); // called by \"sstd::mat_r<T> mat = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\". inline mat_r ( const class mat_r & rhs ); // called by \"sstd::mat_r<T> buf1(N, N); sstd::mat_r<T> buf2(buf1);\" inline mat_r ( class mat_r && rhs ); // called by \"return std::move(rhs);\" or \"std::swap(buf1, buf2)\". inline mat_r ( const uint & rowSize , const uint & colSize ); inline ~ mat_r (); // Read only: R inline const uint rows () const ; inline const uint cols () const ; inline const uint size () const ; // Read and Write: RW inline T *& pMatT_RW (); inline uint & rows_RW (); inline uint & cols_RW (); inline uint & size_RW (); class mat_r & operator = ( const class mat_r & rhs ); // called by \"lhs = sstd::mat_r<T>(3, 3);\". inline T & operator []( const uint i ); inline T & operator []( const int i ); inline const T & operator []( const uint i ) const ; inline const T & operator []( const int i ) const ; inline T & operator ()( const uint p , const uint q ); inline T & operator ()( const int p , const uint q ); inline T & operator ()( const uint p , const int q ); inline T & operator ()( const int p , const int q ); inline const T & operator ()( const uint p , const uint q ) const ; inline const T & operator ()( const int p , const uint q ) const ; inline const T & operator ()( const uint p , const int q ) const ; inline const T & operator ()( const int p , const int q ) const ; // for element operations (elements multiplication) inline sstd :: mat_r_elements < T > operator ()(); inline sstd :: mat_r_elements < T > vec (); }; Usage Init main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m = {{ 1 , 2 }, { 3 , 4 }}; sstd :: mat_r < double > m_eye ( 2 , 2 ); sstd :: eye ( m_eye ); sstd :: mat_r < double > m_ones ( 2 , 2 ); sstd :: ones ( m_ones ); sstd :: mat_r < double > m_zeros ( 2 , 2 ); sstd :: zeros ( m_zeros ); sstd :: printn ( m ); printf ( \" \\n \" ); sstd :: printn ( m_eye ); printf ( \" \\n \" ); sstd :: printn ( m_ones ); printf ( \" \\n \" ); sstd :: printn ( m_zeros ); } Execution result m = 1.000000 2.000000 3.000000 4.000000 m_eye = 1.000000 0.000000 0.000000 1.000000 m_ones = 1.000000 1.000000 1.000000 1.000000 m_zeros = 0.000000 0.000000 0.000000 0.000000 Access to elements As a matrix main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m ( 2 , 2 ); uint i = 0 ; for ( uint r = 0 ; r < m . rows (); ++ r ){ for ( uint c = 0 ; c < m . cols (); ++ c ){ m ( r , c ) = i ; ++ i ; } } sstd :: printn ( m ); } Execution result m = 0.000000 1.000000 2.000000 3.000000 As a vector main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m ( 2 , 2 ); for ( uint i = 0 ; i < m . size (); ++ i ){ m [ i ] = i ; } sstd :: printn ( m ); } Execution result m = 0.000000 1.000000 2.000000 3.000000 Tr (Transpose) main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m1 = {{ 1 , 2 }, { 3 , 4 }}; sstd :: printn ( m1 ); sstd :: printn ( sstd :: Tr ( m1 ) ); printf ( \" \\n \" ); sstd :: mat_r < double > m2 = {{ 1 , 2 }, { 3 , 4 }}; sstd :: printn ( m2 ); sstd :: Tr_myself ( m2 ); sstd :: printn ( m2 ); } Execution result m1 = 1.000000 2.000000 3.000000 4.000000 sstd::Tr( m1 ) = 1.000000 3.000000 2.000000 4.000000 m2 = 1.000000 2.000000 3.000000 4.000000 m2 = 1.000000 3.000000 2.000000 4.000000 Operator matrix \u00d7 scalar main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m ( 2 , 2 ); for ( uint i = 0 ; i < m . size (); ++ i ){ m [ i ] = i ; } sstd :: printn ( m ); printf ( \" \\n \" ); sstd :: printn ( m * 2 ); } Execution result m = 0.000000 1.000000 2.000000 3.000000 m * 2 = 0.000000 2.000000 4.000000 6.000000 matrix \u00d7 matrix main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m1 ( 2 , 2 ); for ( uint i = 0 ; i < m1 . size (); ++ i ){ m1 [ i ] = i ; } sstd :: mat_r < double > m2 ( 2 , 2 ); for ( uint i = 0 ; i < m2 . size (); ++ i ){ m2 [ i ] = i + 1 ; } sstd :: printn ( m1 ); printf ( \" \\n \" ); sstd :: printn ( m2 ); printf ( \" \\n \" ); sstd :: printn ( m1 * m2 ); } Execution result m1 = 0.000000 1.000000 2.000000 3.000000 m2 = 1.000000 2.000000 3.000000 4.000000 m1 * m2 = 3.000000 4.000000 11.000000 16.000000 matrix (as a vector) \u00d7 matrix (as a vector) main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m1 ( 2 , 2 ); for ( uint i = 0 ; i < m1 . size (); ++ i ){ m1 [ i ] = i ; } sstd :: mat_r < double > m2 ( 2 , 2 ); for ( uint i = 0 ; i < m2 . size (); ++ i ){ m2 [ i ] = i + 1 ; } sstd :: printn ( m1 ); printf ( \" \\n \" ); sstd :: printn ( m2 ); printf ( \" \\n \" ); sstd :: printn ( m1 () * m2 () ); } Execution result m1 = 0.000000 1.000000 2.000000 3.000000 m2 = 1.000000 2.000000 3.000000 4.000000 m1() * m2() = 0.000000 2.000000 6.000000 12.000000 Implementation Source: sstd/src/matrixContainer_rowMajor/mat_r.cpp Header: sstd/src/matrixContainer_rowMajor/mat_r.hpp Test: test/mat_r.hpp (Not implemented yet)","title":"mat_r (Row-major)"},{"location":"src/matrix/mat_rowMajor.html#mat_r-row-major","text":"","title":"mat_r (Row-major)"},{"location":"src/matrix/mat_rowMajor.html#abstract","text":"mat_r is a row-major matrix container. mat_r \u306f\u884c\u512a\u5148\u306e\u884c\u5217\u30b3\u30f3\u30c6\u30ca\u3067\u3059.","title":"Abstract"},{"location":"src/matrix/mat_rowMajor.html#header-file","text":"namespace sstd { template < typename T > class mat_r ; template < typename T > void copy ( sstd :: mat_r < T >& lhs , const sstd :: mat_r < T >& rhs ); template < typename T > void move ( sstd :: mat_r < T >& lhs , sstd :: mat_r < T >& rhs ); template < typename T > void swap ( sstd :: mat_r < T >& lhs , sstd :: mat_r < T >& rhs ); template < typename T > void eye ( sstd :: mat_r < T >& rhs ); template < typename T > void ones ( sstd :: mat_r < T >& rhs ); template < typename T > void zeros ( sstd :: mat_r < T >& Mat ); template < typename T > sstd :: mat_r < T > Tr ( const sstd :: mat_r < T >& rhs ); // lhs = Transpose(rhs) template < typename T > void Tr_myself ( sstd :: mat_r < T >& rhs ); // Transpose(rhs) } template < typename T > class sstd :: mat_r { private : T * _pMatT ; uint _rows ; // row size uint _cols ; // column size uint _size ; // number of element public : inline mat_r (); inline mat_r ( const std :: initializer_list < std :: initializer_list < T >>& rhs ); // called by \"sstd::mat_r<T> mat = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\". inline mat_r ( const class mat_r & rhs ); // called by \"sstd::mat_r<T> buf1(N, N); sstd::mat_r<T> buf2(buf1);\" inline mat_r ( class mat_r && rhs ); // called by \"return std::move(rhs);\" or \"std::swap(buf1, buf2)\". inline mat_r ( const uint & rowSize , const uint & colSize ); inline ~ mat_r (); // Read only: R inline const uint rows () const ; inline const uint cols () const ; inline const uint size () const ; // Read and Write: RW inline T *& pMatT_RW (); inline uint & rows_RW (); inline uint & cols_RW (); inline uint & size_RW (); class mat_r & operator = ( const class mat_r & rhs ); // called by \"lhs = sstd::mat_r<T>(3, 3);\". inline T & operator []( const uint i ); inline T & operator []( const int i ); inline const T & operator []( const uint i ) const ; inline const T & operator []( const int i ) const ; inline T & operator ()( const uint p , const uint q ); inline T & operator ()( const int p , const uint q ); inline T & operator ()( const uint p , const int q ); inline T & operator ()( const int p , const int q ); inline const T & operator ()( const uint p , const uint q ) const ; inline const T & operator ()( const int p , const uint q ) const ; inline const T & operator ()( const uint p , const int q ) const ; inline const T & operator ()( const int p , const int q ) const ; // for element operations (elements multiplication) inline sstd :: mat_r_elements < T > operator ()(); inline sstd :: mat_r_elements < T > vec (); };","title":"Header file"},{"location":"src/matrix/mat_rowMajor.html#usage","text":"","title":"Usage"},{"location":"src/matrix/mat_rowMajor.html#init","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m = {{ 1 , 2 }, { 3 , 4 }}; sstd :: mat_r < double > m_eye ( 2 , 2 ); sstd :: eye ( m_eye ); sstd :: mat_r < double > m_ones ( 2 , 2 ); sstd :: ones ( m_ones ); sstd :: mat_r < double > m_zeros ( 2 , 2 ); sstd :: zeros ( m_zeros ); sstd :: printn ( m ); printf ( \" \\n \" ); sstd :: printn ( m_eye ); printf ( \" \\n \" ); sstd :: printn ( m_ones ); printf ( \" \\n \" ); sstd :: printn ( m_zeros ); } Execution result m = 1.000000 2.000000 3.000000 4.000000 m_eye = 1.000000 0.000000 0.000000 1.000000 m_ones = 1.000000 1.000000 1.000000 1.000000 m_zeros = 0.000000 0.000000 0.000000 0.000000","title":"Init"},{"location":"src/matrix/mat_rowMajor.html#access-to-elements","text":"","title":"Access to elements"},{"location":"src/matrix/mat_rowMajor.html#as-a-matrix","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m ( 2 , 2 ); uint i = 0 ; for ( uint r = 0 ; r < m . rows (); ++ r ){ for ( uint c = 0 ; c < m . cols (); ++ c ){ m ( r , c ) = i ; ++ i ; } } sstd :: printn ( m ); } Execution result m = 0.000000 1.000000 2.000000 3.000000","title":"As a matrix"},{"location":"src/matrix/mat_rowMajor.html#as-a-vector","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m ( 2 , 2 ); for ( uint i = 0 ; i < m . size (); ++ i ){ m [ i ] = i ; } sstd :: printn ( m ); } Execution result m = 0.000000 1.000000 2.000000 3.000000","title":"As a vector"},{"location":"src/matrix/mat_rowMajor.html#tr-transpose","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m1 = {{ 1 , 2 }, { 3 , 4 }}; sstd :: printn ( m1 ); sstd :: printn ( sstd :: Tr ( m1 ) ); printf ( \" \\n \" ); sstd :: mat_r < double > m2 = {{ 1 , 2 }, { 3 , 4 }}; sstd :: printn ( m2 ); sstd :: Tr_myself ( m2 ); sstd :: printn ( m2 ); } Execution result m1 = 1.000000 2.000000 3.000000 4.000000 sstd::Tr( m1 ) = 1.000000 3.000000 2.000000 4.000000 m2 = 1.000000 2.000000 3.000000 4.000000 m2 = 1.000000 3.000000 2.000000 4.000000","title":"Tr (Transpose)"},{"location":"src/matrix/mat_rowMajor.html#operator","text":"","title":"Operator"},{"location":"src/matrix/mat_rowMajor.html#matrix-scalar","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m ( 2 , 2 ); for ( uint i = 0 ; i < m . size (); ++ i ){ m [ i ] = i ; } sstd :: printn ( m ); printf ( \" \\n \" ); sstd :: printn ( m * 2 ); } Execution result m = 0.000000 1.000000 2.000000 3.000000 m * 2 = 0.000000 2.000000 4.000000 6.000000","title":"matrix \u00d7 scalar"},{"location":"src/matrix/mat_rowMajor.html#matrix-matrix","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m1 ( 2 , 2 ); for ( uint i = 0 ; i < m1 . size (); ++ i ){ m1 [ i ] = i ; } sstd :: mat_r < double > m2 ( 2 , 2 ); for ( uint i = 0 ; i < m2 . size (); ++ i ){ m2 [ i ] = i + 1 ; } sstd :: printn ( m1 ); printf ( \" \\n \" ); sstd :: printn ( m2 ); printf ( \" \\n \" ); sstd :: printn ( m1 * m2 ); } Execution result m1 = 0.000000 1.000000 2.000000 3.000000 m2 = 1.000000 2.000000 3.000000 4.000000 m1 * m2 = 3.000000 4.000000 11.000000 16.000000","title":"matrix \u00d7 matrix"},{"location":"src/matrix/mat_rowMajor.html#matrix-as-a-vector-matrix-as-a-vector","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m1 ( 2 , 2 ); for ( uint i = 0 ; i < m1 . size (); ++ i ){ m1 [ i ] = i ; } sstd :: mat_r < double > m2 ( 2 , 2 ); for ( uint i = 0 ; i < m2 . size (); ++ i ){ m2 [ i ] = i + 1 ; } sstd :: printn ( m1 ); printf ( \" \\n \" ); sstd :: printn ( m2 ); printf ( \" \\n \" ); sstd :: printn ( m1 () * m2 () ); } Execution result m1 = 0.000000 1.000000 2.000000 3.000000 m2 = 1.000000 2.000000 3.000000 4.000000 m1() * m2() = 0.000000 2.000000 6.000000 12.000000","title":"matrix (as a vector) \u00d7 matrix (as a vector)"},{"location":"src/matrix/mat_rowMajor.html#implementation","text":"Source: sstd/src/matrixContainer_rowMajor/mat_r.cpp Header: sstd/src/matrixContainer_rowMajor/mat_r.hpp Test: test/mat_r.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/stdlib/system.html","text":"system Abstract system() executes the specified command. system() \u306f\u6307\u5b9a\u3055\u308c\u305f\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3057\u307e\u3059\uff0e Header file namespace sstd { int system ( const char * cmd ); int system ( const std :: string & cmd ); std :: string system_stdout ( const char * cmd ); std :: string system_stdout ( const std :: string & cmd ); std :: string system_stderr ( const char * cmd ); std :: string system_stderr ( const std :: string & cmd ); std :: string system_stdout_stderr ( const char * cmd ); std :: string system_stdout_stderr ( const std :: string & cmd ); } Usage system main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: system ( \"mkdir -p ./tmp/a/b/c\" ); sstd :: system ( \"tree ./tmp\" ); } Execution result sh: tree: not found system_stdout_stderr Acquires the stdout and stderr that accompany the execution result. \u5b9f\u884c\u7d50\u679c\u306b\u4f34\u3046\u6a19\u6e96\u51fa\u529b\u3068\u6a19\u6e96\u30a8\u30e9\u30fc\u51fa\u529b\u3092\u53d6\u5f97\u3057\u307e\u3059\uff0e main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: system ( \"touch hello\" ); sstd :: system ( \"touch system_stdout_stderr\" ); std :: string s = sstd :: system_stdout_stderr ( \"ls\" ); sstd :: printn ( s ); } Execution result s = \"hello sstd system_stdout_stderr \" Implementation Source: sstd/src/stdlib.cpp Header: sstd/src/stdlib.hpp Test: test/stdlib.hpp","title":"system"},{"location":"src/stdlib/system.html#system","text":"","title":"system"},{"location":"src/stdlib/system.html#abstract","text":"system() executes the specified command. system() \u306f\u6307\u5b9a\u3055\u308c\u305f\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/stdlib/system.html#header-file","text":"namespace sstd { int system ( const char * cmd ); int system ( const std :: string & cmd ); std :: string system_stdout ( const char * cmd ); std :: string system_stdout ( const std :: string & cmd ); std :: string system_stderr ( const char * cmd ); std :: string system_stderr ( const std :: string & cmd ); std :: string system_stdout_stderr ( const char * cmd ); std :: string system_stdout_stderr ( const std :: string & cmd ); }","title":"Header file"},{"location":"src/stdlib/system.html#usage","text":"","title":"Usage"},{"location":"src/stdlib/system.html#system_1","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: system ( \"mkdir -p ./tmp/a/b/c\" ); sstd :: system ( \"tree ./tmp\" ); } Execution result sh: tree: not found","title":"system"},{"location":"src/stdlib/system.html#system_stdout_stderr","text":"Acquires the stdout and stderr that accompany the execution result. \u5b9f\u884c\u7d50\u679c\u306b\u4f34\u3046\u6a19\u6e96\u51fa\u529b\u3068\u6a19\u6e96\u30a8\u30e9\u30fc\u51fa\u529b\u3092\u53d6\u5f97\u3057\u307e\u3059\uff0e main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: system ( \"touch hello\" ); sstd :: system ( \"touch system_stdout_stderr\" ); std :: string s = sstd :: system_stdout_stderr ( \"ls\" ); sstd :: printn ( s ); } Execution result s = \"hello sstd system_stdout_stderr \"","title":"system_stdout_stderr"},{"location":"src/stdlib/system.html#implementation","text":"Source: sstd/src/stdlib.cpp Header: sstd/src/stdlib.hpp Test: test/stdlib.hpp","title":"Implementation"},{"location":"src/string/ssprintf.html","text":"ssprintf Abstract ssprintf() is the std::string version of sprintf() . ssprintf() \u306f\uff0c sprintf() \u306e std::string \u7248\u3067\u3059\uff0e Header file namespace sstd { std :: string ssprintf ( const char * format , ...); } Usage main.cpp #include <sstd/sstd.hpp> int main (){ std :: string s = sstd :: ssprintf ( \"%s %d%d%d %03d\" , \"ABC\" , 0 , 1 , 2 , 3 ); sstd :: printn ( s ); } Execution result s = \"ABC 012 003\" Implementation Source: sstd/src/ssprintf.cpp Header: sstd/src/ssprintf.hpp Test: test/ssprintf.hpp (Not implemented yet)","title":"ssprintf"},{"location":"src/string/ssprintf.html#ssprintf","text":"","title":"ssprintf"},{"location":"src/string/ssprintf.html#abstract","text":"ssprintf() is the std::string version of sprintf() . ssprintf() \u306f\uff0c sprintf() \u306e std::string \u7248\u3067\u3059\uff0e","title":"Abstract"},{"location":"src/string/ssprintf.html#header-file","text":"namespace sstd { std :: string ssprintf ( const char * format , ...); }","title":"Header file"},{"location":"src/string/ssprintf.html#usage","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: string s = sstd :: ssprintf ( \"%s %d%d%d %03d\" , \"ABC\" , 0 , 1 , 2 , 3 ); sstd :: printn ( s ); } Execution result s = \"ABC 012 003\"","title":"Usage"},{"location":"src/string/ssprintf.html#implementation","text":"Source: sstd/src/ssprintf.cpp Header: sstd/src/ssprintf.hpp Test: test/ssprintf.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/string/strEdit.html","text":"strEdit Abstract strEdit.hpp / strEdit.cpp \u306f\uff0c\u6587\u5b57\u5217\u3092\u7de8\u96c6\u3059\u308b\u305f\u3081\u306e\u95a2\u6570\u3092\u53ce\u9332\u3057\u3066\u3044\u308b\uff0e Header file namespace sstd { std :: vector < std :: string > splitByLine ( const std :: string & str ); std :: vector < std :: string > split ( const char * str , const char X ); std :: vector < std :: string > split ( const std :: string & str , const char X ); // remove space or tab. std :: string lstrip ( const char * str ); // removing head spaces std :: string lstrip ( const std :: string & str ); // removing head spaces void lstrip_ow ( std :: string & str ); // removing head spaces. ow: overwrite std :: string rstrip ( const char * str ); // removing tail spaces std :: string rstrip ( const std :: string & str ); // removing tail spaces void rstrip_ow ( std :: string & str ); // removing tail spaces. ow: overwrite std :: string strip ( const char * str ); // removing head and tail tab and spaces std :: string strip ( const std :: string & str ); // removing head and tail tab and spaces void strip_ow ( std :: string & str ); // removing head and tail tab and spaces. ow: overwrite std :: vector < std :: string > strip ( const std :: vector < std :: string >& vec ); // -> strip(str) // removing head and tail spaces } Description Removing spaces and tabs. \u7a7a\u767d (\u534a\u89d2\u30b9\u30da\u30fc\u30b9) \u3068\u30bf\u30d6\u6587\u5b57\u306e\u9664\u53bb\uff0e Function name Description lstrip() Removing head spaces and tabs. \u6587\u5b57\u5217\u306e\u5148\u982d\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e lstrip_ow() Removing head spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u5148\u982d\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e rstrip() Removing tail spaces and tabs. \u6587\u5b57\u5217\u306e\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e rstrip_ow() Removing tail spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e strip() Removing head and tail spaces and tabs. \u6587\u5b57\u5217\u306e\u5148\u982d\u3068\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e strip_ow() Removing head and tail spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u5148\u982d\u3068\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e Usage main.cpp #include <sstd/sstd.hpp> int main (){ std :: string s = \" abc \" ; sstd :: printn ( sstd :: lstrip ( s )); sstd :: printn ( sstd :: rstrip ( s )); sstd :: printn ( sstd :: strip ( s )); sstd :: strip_ow ( s ); sstd :: printn ( s ); } Execution result sstd::lstrip(s) = \"abc \" sstd::rstrip(s) = \" abc\" sstd::strip(s) = \"abc\" s = \"abc\" Implementation Source: sstd/src/vector/strEdit.cpp Header: sstd/src/vector/strEdit.hpp Test: test/strEdit.hpp","title":"strEdit"},{"location":"src/string/strEdit.html#stredit","text":"","title":"strEdit"},{"location":"src/string/strEdit.html#abstract","text":"strEdit.hpp / strEdit.cpp \u306f\uff0c\u6587\u5b57\u5217\u3092\u7de8\u96c6\u3059\u308b\u305f\u3081\u306e\u95a2\u6570\u3092\u53ce\u9332\u3057\u3066\u3044\u308b\uff0e","title":"Abstract"},{"location":"src/string/strEdit.html#header-file","text":"namespace sstd { std :: vector < std :: string > splitByLine ( const std :: string & str ); std :: vector < std :: string > split ( const char * str , const char X ); std :: vector < std :: string > split ( const std :: string & str , const char X ); // remove space or tab. std :: string lstrip ( const char * str ); // removing head spaces std :: string lstrip ( const std :: string & str ); // removing head spaces void lstrip_ow ( std :: string & str ); // removing head spaces. ow: overwrite std :: string rstrip ( const char * str ); // removing tail spaces std :: string rstrip ( const std :: string & str ); // removing tail spaces void rstrip_ow ( std :: string & str ); // removing tail spaces. ow: overwrite std :: string strip ( const char * str ); // removing head and tail tab and spaces std :: string strip ( const std :: string & str ); // removing head and tail tab and spaces void strip_ow ( std :: string & str ); // removing head and tail tab and spaces. ow: overwrite std :: vector < std :: string > strip ( const std :: vector < std :: string >& vec ); // -> strip(str) // removing head and tail spaces }","title":"Header file"},{"location":"src/string/strEdit.html#description","text":"Removing spaces and tabs. \u7a7a\u767d (\u534a\u89d2\u30b9\u30da\u30fc\u30b9) \u3068\u30bf\u30d6\u6587\u5b57\u306e\u9664\u53bb\uff0e Function name Description lstrip() Removing head spaces and tabs. \u6587\u5b57\u5217\u306e\u5148\u982d\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e lstrip_ow() Removing head spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u5148\u982d\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e rstrip() Removing tail spaces and tabs. \u6587\u5b57\u5217\u306e\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e rstrip_ow() Removing tail spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e strip() Removing head and tail spaces and tabs. \u6587\u5b57\u5217\u306e\u5148\u982d\u3068\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e strip_ow() Removing head and tail spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u5148\u982d\u3068\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e","title":"Description"},{"location":"src/string/strEdit.html#usage","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: string s = \" abc \" ; sstd :: printn ( sstd :: lstrip ( s )); sstd :: printn ( sstd :: rstrip ( s )); sstd :: printn ( sstd :: strip ( s )); sstd :: strip_ow ( s ); sstd :: printn ( s ); } Execution result sstd::lstrip(s) = \"abc \" sstd::rstrip(s) = \" abc\" sstd::strip(s) = \"abc\" s = \"abc\"","title":"Usage"},{"location":"src/string/strEdit.html#implementation","text":"Source: sstd/src/vector/strEdit.cpp Header: sstd/src/vector/strEdit.hpp Test: test/strEdit.hpp","title":"Implementation"},{"location":"src/string/strmatch.html","text":"strmatch Abstract strmatch.hpp contains string comparision functions. strmatch.hpp \u306f\u6587\u5b57\u5217\u6bd4\u8f03\u95a2\u6570\u3092\u53ce\u9332\u3057\u3066\u3044\u307e\u3059\uff0e Header file namespace sstd { bool strcmp ( const char * str1 , const char * str2 ); bool strcmp ( const char * str1 , const std :: string & str2 ); bool strcmp ( const std :: string & str1 , const char * str2 ); bool strcmp ( const std :: string & str1 , const std :: string & str2 ); bool strmatch ( const char * str , const char * wildCard ); bool strmatch ( const char * str , const std :: string & wildCard ); bool strmatch ( const std :: string & str , const char * wildCard ); bool strmatch ( const std :: string & str , const std :: string & wildCard ); bool strmatch_getWC ( const char * str , const char * wildCard , std :: string & retWC ); bool strmatch_getWC ( const char * str , const std :: string & wildCard , std :: string & retWC ); bool strmatch_getWC ( const std :: string & str , const char * wildCard , std :: string & retWC ); bool strmatch_getWC ( const std :: string & str , const std :: string & wildCard , std :: string & retWC ); bool pathmatch ( const char * str , const char * wildCard ); bool pathmatch ( const char * str , const std :: string & wildCard ); bool pathmatch ( const std :: string & str , const char * wildCard ); bool pathmatch ( const std :: string & str , const std :: string & wildCard ); bool isNum ( const char rhs ); bool isNum ( const char * rhs ); bool isNum ( const std :: string & rhs ); bool isAlphabet ( const char rhs ); bool isAlphabet ( const char * rhs ); bool isAlphabet ( const std :: string & rhs ); bool isAlphabet_upper ( const char rhs ); bool isAlphabet_upper ( const char * rhs ); bool isAlphabet_upper ( const std :: string & rhs ); bool isAlphabet_lower ( const char rhs ); bool isAlphabet_lower ( const char * rhs ); bool isAlphabet_lower ( const std :: string & rhs ); bool charIn ( const char lhs , const char * rhs ); // Is lhs in rhs ? bool charIn ( const char lhs , const std :: string & rhs ); // Is lhs in rhs ? bool strIn ( const char * lhs , const char * rhs ); // is lhs in rhs ? (is rhs include lhs ?) bool strIn ( const char * lhs , const std :: string & rhs ); bool strIn ( const std :: string & lhs , const char * rhs ); bool strIn ( const std :: string & lhs , const std :: string & rhs ); } Description Function name Description strcmp() A function that compares whether two input strings match exactly. \u5165\u529b\u5f15\u6570\u306b\u4e0e\u3048\u3089\u308c\u308b 2 \u3064\u306e\u6587\u5b57\u5217\u3092\u6bd4\u8f03\u3057\uff0c\u7b49\u3057\u3044\u5834\u5408\u306f true \u3092\uff0c\u305d\u308c\u4ee5\u5916\u306f false \u3092\u8fd4\u3059\uff0e strmatch() A function to compare strings. The return value returns the match / mismatch of the strings passed to the 1st argument and the 2nd argument. And the string of the 2nd argument can contain wild card ( * or ? ). \u6587\u5b57\u5217\u6bd4\u8f03\u7528\u306e\u95a2\u6570\uff0e\u623b\u308a\u5024\u306f\uff0c\u7b2c\u4e00\u5f15\u6570\u3068\u7b2c\u4e8c\u5f15\u6570\u306b\u6e21\u3055\u308c\u305f\u6587\u5b57\u5217\u306e\u4e00\u81f4\u30fb\u4e0d\u4e00\u81f4\u3092\u8fd4\u5374\u3057\u307e\u3059\uff0e\u307e\u305f\uff0c\u7b2c\u4e8c\u5f15\u6570\u306e\u6587\u5b57\u5217\u306b\u306f wild card ( * \u307e\u305f\u306f ? ) \u3092\u542b\u3081\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e strmatch_getWC() A function to get a substring. In the 3rd argument, the part of the 1st argument string that matches the wild card ( * or ? ) of 2nd argument is returned. The other handling of the return value, the 1st argument, and the 2nd argument is the same as strmatch () . \u90e8\u5206\u6587\u5b57\u5217\u53d6\u5f97\u7528\u306e\u95a2\u6570\uff0e\u7b2c\u4e09\u5f15\u6570\u304c\uff0c\u7b2c\u4e00\u5f15\u6570\u306e\u6587\u5b57\u5217\u306e\u3046\u3061\uff0c\u7b2c\u4e8c\u5f15\u6570\u306e wild card ( * \u307e\u305f\u306f ? ) \u3068\u4e00\u81f4\u3059\u308b\u90e8\u5206\u3092\u8fd4\u5374\u3057\u307e\u3059\uff0e\u623b\u308a\u5024\u3068\u7b2c\u4e00\u5f15\u6570\uff0c\u7b2c\u4e8c\u5f15\u6570\u306e\u6271\u3044\u306f strmatch() \u3068\u540c\u3058\u3067\u3059\uff0e pathmatch() A function to compare a paths of strings. The splitter string ( / or \\\\ ) does not accept wild card exclusions. The other handlings work the same as strmatch () . \u30d1\u30b9\u306e\u6bd4\u8f03\u7528\u95a2\u6570\uff0e\u30b9\u30d7\u30ea\u30c3\u30bf\u3068\u306a\u308b\u6587\u5b57\u5217 ( / \u307e\u305f\u306f \\\\ ) \u304c wild card \u306b\u3088\u308b\u9664\u5916\u3092\u53d7\u4ed8\u307e\u305b\u3093\uff0e\u305d\u308c\u4ee5\u5916\u306f\uff0c strmatch() \u3068\u540c\u69d8\u306b\u52d5\u4f5c\u3057\u307e\u3059\uff0e isNum() A function that judges if a string is configured by numerical string. Determine if a character or all of the string passed to the 1st argument are in the range of 0 to 9 as a ASCII Code. \u6587\u5b57\u5217\u304c\u6570\u5024\u3067\u69cb\u6210\u3055\u308c\u3066\u3044\u308b\u304b\u5224\u5b9a\u3059\u308b\u95a2\u6570\uff0e\u7b2c\u4e00\u5f15\u6570\u306b\u6e21\u3055\u308c\u305f\u5168\u3066\u306e\u6587\u5b57\u307e\u305f\u306f\u6587\u5b57\u5217\u304c ASCII Code \u3067\u306e 0 ~ 9 \u306e\u7bc4\u56f2\u306b\u3042\u308b\u304b\u3069\u3046\u304b\u3092\u5224\u5b9a\u3057\u307e\u3059\uff0e isAlphabet() A function that judges if a string is configured by alphabet. Determine if a character or all of the string passed to the 1st argument are in the range of A to Z or a to z as a ASCII Code. \u6587\u5b57\u5217\u304c\u30a2\u30eb\u30d5\u30a1\u30d9\u30c3\u30c8\u3067\u69cb\u6210\u3055\u308c\u3066\u3044\u308b\u304b\u5224\u5b9a\u3059\u308b\u95a2\u6570\uff0e\u7b2c\u4e00\u5f15\u6570\u306b\u6e21\u3055\u308c\u305f\u5168\u3066\u306e\u6587\u5b57\u307e\u305f\u306f\u6587\u5b57\u5217\u304c ASCII Code \u3067\u306e A ~ Z \u307e\u305f\u306f a ~ z \u306e\u7bc4\u56f2\u306b\u3042\u308b\u304b\u3069\u3046\u304b\u3092\u5224\u5b9a\u3057\u307e\u3059\uff0e isAlphabet_upper() A function that judges if a string is configured by uppercase. Determine if a character or all of the string passed to the 1st argument are in the range of A to Z as a ASCII Code. \u6587\u5b57\u5217\u304c\u5927\u6587\u5b57\u306e\u30a2\u30eb\u30d5\u30a1\u30d9\u30c3\u30c8\u3067\u69cb\u6210\u3055\u308c\u3066\u3044\u308b\u304b\u5224\u5b9a\u3059\u308b\u95a2\u6570\uff0e\u7b2c\u4e00\u5f15\u6570\u306b\u6e21\u3055\u308c\u305f\u5168\u3066\u306e\u6587\u5b57\u307e\u305f\u306f\u6587\u5b57\u5217\u304c ASCII Code \u3067\u306e A ~ Z \u306e\u7bc4\u56f2\u306b\u3042\u308b\u304b\u3069\u3046\u304b\u3092\u5224\u5b9a\u3057\u307e\u3059\uff0e isAlphabet_lower() A function that judges if a string is configured by lowercase. Determine if a character or all of the string passed to the 1st argument are in the range of a to z as a ASCII Code. \u6587\u5b57\u5217\u304c\u5c0f\u6587\u5b57\u306e\u30a2\u30eb\u30d5\u30a1\u30d9\u30c3\u30c8\u3067\u69cb\u6210\u3055\u308c\u3066\u3044\u308b\u304b\u5224\u5b9a\u3059\u308b\u95a2\u6570\uff0e\u7b2c\u4e00\u5f15\u6570\u306b\u6e21\u3055\u308c\u305f\u5168\u3066\u306e\u6587\u5b57\u307e\u305f\u306f\u6587\u5b57\u5217\u304c ASCII Code \u3067\u306e a ~ z \u306e\u7bc4\u56f2\u306b\u3042\u308b\u304b\u3069\u3046\u304b\u3092\u5224\u5b9a\u3057\u307e\u3059\uff0e charIn() A function that judges the inclusion of a particular character. Determine if the character of the 1st argument is included in the string of the 2nd argument. \u7279\u5b9a\u306e\u6587\u5b57\u3092\u5185\u5305\u3059\u308b\u304b\u5224\u5b9a\u3059\u308b\u95a2\u6570\uff0e\u7b2c\u4e00\u5f15\u6570\u306e\u6587\u5b57\u304c\uff0c\u7b2c\u4e8c\u5f15\u6570\u306e\u6587\u5b57\u5217\u306b\u542b\u307e\u308c\u308b\u3092\u5224\u5b9a\u3057\u307e\u3059\uff0e strIn() A function that judges the inclusion of a particular string. Determine if the string of the 1st argument is included in the string of the 2nd argument. \u7279\u5b9a\u306e\u6587\u5b57\u5217\u3092\u5185\u5305\u3059\u308b\u304b\u5224\u5b9a\u3059\u308b\u95a2\u6570\uff0e\u7b2c\u4e00\u5f15\u6570\u306e\u6587\u5b57\u5217\u304c\uff0c\u7b2c\u4e8c\u5f15\u6570\u306e\u6587\u5b57\u5217\u306b\u542b\u307e\u308c\u308b\u304b\u3092\u5224\u5b9a\u3057\u307e\u3059\uff0e Usage strcmp() main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: strcmp ( \"abc def\" , \"abc def\" ) ); sstd :: printn ( sstd :: strcmp ( \"abc def\" , \"abc ef\" ) ); } Execution result sstd::strcmp(\"abc def\", \"abc def\") = true sstd::strcmp(\"abc def\", \"abc ef\") = false strmatch(), strmatch_getWC() main.cpp #include <sstd/sstd.hpp> int main (){ std :: string s = \"TOKYOTO...\" ; sstd :: printn ( sstd :: strmatch ( s , \"??KYOTO*\" ) ); std :: string ret ; sstd :: printn ( sstd :: strmatch_getWC ( s , \"TO*...\" , ret ) ); sstd :: printn ( ret ); } Execution result sstd::strmatch(s, \"??KYOTO*\") = true sstd::strmatch_getWC(s, \"TO*...\", ret) = true ret = \"KYOTO\" pathmatch() main.cpp #include <sstd/sstd.hpp> int main (){ std :: string s = \"/a/b/c/example.txt\" ; sstd :: printn ( sstd :: pathmatch ( s , \"/*/*/*/*.txt\" ) ); sstd :: printn ( sstd :: pathmatch ( s , \"/*/*/*.txt\" ) ); } Execution result sstd::pathmatch(s, \"/*/*/*/*.txt\") = true sstd::pathmatch(s, \"/*/*/*.txt\") = false isNum() main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: isNum ( '0' ) ); sstd :: printn ( sstd :: isNum ( 'A' ) ); sstd :: printn ( sstd :: isNum ( 'a' ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isNum ( \"0123456789\" ) ); sstd :: printn ( sstd :: isNum ( \"012345678a\" ) ); sstd :: printn ( sstd :: isNum ( \"abcdeABCDE\" ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isNum ( std :: string ( \"0123456789\" )) ); sstd :: printn ( sstd :: isNum ( std :: string ( \"012345678a\" )) ); sstd :: printn ( sstd :: isNum ( std :: string ( \"abcdeABCDE\" )) ); printf ( \" \\n \" ); } Execution result sstd::isNum('0') = true sstd::isNum('A') = false sstd::isNum('a') = false sstd::isNum(\"0123456789\") = true sstd::isNum(\"012345678a\") = false sstd::isNum(\"abcdeABCDE\") = false sstd::isNum(std::string(\"0123456789\")) = true sstd::isNum(std::string(\"012345678a\")) = false sstd::isNum(std::string(\"abcdeABCDE\")) = false isAlphabet() main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: isAlphabet ( '0' ) ); sstd :: printn ( sstd :: isAlphabet ( 'A' ) ); sstd :: printn ( sstd :: isAlphabet ( 'a' ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isAlphabet ( \"0123456789\" ) ); sstd :: printn ( sstd :: isAlphabet ( \"ABCDEFTGI9\" ) ); sstd :: printn ( sstd :: isAlphabet ( \"abcdeABCDE\" ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isAlphabet ( std :: string ( \"0123456789\" )) ); sstd :: printn ( sstd :: isAlphabet ( std :: string ( \"ABCDEFTGI9\" )) ); sstd :: printn ( sstd :: isAlphabet ( std :: string ( \"abcdeABCDE\" )) ); printf ( \" \\n \" ); } Execution result sstd::isAlphabet('0') = false sstd::isAlphabet('A') = true sstd::isAlphabet('a') = true sstd::isAlphabet(\"0123456789\") = false sstd::isAlphabet(\"ABCDEFTGI9\") = false sstd::isAlphabet(\"abcdeABCDE\") = true sstd::isAlphabet(std::string(\"0123456789\")) = false sstd::isAlphabet(std::string(\"ABCDEFTGI9\")) = false sstd::isAlphabet(std::string(\"abcdeABCDE\")) = true isAlphabet_upper() main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: isAlphabet_upper ( '0' ) ); sstd :: printn ( sstd :: isAlphabet_upper ( 'A' ) ); sstd :: printn ( sstd :: isAlphabet_upper ( 'a' ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isAlphabet_upper ( \"0123456789\" ) ); sstd :: printn ( sstd :: isAlphabet_upper ( \"ABCDEFGHIJ\" ) ); sstd :: printn ( sstd :: isAlphabet_upper ( \"abcdeABCDE\" ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isAlphabet_upper ( std :: string ( \"0123456789\" )) ); sstd :: printn ( sstd :: isAlphabet_upper ( std :: string ( \"ABCDEFGHIJ\" )) ); sstd :: printn ( sstd :: isAlphabet_upper ( std :: string ( \"abcdeABCDE\" )) ); printf ( \" \\n \" ); } Execution result sstd::isAlphabet_upper('0') = false sstd::isAlphabet_upper('A') = true sstd::isAlphabet_upper('a') = false sstd::isAlphabet_upper(\"0123456789\") = false sstd::isAlphabet_upper(\"ABCDEFGHIJ\") = true sstd::isAlphabet_upper(\"abcdeABCDE\") = false sstd::isAlphabet_upper(std::string(\"0123456789\")) = false sstd::isAlphabet_upper(std::string(\"ABCDEFGHIJ\")) = true sstd::isAlphabet_upper(std::string(\"abcdeABCDE\")) = false isAlphabet_lower() main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: isAlphabet_lower ( '0' ) ); sstd :: printn ( sstd :: isAlphabet_lower ( 'A' ) ); sstd :: printn ( sstd :: isAlphabet_lower ( 'a' ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isAlphabet_lower ( \"0123456789\" ) ); sstd :: printn ( sstd :: isAlphabet_lower ( \"abcdeABCDE\" ) ); sstd :: printn ( sstd :: isAlphabet_lower ( \"abcdefghij\" ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isAlphabet_lower ( std :: string ( \"0123456789\" )) ); sstd :: printn ( sstd :: isAlphabet_lower ( std :: string ( \"abcdeABCDE\" )) ); sstd :: printn ( sstd :: isAlphabet_lower ( std :: string ( \"abcdefghij\" )) ); printf ( \" \\n \" ); } Execution result sstd::isAlphabet_lower('0') = false sstd::isAlphabet_lower('A') = false sstd::isAlphabet_lower('a') = true sstd::isAlphabet_lower(\"0123456789\") = false sstd::isAlphabet_lower(\"abcdeABCDE\") = false sstd::isAlphabet_lower(\"abcdefghij\") = true sstd::isAlphabet_lower(std::string(\"0123456789\")) = false sstd::isAlphabet_lower(std::string(\"abcdeABCDE\")) = false sstd::isAlphabet_lower(std::string(\"abcdefghij\")) = true charIn(), strIn() main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: charIn ( 'c' , \"abcdef\" ) ); sstd :: printn ( sstd :: charIn ( 'x' , \"abcdef\" ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: strIn ( \"def\" , \"abcdefgh\" ) ); sstd :: printn ( sstd :: strIn ( \"defx\" , \"abcdefgh\" ) ); } Execution result sstd::charIn('c', \"abcdef\") = true sstd::charIn('x', \"abcdef\") = false sstd::strIn(\"def\", \"abcdefgh\") = true sstd::strIn(\"defx\", \"abcdefgh\") = false Implementation Source: sstd/src/string/strmatch.cpp Header: sstd/src/string/strmatch.hpp Test: test/string/strmatch.hpp","title":"strmatch"},{"location":"src/string/strmatch.html#strmatch","text":"","title":"strmatch"},{"location":"src/string/strmatch.html#abstract","text":"strmatch.hpp contains string comparision functions. strmatch.hpp \u306f\u6587\u5b57\u5217\u6bd4\u8f03\u95a2\u6570\u3092\u53ce\u9332\u3057\u3066\u3044\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/string/strmatch.html#header-file","text":"namespace sstd { bool strcmp ( const char * str1 , const char * str2 ); bool strcmp ( const char * str1 , const std :: string & str2 ); bool strcmp ( const std :: string & str1 , const char * str2 ); bool strcmp ( const std :: string & str1 , const std :: string & str2 ); bool strmatch ( const char * str , const char * wildCard ); bool strmatch ( const char * str , const std :: string & wildCard ); bool strmatch ( const std :: string & str , const char * wildCard ); bool strmatch ( const std :: string & str , const std :: string & wildCard ); bool strmatch_getWC ( const char * str , const char * wildCard , std :: string & retWC ); bool strmatch_getWC ( const char * str , const std :: string & wildCard , std :: string & retWC ); bool strmatch_getWC ( const std :: string & str , const char * wildCard , std :: string & retWC ); bool strmatch_getWC ( const std :: string & str , const std :: string & wildCard , std :: string & retWC ); bool pathmatch ( const char * str , const char * wildCard ); bool pathmatch ( const char * str , const std :: string & wildCard ); bool pathmatch ( const std :: string & str , const char * wildCard ); bool pathmatch ( const std :: string & str , const std :: string & wildCard ); bool isNum ( const char rhs ); bool isNum ( const char * rhs ); bool isNum ( const std :: string & rhs ); bool isAlphabet ( const char rhs ); bool isAlphabet ( const char * rhs ); bool isAlphabet ( const std :: string & rhs ); bool isAlphabet_upper ( const char rhs ); bool isAlphabet_upper ( const char * rhs ); bool isAlphabet_upper ( const std :: string & rhs ); bool isAlphabet_lower ( const char rhs ); bool isAlphabet_lower ( const char * rhs ); bool isAlphabet_lower ( const std :: string & rhs ); bool charIn ( const char lhs , const char * rhs ); // Is lhs in rhs ? bool charIn ( const char lhs , const std :: string & rhs ); // Is lhs in rhs ? bool strIn ( const char * lhs , const char * rhs ); // is lhs in rhs ? (is rhs include lhs ?) bool strIn ( const char * lhs , const std :: string & rhs ); bool strIn ( const std :: string & lhs , const char * rhs ); bool strIn ( const std :: string & lhs , const std :: string & rhs ); }","title":"Header file"},{"location":"src/string/strmatch.html#description","text":"Function name Description strcmp() A function that compares whether two input strings match exactly. \u5165\u529b\u5f15\u6570\u306b\u4e0e\u3048\u3089\u308c\u308b 2 \u3064\u306e\u6587\u5b57\u5217\u3092\u6bd4\u8f03\u3057\uff0c\u7b49\u3057\u3044\u5834\u5408\u306f true \u3092\uff0c\u305d\u308c\u4ee5\u5916\u306f false \u3092\u8fd4\u3059\uff0e strmatch() A function to compare strings. The return value returns the match / mismatch of the strings passed to the 1st argument and the 2nd argument. And the string of the 2nd argument can contain wild card ( * or ? ). \u6587\u5b57\u5217\u6bd4\u8f03\u7528\u306e\u95a2\u6570\uff0e\u623b\u308a\u5024\u306f\uff0c\u7b2c\u4e00\u5f15\u6570\u3068\u7b2c\u4e8c\u5f15\u6570\u306b\u6e21\u3055\u308c\u305f\u6587\u5b57\u5217\u306e\u4e00\u81f4\u30fb\u4e0d\u4e00\u81f4\u3092\u8fd4\u5374\u3057\u307e\u3059\uff0e\u307e\u305f\uff0c\u7b2c\u4e8c\u5f15\u6570\u306e\u6587\u5b57\u5217\u306b\u306f wild card ( * \u307e\u305f\u306f ? ) \u3092\u542b\u3081\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e strmatch_getWC() A function to get a substring. In the 3rd argument, the part of the 1st argument string that matches the wild card ( * or ? ) of 2nd argument is returned. The other handling of the return value, the 1st argument, and the 2nd argument is the same as strmatch () . \u90e8\u5206\u6587\u5b57\u5217\u53d6\u5f97\u7528\u306e\u95a2\u6570\uff0e\u7b2c\u4e09\u5f15\u6570\u304c\uff0c\u7b2c\u4e00\u5f15\u6570\u306e\u6587\u5b57\u5217\u306e\u3046\u3061\uff0c\u7b2c\u4e8c\u5f15\u6570\u306e wild card ( * \u307e\u305f\u306f ? ) \u3068\u4e00\u81f4\u3059\u308b\u90e8\u5206\u3092\u8fd4\u5374\u3057\u307e\u3059\uff0e\u623b\u308a\u5024\u3068\u7b2c\u4e00\u5f15\u6570\uff0c\u7b2c\u4e8c\u5f15\u6570\u306e\u6271\u3044\u306f strmatch() \u3068\u540c\u3058\u3067\u3059\uff0e pathmatch() A function to compare a paths of strings. The splitter string ( / or \\\\ ) does not accept wild card exclusions. The other handlings work the same as strmatch () . \u30d1\u30b9\u306e\u6bd4\u8f03\u7528\u95a2\u6570\uff0e\u30b9\u30d7\u30ea\u30c3\u30bf\u3068\u306a\u308b\u6587\u5b57\u5217 ( / \u307e\u305f\u306f \\\\ ) \u304c wild card \u306b\u3088\u308b\u9664\u5916\u3092\u53d7\u4ed8\u307e\u305b\u3093\uff0e\u305d\u308c\u4ee5\u5916\u306f\uff0c strmatch() \u3068\u540c\u69d8\u306b\u52d5\u4f5c\u3057\u307e\u3059\uff0e isNum() A function that judges if a string is configured by numerical string. Determine if a character or all of the string passed to the 1st argument are in the range of 0 to 9 as a ASCII Code. \u6587\u5b57\u5217\u304c\u6570\u5024\u3067\u69cb\u6210\u3055\u308c\u3066\u3044\u308b\u304b\u5224\u5b9a\u3059\u308b\u95a2\u6570\uff0e\u7b2c\u4e00\u5f15\u6570\u306b\u6e21\u3055\u308c\u305f\u5168\u3066\u306e\u6587\u5b57\u307e\u305f\u306f\u6587\u5b57\u5217\u304c ASCII Code \u3067\u306e 0 ~ 9 \u306e\u7bc4\u56f2\u306b\u3042\u308b\u304b\u3069\u3046\u304b\u3092\u5224\u5b9a\u3057\u307e\u3059\uff0e isAlphabet() A function that judges if a string is configured by alphabet. Determine if a character or all of the string passed to the 1st argument are in the range of A to Z or a to z as a ASCII Code. \u6587\u5b57\u5217\u304c\u30a2\u30eb\u30d5\u30a1\u30d9\u30c3\u30c8\u3067\u69cb\u6210\u3055\u308c\u3066\u3044\u308b\u304b\u5224\u5b9a\u3059\u308b\u95a2\u6570\uff0e\u7b2c\u4e00\u5f15\u6570\u306b\u6e21\u3055\u308c\u305f\u5168\u3066\u306e\u6587\u5b57\u307e\u305f\u306f\u6587\u5b57\u5217\u304c ASCII Code \u3067\u306e A ~ Z \u307e\u305f\u306f a ~ z \u306e\u7bc4\u56f2\u306b\u3042\u308b\u304b\u3069\u3046\u304b\u3092\u5224\u5b9a\u3057\u307e\u3059\uff0e isAlphabet_upper() A function that judges if a string is configured by uppercase. Determine if a character or all of the string passed to the 1st argument are in the range of A to Z as a ASCII Code. \u6587\u5b57\u5217\u304c\u5927\u6587\u5b57\u306e\u30a2\u30eb\u30d5\u30a1\u30d9\u30c3\u30c8\u3067\u69cb\u6210\u3055\u308c\u3066\u3044\u308b\u304b\u5224\u5b9a\u3059\u308b\u95a2\u6570\uff0e\u7b2c\u4e00\u5f15\u6570\u306b\u6e21\u3055\u308c\u305f\u5168\u3066\u306e\u6587\u5b57\u307e\u305f\u306f\u6587\u5b57\u5217\u304c ASCII Code \u3067\u306e A ~ Z \u306e\u7bc4\u56f2\u306b\u3042\u308b\u304b\u3069\u3046\u304b\u3092\u5224\u5b9a\u3057\u307e\u3059\uff0e isAlphabet_lower() A function that judges if a string is configured by lowercase. Determine if a character or all of the string passed to the 1st argument are in the range of a to z as a ASCII Code. \u6587\u5b57\u5217\u304c\u5c0f\u6587\u5b57\u306e\u30a2\u30eb\u30d5\u30a1\u30d9\u30c3\u30c8\u3067\u69cb\u6210\u3055\u308c\u3066\u3044\u308b\u304b\u5224\u5b9a\u3059\u308b\u95a2\u6570\uff0e\u7b2c\u4e00\u5f15\u6570\u306b\u6e21\u3055\u308c\u305f\u5168\u3066\u306e\u6587\u5b57\u307e\u305f\u306f\u6587\u5b57\u5217\u304c ASCII Code \u3067\u306e a ~ z \u306e\u7bc4\u56f2\u306b\u3042\u308b\u304b\u3069\u3046\u304b\u3092\u5224\u5b9a\u3057\u307e\u3059\uff0e charIn() A function that judges the inclusion of a particular character. Determine if the character of the 1st argument is included in the string of the 2nd argument. \u7279\u5b9a\u306e\u6587\u5b57\u3092\u5185\u5305\u3059\u308b\u304b\u5224\u5b9a\u3059\u308b\u95a2\u6570\uff0e\u7b2c\u4e00\u5f15\u6570\u306e\u6587\u5b57\u304c\uff0c\u7b2c\u4e8c\u5f15\u6570\u306e\u6587\u5b57\u5217\u306b\u542b\u307e\u308c\u308b\u3092\u5224\u5b9a\u3057\u307e\u3059\uff0e strIn() A function that judges the inclusion of a particular string. Determine if the string of the 1st argument is included in the string of the 2nd argument. \u7279\u5b9a\u306e\u6587\u5b57\u5217\u3092\u5185\u5305\u3059\u308b\u304b\u5224\u5b9a\u3059\u308b\u95a2\u6570\uff0e\u7b2c\u4e00\u5f15\u6570\u306e\u6587\u5b57\u5217\u304c\uff0c\u7b2c\u4e8c\u5f15\u6570\u306e\u6587\u5b57\u5217\u306b\u542b\u307e\u308c\u308b\u304b\u3092\u5224\u5b9a\u3057\u307e\u3059\uff0e","title":"Description"},{"location":"src/string/strmatch.html#usage","text":"","title":"Usage"},{"location":"src/string/strmatch.html#strcmp","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: strcmp ( \"abc def\" , \"abc def\" ) ); sstd :: printn ( sstd :: strcmp ( \"abc def\" , \"abc ef\" ) ); } Execution result sstd::strcmp(\"abc def\", \"abc def\") = true sstd::strcmp(\"abc def\", \"abc ef\") = false","title":"strcmp()"},{"location":"src/string/strmatch.html#strmatch-strmatch_getwc","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: string s = \"TOKYOTO...\" ; sstd :: printn ( sstd :: strmatch ( s , \"??KYOTO*\" ) ); std :: string ret ; sstd :: printn ( sstd :: strmatch_getWC ( s , \"TO*...\" , ret ) ); sstd :: printn ( ret ); } Execution result sstd::strmatch(s, \"??KYOTO*\") = true sstd::strmatch_getWC(s, \"TO*...\", ret) = true ret = \"KYOTO\"","title":"strmatch(), strmatch_getWC()"},{"location":"src/string/strmatch.html#pathmatch","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: string s = \"/a/b/c/example.txt\" ; sstd :: printn ( sstd :: pathmatch ( s , \"/*/*/*/*.txt\" ) ); sstd :: printn ( sstd :: pathmatch ( s , \"/*/*/*.txt\" ) ); } Execution result sstd::pathmatch(s, \"/*/*/*/*.txt\") = true sstd::pathmatch(s, \"/*/*/*.txt\") = false","title":"pathmatch()"},{"location":"src/string/strmatch.html#isnum","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: isNum ( '0' ) ); sstd :: printn ( sstd :: isNum ( 'A' ) ); sstd :: printn ( sstd :: isNum ( 'a' ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isNum ( \"0123456789\" ) ); sstd :: printn ( sstd :: isNum ( \"012345678a\" ) ); sstd :: printn ( sstd :: isNum ( \"abcdeABCDE\" ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isNum ( std :: string ( \"0123456789\" )) ); sstd :: printn ( sstd :: isNum ( std :: string ( \"012345678a\" )) ); sstd :: printn ( sstd :: isNum ( std :: string ( \"abcdeABCDE\" )) ); printf ( \" \\n \" ); } Execution result sstd::isNum('0') = true sstd::isNum('A') = false sstd::isNum('a') = false sstd::isNum(\"0123456789\") = true sstd::isNum(\"012345678a\") = false sstd::isNum(\"abcdeABCDE\") = false sstd::isNum(std::string(\"0123456789\")) = true sstd::isNum(std::string(\"012345678a\")) = false sstd::isNum(std::string(\"abcdeABCDE\")) = false","title":"isNum()"},{"location":"src/string/strmatch.html#isalphabet","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: isAlphabet ( '0' ) ); sstd :: printn ( sstd :: isAlphabet ( 'A' ) ); sstd :: printn ( sstd :: isAlphabet ( 'a' ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isAlphabet ( \"0123456789\" ) ); sstd :: printn ( sstd :: isAlphabet ( \"ABCDEFTGI9\" ) ); sstd :: printn ( sstd :: isAlphabet ( \"abcdeABCDE\" ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isAlphabet ( std :: string ( \"0123456789\" )) ); sstd :: printn ( sstd :: isAlphabet ( std :: string ( \"ABCDEFTGI9\" )) ); sstd :: printn ( sstd :: isAlphabet ( std :: string ( \"abcdeABCDE\" )) ); printf ( \" \\n \" ); } Execution result sstd::isAlphabet('0') = false sstd::isAlphabet('A') = true sstd::isAlphabet('a') = true sstd::isAlphabet(\"0123456789\") = false sstd::isAlphabet(\"ABCDEFTGI9\") = false sstd::isAlphabet(\"abcdeABCDE\") = true sstd::isAlphabet(std::string(\"0123456789\")) = false sstd::isAlphabet(std::string(\"ABCDEFTGI9\")) = false sstd::isAlphabet(std::string(\"abcdeABCDE\")) = true","title":"isAlphabet()"},{"location":"src/string/strmatch.html#isalphabet_upper","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: isAlphabet_upper ( '0' ) ); sstd :: printn ( sstd :: isAlphabet_upper ( 'A' ) ); sstd :: printn ( sstd :: isAlphabet_upper ( 'a' ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isAlphabet_upper ( \"0123456789\" ) ); sstd :: printn ( sstd :: isAlphabet_upper ( \"ABCDEFGHIJ\" ) ); sstd :: printn ( sstd :: isAlphabet_upper ( \"abcdeABCDE\" ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isAlphabet_upper ( std :: string ( \"0123456789\" )) ); sstd :: printn ( sstd :: isAlphabet_upper ( std :: string ( \"ABCDEFGHIJ\" )) ); sstd :: printn ( sstd :: isAlphabet_upper ( std :: string ( \"abcdeABCDE\" )) ); printf ( \" \\n \" ); } Execution result sstd::isAlphabet_upper('0') = false sstd::isAlphabet_upper('A') = true sstd::isAlphabet_upper('a') = false sstd::isAlphabet_upper(\"0123456789\") = false sstd::isAlphabet_upper(\"ABCDEFGHIJ\") = true sstd::isAlphabet_upper(\"abcdeABCDE\") = false sstd::isAlphabet_upper(std::string(\"0123456789\")) = false sstd::isAlphabet_upper(std::string(\"ABCDEFGHIJ\")) = true sstd::isAlphabet_upper(std::string(\"abcdeABCDE\")) = false","title":"isAlphabet_upper()"},{"location":"src/string/strmatch.html#isalphabet_lower","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: isAlphabet_lower ( '0' ) ); sstd :: printn ( sstd :: isAlphabet_lower ( 'A' ) ); sstd :: printn ( sstd :: isAlphabet_lower ( 'a' ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isAlphabet_lower ( \"0123456789\" ) ); sstd :: printn ( sstd :: isAlphabet_lower ( \"abcdeABCDE\" ) ); sstd :: printn ( sstd :: isAlphabet_lower ( \"abcdefghij\" ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isAlphabet_lower ( std :: string ( \"0123456789\" )) ); sstd :: printn ( sstd :: isAlphabet_lower ( std :: string ( \"abcdeABCDE\" )) ); sstd :: printn ( sstd :: isAlphabet_lower ( std :: string ( \"abcdefghij\" )) ); printf ( \" \\n \" ); } Execution result sstd::isAlphabet_lower('0') = false sstd::isAlphabet_lower('A') = false sstd::isAlphabet_lower('a') = true sstd::isAlphabet_lower(\"0123456789\") = false sstd::isAlphabet_lower(\"abcdeABCDE\") = false sstd::isAlphabet_lower(\"abcdefghij\") = true sstd::isAlphabet_lower(std::string(\"0123456789\")) = false sstd::isAlphabet_lower(std::string(\"abcdeABCDE\")) = false sstd::isAlphabet_lower(std::string(\"abcdefghij\")) = true","title":"isAlphabet_lower()"},{"location":"src/string/strmatch.html#charin-strin","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: charIn ( 'c' , \"abcdef\" ) ); sstd :: printn ( sstd :: charIn ( 'x' , \"abcdef\" ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: strIn ( \"def\" , \"abcdefgh\" ) ); sstd :: printn ( sstd :: strIn ( \"defx\" , \"abcdefgh\" ) ); } Execution result sstd::charIn('c', \"abcdef\") = true sstd::charIn('x', \"abcdef\") = false sstd::strIn(\"def\", \"abcdefgh\") = true sstd::strIn(\"defx\", \"abcdefgh\") = false","title":"charIn(), strIn()"},{"location":"src/string/strmatch.html#implementation","text":"Source: sstd/src/string/strmatch.cpp Header: sstd/src/string/strmatch.hpp Test: test/string/strmatch.hpp","title":"Implementation"},{"location":"src/time/measureTime.html","text":"measureTime Abstract measureTime measures the execution time. measureTime \u306f\u5b9f\u884c\u6642\u9593\u3092\u8a08\u6e2c\u3057\u307e\u3059\uff0e Header file namespace sstd { void measureTime_start ( time_m & startTime ); double measureTime_stop_s ( const time_m & startTime ); // sec double measureTime_stop_ms ( const time_m & startTime ); // milli sec double measureTime_stop_us ( const time_m & startTime ); // micro sec double measureTime_stop_ns ( const time_m & startTime ); // nano sec std :: string measureTime_ms2str ( uint64 tmp ); std :: string measureTime_stop_str ( const time_m & startTime ); void measureTime_stop_print ( const time_m & startTime ); } Usage Measurement of execution time. (\u5b9f\u884c\u6642\u9593\u306e\u8a08\u6e2c) main.cpp #include <sstd/sstd.hpp> int main (){ printf ( \" \\n \" ); printf ( \"+---------------------------------------------------+ \\n \" ); printf ( \"| | \\n \" ); printf ( \"| Welcome to Sub Standard Library (SSTD) ! | \\n \" ); printf ( \"| | \\n \" ); printf ( \"+---------------------------------------------------+ \\n \" ); printf ( \" \\n \" ); printf ( \"\u25a0 measureTime_start--------------- \\n\\n \" ); time_m timem ; sstd :: measureTime_start ( timem ); sstd :: sleep_s ( 1 ); sstd :: sleep_ms ( 100 ); sstd :: sleep_us ( 11 * 1000 ); printf ( \" \\n \" ); printf ( \"\u25a0 measureTime_stop---------------- \\n \" ); sstd :: measureTime_stop_print ( timem ); sstd :: pauseIfWin32 (); return 0 ; } Execution result +---------------------------------------------------+ | | | Welcome to Sub Standard Library (SSTD) ! | | | +---------------------------------------------------+ \u25a0 measureTime_start--------------- \u25a0 measureTime_stop---------------- -------------------------------- Execution time: 1. 111 sec -------------------------------- Lap time measurement. (\u30e9\u30c3\u30d7\u30bf\u30a4\u30e0\u306e\u6e2c\u5b9a) main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < double > vLT_ms ; time_m timem ; sstd :: measureTime_start ( timem ); vLT_ms . push_back ( sstd :: measureTime_stop_ms ( timem ) ); for ( uint i = 0 ; i < 5 ; ++ i ){ sstd :: sleep_ms ( 10 ); vLT_ms . push_back ( sstd :: measureTime_stop_ms ( timem ) ); } sstd :: printn ( vLT_ms ); return 0 ; } Execution result vLT_ms = [0. 10.097 20.163 30.236 40.299 50.376] Implementation Source: sstd/src/time/measureTime.cpp Header: sstd/src/time/measureTime.hpp Test: test/time/measureTime.hpp","title":"measureTime"},{"location":"src/time/measureTime.html#measuretime","text":"","title":"measureTime"},{"location":"src/time/measureTime.html#abstract","text":"measureTime measures the execution time. measureTime \u306f\u5b9f\u884c\u6642\u9593\u3092\u8a08\u6e2c\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/time/measureTime.html#header-file","text":"namespace sstd { void measureTime_start ( time_m & startTime ); double measureTime_stop_s ( const time_m & startTime ); // sec double measureTime_stop_ms ( const time_m & startTime ); // milli sec double measureTime_stop_us ( const time_m & startTime ); // micro sec double measureTime_stop_ns ( const time_m & startTime ); // nano sec std :: string measureTime_ms2str ( uint64 tmp ); std :: string measureTime_stop_str ( const time_m & startTime ); void measureTime_stop_print ( const time_m & startTime ); }","title":"Header file"},{"location":"src/time/measureTime.html#usage","text":"","title":"Usage"},{"location":"src/time/measureTime.html#measurement-of-execution-time","text":"main.cpp #include <sstd/sstd.hpp> int main (){ printf ( \" \\n \" ); printf ( \"+---------------------------------------------------+ \\n \" ); printf ( \"| | \\n \" ); printf ( \"| Welcome to Sub Standard Library (SSTD) ! | \\n \" ); printf ( \"| | \\n \" ); printf ( \"+---------------------------------------------------+ \\n \" ); printf ( \" \\n \" ); printf ( \"\u25a0 measureTime_start--------------- \\n\\n \" ); time_m timem ; sstd :: measureTime_start ( timem ); sstd :: sleep_s ( 1 ); sstd :: sleep_ms ( 100 ); sstd :: sleep_us ( 11 * 1000 ); printf ( \" \\n \" ); printf ( \"\u25a0 measureTime_stop---------------- \\n \" ); sstd :: measureTime_stop_print ( timem ); sstd :: pauseIfWin32 (); return 0 ; } Execution result +---------------------------------------------------+ | | | Welcome to Sub Standard Library (SSTD) ! | | | +---------------------------------------------------+ \u25a0 measureTime_start--------------- \u25a0 measureTime_stop---------------- -------------------------------- Execution time: 1. 111 sec --------------------------------","title":"Measurement of execution time. (\u5b9f\u884c\u6642\u9593\u306e\u8a08\u6e2c)"},{"location":"src/time/measureTime.html#lap-time-measurement","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < double > vLT_ms ; time_m timem ; sstd :: measureTime_start ( timem ); vLT_ms . push_back ( sstd :: measureTime_stop_ms ( timem ) ); for ( uint i = 0 ; i < 5 ; ++ i ){ sstd :: sleep_ms ( 10 ); vLT_ms . push_back ( sstd :: measureTime_stop_ms ( timem ) ); } sstd :: printn ( vLT_ms ); return 0 ; } Execution result vLT_ms = [0. 10.097 20.163 30.236 40.299 50.376]","title":"Lap time measurement. (\u30e9\u30c3\u30d7\u30bf\u30a4\u30e0\u306e\u6e2c\u5b9a)"},{"location":"src/time/measureTime.html#implementation","text":"Source: sstd/src/time/measureTime.cpp Header: sstd/src/time/measureTime.hpp Test: test/time/measureTime.hpp","title":"Implementation"},{"location":"src/time/sleep.html","text":"sleep Abstract sleep waits for the specified time. sleep \u306f\u6307\u5b9a\u6642\u9593\u5f85\u6a5f\u3057\u307e\u3059\uff0e Header file namespace sstd { inline void sleep_hour ( uint rhs ); inline void sleep_min ( uint rhs ); inline void sleep_s ( uint rhs ); inline void sleep_ms ( uint rhs ); inline void sleep_us ( uint rhs ); inline void sleep_ns ( uint rhs ); } Usage main.cpp #include <sstd/sstd.hpp> int main (){ time_m timem ; sstd :: measureTime_start ( timem ); sstd :: sleep_s ( 1 ); sstd :: sleep_ms ( 100 ); sstd :: sleep_us ( 11 * 1000 ); sstd :: measureTime_stop_print ( timem ); return 0 ; } Execution result -------------------------------- Execution time: 1. 111 sec -------------------------------- Implementation Header: sstd/src/sleep.hpp Test: test/sleep.hpp (Not implemented yet)","title":"sleep"},{"location":"src/time/sleep.html#sleep","text":"","title":"sleep"},{"location":"src/time/sleep.html#abstract","text":"sleep waits for the specified time. sleep \u306f\u6307\u5b9a\u6642\u9593\u5f85\u6a5f\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/time/sleep.html#header-file","text":"namespace sstd { inline void sleep_hour ( uint rhs ); inline void sleep_min ( uint rhs ); inline void sleep_s ( uint rhs ); inline void sleep_ms ( uint rhs ); inline void sleep_us ( uint rhs ); inline void sleep_ns ( uint rhs ); }","title":"Header file"},{"location":"src/time/sleep.html#usage","text":"main.cpp #include <sstd/sstd.hpp> int main (){ time_m timem ; sstd :: measureTime_start ( timem ); sstd :: sleep_s ( 1 ); sstd :: sleep_ms ( 100 ); sstd :: sleep_us ( 11 * 1000 ); sstd :: measureTime_stop_print ( timem ); return 0 ; } Execution result -------------------------------- Execution time: 1. 111 sec --------------------------------","title":"Usage"},{"location":"src/time/sleep.html#implementation","text":"Header: sstd/src/sleep.hpp Test: test/sleep.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/time/time.html","text":"time Abstract struct tm \u3068 time_t (unixtime) \u304a\u3088\u3073\uff0c\u305d\u306e\u4ed6\u306e\u6642\u523b\u3092\u76f8\u4e92\u5909\u63db\u3059\u308b\uff0e Header file namespace sstd { struct tm time2tm ( time_t unixtime ); time_t tm2time ( struct tm & rhs ); struct tm timeGm2tmLocal ( time_t unixtime ); time_t tmLocal2timeGm ( struct tm & rhs ); std :: string time2str ( time_t unixtime ); std :: string tm2str ( struct tm & rhs ); double time2unixday ( time_t unixtime ); double tm2unixday ( struct tm & rhs ); time_t yday2time ( uint year , uint yday ); struct tm yday2tm ( uint year , uint yday ); struct timeval getTimeval (); double unixtime2JulianDate ( time_t unixtime ); double Julius_T ( time_t unixtime ); double JulianDate2Julius_T ( double JulianDate ); double TJuliusD ( time_t unixtime ); double JulianDate2TJuliusD ( double JulianDate ); void print ( const struct tm & rhs ); void for_printn ( const struct tm & rhs ); } Usage main.cpp #include <time.h> // for time() #include <sstd/sstd.hpp> int main (){ time_t unixtime_UTC ; time ( & unixtime_UTC ); // get current unixtime (UTC) struct tm tm_UTC = sstd :: time2tm ( unixtime_UTC ); struct tm tm_Local = sstd :: timeGm2tmLocal ( unixtime_UTC ); sstd :: printn ( unixtime_UTC ); sstd :: printn ( tm_UTC ); sstd :: printn ( tm_Local ); } Execution result Below is the result on Japanese local time (UTC+9hour). unixtime_UTC = 1643029288 tm_UTC = 2022-01-24 13:01:28 tm_Local = 2022-01-24 13:01:28 Appendix struct tm { int tm_sec ; /* \u79d2 [0-61] \u6700\u59272\u79d2\u307e\u3067\u306e\u3046\u308b\u3046\u79d2\u3092\u8003\u616e */ int tm_min ; /* \u5206 [0-59] */ int tm_hour ; /* \u6642 [0-23] */ int tm_mday ; /* \u65e5 [1-31] */ int tm_mon ; /* \u6708 [0-11] 0\u304b\u3089\u59cb\u307e\u308b\u3053\u3068\u306b\u6ce8\u610f */ int tm_year ; /* \u5e74 [1900\u304b\u3089\u306e\u7d4c\u904e\u5e74\u6570] */ int tm_wday ; /* \u66dc\u65e5 [0:\u65e5 1:\u6708 ... 6:\u571f] */ int tm_yday ; /* \u5e74\u5185\u306e\u901a\u3057\u65e5\u6570 [0-365] 0\u304b\u3089\u59cb\u307e\u308b\u3053\u3068\u306b\u6ce8\u610f*/ int tm_isdst ; /* \u590f\u6642\u9593\u304c\u7121\u52b9\u3067\u3042\u308c\u3070 0 */ }; ref: localtime - \u521d\u5fc3\u8005\u306e\u305f\u3081\u306e\u30dd\u30a4\u30f3\u30c8\u5b66\u7fd2 C \u8a00\u8a9e Implementation Source: sstd/src/time/time.cpp Header: sstd/src/time/time.hpp Test: test/time/time.hpp","title":"time"},{"location":"src/time/time.html#time","text":"","title":"time"},{"location":"src/time/time.html#abstract","text":"struct tm \u3068 time_t (unixtime) \u304a\u3088\u3073\uff0c\u305d\u306e\u4ed6\u306e\u6642\u523b\u3092\u76f8\u4e92\u5909\u63db\u3059\u308b\uff0e","title":"Abstract"},{"location":"src/time/time.html#header-file","text":"namespace sstd { struct tm time2tm ( time_t unixtime ); time_t tm2time ( struct tm & rhs ); struct tm timeGm2tmLocal ( time_t unixtime ); time_t tmLocal2timeGm ( struct tm & rhs ); std :: string time2str ( time_t unixtime ); std :: string tm2str ( struct tm & rhs ); double time2unixday ( time_t unixtime ); double tm2unixday ( struct tm & rhs ); time_t yday2time ( uint year , uint yday ); struct tm yday2tm ( uint year , uint yday ); struct timeval getTimeval (); double unixtime2JulianDate ( time_t unixtime ); double Julius_T ( time_t unixtime ); double JulianDate2Julius_T ( double JulianDate ); double TJuliusD ( time_t unixtime ); double JulianDate2TJuliusD ( double JulianDate ); void print ( const struct tm & rhs ); void for_printn ( const struct tm & rhs ); }","title":"Header file"},{"location":"src/time/time.html#usage","text":"main.cpp #include <time.h> // for time() #include <sstd/sstd.hpp> int main (){ time_t unixtime_UTC ; time ( & unixtime_UTC ); // get current unixtime (UTC) struct tm tm_UTC = sstd :: time2tm ( unixtime_UTC ); struct tm tm_Local = sstd :: timeGm2tmLocal ( unixtime_UTC ); sstd :: printn ( unixtime_UTC ); sstd :: printn ( tm_UTC ); sstd :: printn ( tm_Local ); } Execution result Below is the result on Japanese local time (UTC+9hour). unixtime_UTC = 1643029288 tm_UTC = 2022-01-24 13:01:28 tm_Local = 2022-01-24 13:01:28","title":"Usage"},{"location":"src/time/time.html#appendix","text":"struct tm { int tm_sec ; /* \u79d2 [0-61] \u6700\u59272\u79d2\u307e\u3067\u306e\u3046\u308b\u3046\u79d2\u3092\u8003\u616e */ int tm_min ; /* \u5206 [0-59] */ int tm_hour ; /* \u6642 [0-23] */ int tm_mday ; /* \u65e5 [1-31] */ int tm_mon ; /* \u6708 [0-11] 0\u304b\u3089\u59cb\u307e\u308b\u3053\u3068\u306b\u6ce8\u610f */ int tm_year ; /* \u5e74 [1900\u304b\u3089\u306e\u7d4c\u904e\u5e74\u6570] */ int tm_wday ; /* \u66dc\u65e5 [0:\u65e5 1:\u6708 ... 6:\u571f] */ int tm_yday ; /* \u5e74\u5185\u306e\u901a\u3057\u65e5\u6570 [0-365] 0\u304b\u3089\u59cb\u307e\u308b\u3053\u3068\u306b\u6ce8\u610f*/ int tm_isdst ; /* \u590f\u6642\u9593\u304c\u7121\u52b9\u3067\u3042\u308c\u3070 0 */ }; ref: localtime - \u521d\u5fc3\u8005\u306e\u305f\u3081\u306e\u30dd\u30a4\u30f3\u30c8\u5b66\u7fd2 C \u8a00\u8a9e","title":"Appendix"},{"location":"src/time/time.html#implementation","text":"Source: sstd/src/time/time.cpp Header: sstd/src/time/time.hpp Test: test/time/time.hpp","title":"Implementation"},{"location":"src/vector/Tr.html","text":"Tr (Transpose) Abstract Tr() are the transpose functions for std::vector<std::vector<T>> . Tr() \u306f std::vector<std::vector<T>> \u3092\u8ee2\u7f6e\u3059\u308b\u305f\u3081\u306e\u95a2\u6570\u3067\u3059. Header file namespace sstd { template < typename T > std :: vector < std :: vector < T >> Tr ( const std :: vector < std :: vector < T >>& rhs ); template < typename T > std :: vector < std :: vector < T >> Tr ( std :: vector < std :: vector < T >>&& rhs ); } Usage Transpose. Ex: 1 main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < int >> vvec = { { 1 , 2 , 3 } }; sstd :: printn ( vvec ); std :: vector < std :: vector < int >> vvecTr = sstd :: Tr ( vvec ); sstd :: printn ( vvecTr ); } Execution result vvec = [[1 2 3]] vvecTr = [[1] [2] [3]] Transpose. Ex: 2 main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < int >> vvec = { { 1 , 2 , 3 }, { 4 , 5 , 6 }, { 7 , 8 , 9 } }; sstd :: printn ( vvec ); std :: vector < std :: vector < int >> vvecTr = sstd :: Tr ( vvec ); sstd :: printn ( vvecTr ); } Execution result vvec = [[1 2 3] [4 5 6] [7 8 9]] vvecTr = [[1 4 7] [2 5 8] [3 6 9]] Transpose. Ex: 3 main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < int >> vvec = { { 1 }, { 2 , 3 }, { 4 , 5 , 6 } }; sstd :: printn ( vvec ); std :: vector < std :: vector < int >> vvecTr = sstd :: Tr ( vvec ); sstd :: printn ( vvecTr ); } Execution result vvec = [[1] [2 3] [4 5 6]] vvecTr = [[1 2 4] [0 3 5] [0 0 6]] Implementation Header: sstd/src/vector/vvec.hpp Test: test/vector_vvec.hpp","title":"Tr (Transpose)"},{"location":"src/vector/Tr.html#tr-transpose","text":"","title":"Tr (Transpose)"},{"location":"src/vector/Tr.html#abstract","text":"Tr() are the transpose functions for std::vector<std::vector<T>> . Tr() \u306f std::vector<std::vector<T>> \u3092\u8ee2\u7f6e\u3059\u308b\u305f\u3081\u306e\u95a2\u6570\u3067\u3059.","title":"Abstract"},{"location":"src/vector/Tr.html#header-file","text":"namespace sstd { template < typename T > std :: vector < std :: vector < T >> Tr ( const std :: vector < std :: vector < T >>& rhs ); template < typename T > std :: vector < std :: vector < T >> Tr ( std :: vector < std :: vector < T >>&& rhs ); }","title":"Header file"},{"location":"src/vector/Tr.html#usage","text":"","title":"Usage"},{"location":"src/vector/Tr.html#transpose-ex-1","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < int >> vvec = { { 1 , 2 , 3 } }; sstd :: printn ( vvec ); std :: vector < std :: vector < int >> vvecTr = sstd :: Tr ( vvec ); sstd :: printn ( vvecTr ); } Execution result vvec = [[1 2 3]] vvecTr = [[1] [2] [3]]","title":"Transpose. Ex: 1"},{"location":"src/vector/Tr.html#transpose-ex-2","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < int >> vvec = { { 1 , 2 , 3 }, { 4 , 5 , 6 }, { 7 , 8 , 9 } }; sstd :: printn ( vvec ); std :: vector < std :: vector < int >> vvecTr = sstd :: Tr ( vvec ); sstd :: printn ( vvecTr ); } Execution result vvec = [[1 2 3] [4 5 6] [7 8 9]] vvecTr = [[1 4 7] [2 5 8] [3 6 9]]","title":"Transpose. Ex: 2"},{"location":"src/vector/Tr.html#transpose-ex-3","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < int >> vvec = { { 1 }, { 2 , 3 }, { 4 , 5 , 6 } }; sstd :: printn ( vvec ); std :: vector < std :: vector < int >> vvecTr = sstd :: Tr ( vvec ); sstd :: printn ( vvecTr ); } Execution result vvec = [[1] [2 3] [4 5 6]] vvecTr = [[1 2 4] [0 3 5] [0 0 6]]","title":"Transpose. Ex: 3"},{"location":"src/vector/Tr.html#implementation","text":"Header: sstd/src/vector/vvec.hpp Test: test/vector_vvec.hpp","title":"Implementation"},{"location":"src/vector/slice.html","text":"slice Abstract sstd::slice / sstd::slice_mv \u306f\uff0cPython \u306e slice \u5b9f\u88c5\u3092 C++ \u98a8\u306b\u30a2\u30ec\u30f3\u30b8\u3057\u305f sstd \u306e\u72ec\u81ea\u5b9f\u88c5\u3067\u3059\uff0e sstd::slice \u306f\u8981\u7d20\u30b3\u30d4\u30fc\u3092\u4f34\u3046\u547d\u4ee4\u3067\uff0c sstd::slice_mv \u306f\u5185\u90e8\u7684\u306b std::move \u3092\u547c\u3073\u51fa\u3057\u307e\u3059\uff0e std::vector \u306b\u5bfe\u3059\u308b slice \u64cd\u4f5c\u3092\u5b9a\u7fa9\u3057\u3066\u3044\u307e\u3059\uff0e \u306a\u304a\uff0c sstd::begin \u304a\u3088\u3073 sstd::end \u306f\uff0c src/itr.hpp \u306b\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\uff0e Header file namespace sstd { sstd_vecSc :: slice_i slice ( const int val ); sstd_vecSc :: slice_u slice ( const uint val ); sstd_vecSc :: slice_s slice ( const size_t val ); sstd_vecSc :: slice_b slice ( const sstd :: begin val ); sstd_vecSc :: slice_e slice ( const sstd :: end val ); sstd_vecSc :: slice_ii slice ( const int lhs , const int rhs ); sstd_vecSc :: slice_iu slice ( const int lhs , const uint rhs ); sstd_vecSc :: slice_is slice ( const int lhs , const size_t rhs ); sstd_vecSc :: slice_ui slice ( const uint lhs , const int rhs ); sstd_vecSc :: slice_uu slice ( const uint lhs , const uint rhs ); sstd_vecSc :: slice_us slice ( const uint lhs , const size_t rhs ); sstd_vecSc :: slice_si slice ( const size_t lhs , const int rhs ); sstd_vecSc :: slice_su slice ( const size_t lhs , const uint rhs ); sstd_vecSc :: slice_ss slice ( const size_t lhs , const size_t rhs ); sstd_vecSc :: slice_bi slice ( const sstd :: begin lhs , const int rhs ); sstd_vecSc :: slice_bu slice ( const sstd :: begin lhs , const uint rhs ); sstd_vecSc :: slice_bs slice ( const sstd :: begin lhs , const size_t rhs ); sstd_vecSc :: slice_ie slice ( const int lhs , const sstd :: end rhs ); sstd_vecSc :: slice_ue slice ( const uint lhs , const sstd :: end rhs ); sstd_vecSc :: slice_se slice ( const size_t lhs , const sstd :: end rhs ); sstd_vecSc :: slice_be slice ( const sstd :: begin lhs , const sstd :: end rhs ); //--- sstd_vecSc :: slice_mv_i slice_mv ( const int val ); sstd_vecSc :: slice_mv_u slice_mv ( const uint val ); sstd_vecSc :: slice_mv_s slice_mv ( const size_t val ); sstd_vecSc :: slice_mv_b slice_mv ( const sstd :: begin val ); sstd_vecSc :: slice_mv_e slice_mv ( const sstd :: end val ); sstd_vecSc :: slice_mv_ii slice_mv ( const int lhs , const int rhs ); sstd_vecSc :: slice_mv_iu slice_mv ( const int lhs , const uint rhs ); sstd_vecSc :: slice_mv_is slice_mv ( const int lhs , const size_t rhs ); sstd_vecSc :: slice_mv_ui slice_mv ( const uint lhs , const int rhs ); sstd_vecSc :: slice_mv_uu slice_mv ( const uint lhs , const uint rhs ); sstd_vecSc :: slice_mv_us slice_mv ( const uint lhs , const size_t rhs ); sstd_vecSc :: slice_mv_si slice_mv ( const size_t lhs , const int rhs ); sstd_vecSc :: slice_mv_su slice_mv ( const size_t lhs , const uint rhs ); sstd_vecSc :: slice_mv_ss slice_mv ( const size_t lhs , const size_t rhs ); sstd_vecSc :: slice_mv_bi slice_mv ( const sstd :: begin lhs , const int rhs ); sstd_vecSc :: slice_mv_bu slice_mv ( const sstd :: begin lhs , const uint rhs ); sstd_vecSc :: slice_mv_bs slice_mv ( const sstd :: begin lhs , const size_t rhs ); sstd_vecSc :: slice_mv_ie slice_mv ( const int lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_ue slice_mv ( const uint lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_se slice_mv ( const size_t lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_be slice_mv ( const sstd :: begin lhs , const sstd :: end rhs ); } Usage one arg (copy) main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced01 = v && sstd :: slice ( 1 ); std :: vector < int > v_sliced02 = v && sstd :: slice ( -1 ); sstd :: printn ( v ); sstd :: printn ( v_sliced01 ); sstd :: printn ( v_sliced02 ); } Execution result v = [1 2 3 4 5] v_sliced01 = [2] v_sliced02 = [5] two args (copy) main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced = v && sstd :: slice ( 1 , 3 ); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } Execution result v = [1 2 3 4 5] v_sliced = [2 3] begin to end (copy) main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced = v && sstd :: slice ( sstd :: begin (), sstd :: end ()); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } Execution result v = [1 2 3 4 5] v_sliced = [1 2 3 4 5] one arg (move) main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced01 = v && sstd :: slice_mv ( 1 ); std :: vector < std :: string > v_sliced02 = v && sstd :: slice_mv ( -1 ); sstd :: printn ( v ); sstd :: printn ( v_sliced01 ); sstd :: printn ( v_sliced02 ); } Execution result v = [\"1\" \"\" \"3\" \"4\" \"\"] v_sliced01 = [\"2\"] v_sliced02 = [\"5\"] two args (move) main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced = v && sstd :: slice_mv ( 1 , 3 ); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } Execution result v = [\"1\" \"\" \"\" \"4\" \"5\"] v_sliced = [\"2\" \"3\"] begin to end (move) main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced = v && sstd :: slice_mv ( sstd :: begin (), sstd :: end ()); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } Execution result v = [\"\" \"\" \"\" \"\" \"\"] v_sliced = [\"1\" \"2\" \"3\" \"4\" \"5\"] Implementation Header: sstd/src/vector/slice.hpp Test: test/vector_slice.hpp","title":"slice"},{"location":"src/vector/slice.html#slice","text":"","title":"slice"},{"location":"src/vector/slice.html#abstract","text":"sstd::slice / sstd::slice_mv \u306f\uff0cPython \u306e slice \u5b9f\u88c5\u3092 C++ \u98a8\u306b\u30a2\u30ec\u30f3\u30b8\u3057\u305f sstd \u306e\u72ec\u81ea\u5b9f\u88c5\u3067\u3059\uff0e sstd::slice \u306f\u8981\u7d20\u30b3\u30d4\u30fc\u3092\u4f34\u3046\u547d\u4ee4\u3067\uff0c sstd::slice_mv \u306f\u5185\u90e8\u7684\u306b std::move \u3092\u547c\u3073\u51fa\u3057\u307e\u3059\uff0e std::vector \u306b\u5bfe\u3059\u308b slice \u64cd\u4f5c\u3092\u5b9a\u7fa9\u3057\u3066\u3044\u307e\u3059\uff0e \u306a\u304a\uff0c sstd::begin \u304a\u3088\u3073 sstd::end \u306f\uff0c src/itr.hpp \u306b\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\uff0e","title":"Abstract"},{"location":"src/vector/slice.html#header-file","text":"namespace sstd { sstd_vecSc :: slice_i slice ( const int val ); sstd_vecSc :: slice_u slice ( const uint val ); sstd_vecSc :: slice_s slice ( const size_t val ); sstd_vecSc :: slice_b slice ( const sstd :: begin val ); sstd_vecSc :: slice_e slice ( const sstd :: end val ); sstd_vecSc :: slice_ii slice ( const int lhs , const int rhs ); sstd_vecSc :: slice_iu slice ( const int lhs , const uint rhs ); sstd_vecSc :: slice_is slice ( const int lhs , const size_t rhs ); sstd_vecSc :: slice_ui slice ( const uint lhs , const int rhs ); sstd_vecSc :: slice_uu slice ( const uint lhs , const uint rhs ); sstd_vecSc :: slice_us slice ( const uint lhs , const size_t rhs ); sstd_vecSc :: slice_si slice ( const size_t lhs , const int rhs ); sstd_vecSc :: slice_su slice ( const size_t lhs , const uint rhs ); sstd_vecSc :: slice_ss slice ( const size_t lhs , const size_t rhs ); sstd_vecSc :: slice_bi slice ( const sstd :: begin lhs , const int rhs ); sstd_vecSc :: slice_bu slice ( const sstd :: begin lhs , const uint rhs ); sstd_vecSc :: slice_bs slice ( const sstd :: begin lhs , const size_t rhs ); sstd_vecSc :: slice_ie slice ( const int lhs , const sstd :: end rhs ); sstd_vecSc :: slice_ue slice ( const uint lhs , const sstd :: end rhs ); sstd_vecSc :: slice_se slice ( const size_t lhs , const sstd :: end rhs ); sstd_vecSc :: slice_be slice ( const sstd :: begin lhs , const sstd :: end rhs ); //--- sstd_vecSc :: slice_mv_i slice_mv ( const int val ); sstd_vecSc :: slice_mv_u slice_mv ( const uint val ); sstd_vecSc :: slice_mv_s slice_mv ( const size_t val ); sstd_vecSc :: slice_mv_b slice_mv ( const sstd :: begin val ); sstd_vecSc :: slice_mv_e slice_mv ( const sstd :: end val ); sstd_vecSc :: slice_mv_ii slice_mv ( const int lhs , const int rhs ); sstd_vecSc :: slice_mv_iu slice_mv ( const int lhs , const uint rhs ); sstd_vecSc :: slice_mv_is slice_mv ( const int lhs , const size_t rhs ); sstd_vecSc :: slice_mv_ui slice_mv ( const uint lhs , const int rhs ); sstd_vecSc :: slice_mv_uu slice_mv ( const uint lhs , const uint rhs ); sstd_vecSc :: slice_mv_us slice_mv ( const uint lhs , const size_t rhs ); sstd_vecSc :: slice_mv_si slice_mv ( const size_t lhs , const int rhs ); sstd_vecSc :: slice_mv_su slice_mv ( const size_t lhs , const uint rhs ); sstd_vecSc :: slice_mv_ss slice_mv ( const size_t lhs , const size_t rhs ); sstd_vecSc :: slice_mv_bi slice_mv ( const sstd :: begin lhs , const int rhs ); sstd_vecSc :: slice_mv_bu slice_mv ( const sstd :: begin lhs , const uint rhs ); sstd_vecSc :: slice_mv_bs slice_mv ( const sstd :: begin lhs , const size_t rhs ); sstd_vecSc :: slice_mv_ie slice_mv ( const int lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_ue slice_mv ( const uint lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_se slice_mv ( const size_t lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_be slice_mv ( const sstd :: begin lhs , const sstd :: end rhs ); }","title":"Header file"},{"location":"src/vector/slice.html#usage","text":"","title":"Usage"},{"location":"src/vector/slice.html#one-arg-copy","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced01 = v && sstd :: slice ( 1 ); std :: vector < int > v_sliced02 = v && sstd :: slice ( -1 ); sstd :: printn ( v ); sstd :: printn ( v_sliced01 ); sstd :: printn ( v_sliced02 ); } Execution result v = [1 2 3 4 5] v_sliced01 = [2] v_sliced02 = [5]","title":"one arg (copy)"},{"location":"src/vector/slice.html#two-args-copy","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced = v && sstd :: slice ( 1 , 3 ); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } Execution result v = [1 2 3 4 5] v_sliced = [2 3]","title":"two args (copy)"},{"location":"src/vector/slice.html#begin-to-end-copy","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced = v && sstd :: slice ( sstd :: begin (), sstd :: end ()); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } Execution result v = [1 2 3 4 5] v_sliced = [1 2 3 4 5]","title":"begin to end (copy)"},{"location":"src/vector/slice.html#one-arg-move","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced01 = v && sstd :: slice_mv ( 1 ); std :: vector < std :: string > v_sliced02 = v && sstd :: slice_mv ( -1 ); sstd :: printn ( v ); sstd :: printn ( v_sliced01 ); sstd :: printn ( v_sliced02 ); } Execution result v = [\"1\" \"\" \"3\" \"4\" \"\"] v_sliced01 = [\"2\"] v_sliced02 = [\"5\"]","title":"one arg (move)"},{"location":"src/vector/slice.html#two-args-move","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced = v && sstd :: slice_mv ( 1 , 3 ); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } Execution result v = [\"1\" \"\" \"\" \"4\" \"5\"] v_sliced = [\"2\" \"3\"]","title":"two args (move)"},{"location":"src/vector/slice.html#begin-to-end-move","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced = v && sstd :: slice_mv ( sstd :: begin (), sstd :: end ()); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } Execution result v = [\"\" \"\" \"\" \"\" \"\"] v_sliced = [\"1\" \"2\" \"3\" \"4\" \"5\"]","title":"begin to end (move)"},{"location":"src/vector/slice.html#implementation","text":"Header: sstd/src/vector/slice.hpp Test: test/vector_slice.hpp","title":"Implementation"},{"location":"src/vector/stdVector_expansion.html","text":"Operator expansions for std::vector<T> Abstract Operator definitions on SSTD. These definitions are read by #include <sstd/sstd.hpp> . SSTD \u306b\u304a\u3051\u308b\u6f14\u7b97\u5b50\u306e\u5b9a\u7fa9\uff0e #include <sstd/sstd.hpp> \u306b\u3088\u308a\u5b9a\u7fa9\u304c\u8aad\u307f\u8fbc\u307e\u308c\u308b\uff0e Header file namespace sstd_stdVecEx { // operators for mathematics SSTD_DEF_stdVecEx_defInNamespace ( add ); // + SSTD_DEF_stdVecEx_defInNamespace_eq ( add_eq ); // += SSTD_DEF_stdVecEx_defInNamespace ( sub ); // - SSTD_DEF_stdVecEx_defInNamespace_eq ( sub_eq ); // -= SSTD_DEF_stdVecEx_defInNamespace ( mul ); // * SSTD_DEF_stdVecEx_defInNamespace_eq ( mul_eq ); // *= SSTD_DEF_stdVecEx_defInNamespace ( div ); // / SSTD_DEF_stdVecEx_defInNamespace_eq ( div_eq ); // /= SSTD_DEF_stdVecEx_defInNamespace ( mod ); // % SSTD_DEF_stdVecEx_defInNamespace_eq ( mod_eq ); // %= SSTD_DEF_stdVecEx_defInNamespace ( pow ); // ^ SSTD_DEF_stdVecEx_defInNamespace_eq ( pow_eq ); // ^= // operators for std::vector SSTD_DEF_stdVecEx_defInNamespace ( push_front ); // >> SSTD_DEF_stdVecEx_defInNamespace_eq ( push_front_eq ); // >>= SSTD_DEF_stdVecEx_defInNamespace ( push_back ); // << SSTD_DEF_stdVecEx_defInNamespace_eq ( push_back_eq ); // <<= } Usage Ope. * and *= vector \u00d7 scalar main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 }; sstd :: printn ( v * 2 ); v *= 3 ; sstd :: printn ( v ); } Execution result v * 2 = [2 4 6] v = [3 6 9] vector \u00d7 vector main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { 2 , 3 , 4 }; sstd :: printn ( v1 * v2 ); v1 *= v2 ; sstd :: printn ( v1 ); sstd :: printn ( v2 ); } Execution result v1 * v2 = [2 6 12] v1 = [2 6 12] v2 = [2 3 4] any depth vector \u00d7 scalar main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < std :: vector < int >>> v = {{{ 1 , 2 }, { 3 , 4 }}, {{ 5 , 6 }, { 7 , 8 }}}; sstd :: printn ( v * 2 ); v *= 3 ; sstd :: printn ( v ); } Execution result v * 2 = [[[2 4] [6 8]] [[10 12] [14 16]]] v = [[[3 6] [9 12]] [[15 18] [21 24]]] any depth vector \u00d7 vector main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < std :: vector < int >>> v1 = {{{ 1 , 2 }, { 3 , 4 }}, {{ 5 , 6 }, { 7 , 8 }}}; std :: vector < std :: vector < std :: vector < int >>> v2 = {{{ 9 , 10 }, { 11 , 12 }}, {{ 13 , 14 }, { 15 , 16 }}}; sstd :: printn ( v1 * v2 ); v1 *= v2 ; sstd :: printn ( v1 ); sstd :: printn ( v2 ); } Execution result v1 * v2 = [[[9 20] [33 48]] [[65 84] [105 128]]] v1 = [[[9 20] [33 48]] [[65 84] [105 128]]] v2 = [[[9 10] [11 12]] [[13 14] [15 16]]] Linking << vector << scalar main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 }; int s = 4 ; sstd :: printn ( v << s ); sstd :: printn ( v ); sstd :: printn ( s ); } Execution result v << s = [1 2 3 4] v = [1 2 3] s = 4 vector << vector main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { 4 , 5 , 6 }; sstd :: printn ( v1 << v2 ); sstd :: printn ( v1 ); sstd :: printn ( v2 ); } Execution result v1 << v2 = [1 2 3 4 5 6] v1 = [1 2 3] v2 = [4 5 6] push_back() vector <<= scalar main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v ; v <<= 1 ; // same as a \"v.push_back(1);\" v <<= 2 ; // same as a \"v.push_back(2);\" v <<= 3 ; // same as a \"v.push_back(3);\" sstd :: printn ( v ); } Execution result v = [1 2 3] vector <<= vector main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { 4 , 5 , 6 }; v1 <<= v2 ; sstd :: printn ( v1 ); sstd :: printn ( v2 ); } Execution result v1 = [1 2 3 4 5 6] v2 = [4 5 6] Linking >> vector >> scalar main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 }; int s = 0 ; sstd :: printn ( v >> s ); sstd :: printn ( v ); sstd :: printn ( s ); } Execution result v >> s = [0 1 2 3] v = [1 2 3] s = 0 vector >> vector main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { -2 , -1 , 0 }; sstd :: printn ( v1 >> v2 ); sstd :: printn ( v1 ); sstd :: printn ( v2 ); } Execution result v1 >> v2 = [-2 -1 0 1 2 3] v1 = [1 2 3] v2 = [-2 -1 0] push_front() vector >>= scalar main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 }; v >>= 0 ; sstd :: printn ( v ); } Execution result v = [0 1 2 3] vector >>= vector main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { -2 , -1 , 0 }; v1 >>= v2 ; sstd :: printn ( v1 ); sstd :: printn ( v2 ); } Execution result v1 = [-2 -1 0 1 2 3] v2 = [-2 -1 0] Implementation Header: sstd/src/vector/stdVector_expansion.hpp Test: test/vector_stdVector_expansion.hpp","title":"Ope. Exp. for std::vector&lt;T&gt;"},{"location":"src/vector/stdVector_expansion.html#operator-expansions-for-stdvectort","text":"","title":"Operator expansions for std::vector&lt;T&gt;"},{"location":"src/vector/stdVector_expansion.html#abstract","text":"Operator definitions on SSTD. These definitions are read by #include <sstd/sstd.hpp> . SSTD \u306b\u304a\u3051\u308b\u6f14\u7b97\u5b50\u306e\u5b9a\u7fa9\uff0e #include <sstd/sstd.hpp> \u306b\u3088\u308a\u5b9a\u7fa9\u304c\u8aad\u307f\u8fbc\u307e\u308c\u308b\uff0e","title":"Abstract"},{"location":"src/vector/stdVector_expansion.html#header-file","text":"namespace sstd_stdVecEx { // operators for mathematics SSTD_DEF_stdVecEx_defInNamespace ( add ); // + SSTD_DEF_stdVecEx_defInNamespace_eq ( add_eq ); // += SSTD_DEF_stdVecEx_defInNamespace ( sub ); // - SSTD_DEF_stdVecEx_defInNamespace_eq ( sub_eq ); // -= SSTD_DEF_stdVecEx_defInNamespace ( mul ); // * SSTD_DEF_stdVecEx_defInNamespace_eq ( mul_eq ); // *= SSTD_DEF_stdVecEx_defInNamespace ( div ); // / SSTD_DEF_stdVecEx_defInNamespace_eq ( div_eq ); // /= SSTD_DEF_stdVecEx_defInNamespace ( mod ); // % SSTD_DEF_stdVecEx_defInNamespace_eq ( mod_eq ); // %= SSTD_DEF_stdVecEx_defInNamespace ( pow ); // ^ SSTD_DEF_stdVecEx_defInNamespace_eq ( pow_eq ); // ^= // operators for std::vector SSTD_DEF_stdVecEx_defInNamespace ( push_front ); // >> SSTD_DEF_stdVecEx_defInNamespace_eq ( push_front_eq ); // >>= SSTD_DEF_stdVecEx_defInNamespace ( push_back ); // << SSTD_DEF_stdVecEx_defInNamespace_eq ( push_back_eq ); // <<= }","title":"Header file"},{"location":"src/vector/stdVector_expansion.html#usage","text":"","title":"Usage"},{"location":"src/vector/stdVector_expansion.html#ope-and","text":"","title":"Ope. * and *="},{"location":"src/vector/stdVector_expansion.html#vector-scalar","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 }; sstd :: printn ( v * 2 ); v *= 3 ; sstd :: printn ( v ); } Execution result v * 2 = [2 4 6] v = [3 6 9]","title":"vector \u00d7 scalar"},{"location":"src/vector/stdVector_expansion.html#vector-vector","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { 2 , 3 , 4 }; sstd :: printn ( v1 * v2 ); v1 *= v2 ; sstd :: printn ( v1 ); sstd :: printn ( v2 ); } Execution result v1 * v2 = [2 6 12] v1 = [2 6 12] v2 = [2 3 4]","title":"vector \u00d7 vector"},{"location":"src/vector/stdVector_expansion.html#any-depth-vector-scalar","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < std :: vector < int >>> v = {{{ 1 , 2 }, { 3 , 4 }}, {{ 5 , 6 }, { 7 , 8 }}}; sstd :: printn ( v * 2 ); v *= 3 ; sstd :: printn ( v ); } Execution result v * 2 = [[[2 4] [6 8]] [[10 12] [14 16]]] v = [[[3 6] [9 12]] [[15 18] [21 24]]]","title":"any depth vector \u00d7 scalar"},{"location":"src/vector/stdVector_expansion.html#any-depth-vector-vector","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < std :: vector < int >>> v1 = {{{ 1 , 2 }, { 3 , 4 }}, {{ 5 , 6 }, { 7 , 8 }}}; std :: vector < std :: vector < std :: vector < int >>> v2 = {{{ 9 , 10 }, { 11 , 12 }}, {{ 13 , 14 }, { 15 , 16 }}}; sstd :: printn ( v1 * v2 ); v1 *= v2 ; sstd :: printn ( v1 ); sstd :: printn ( v2 ); } Execution result v1 * v2 = [[[9 20] [33 48]] [[65 84] [105 128]]] v1 = [[[9 20] [33 48]] [[65 84] [105 128]]] v2 = [[[9 10] [11 12]] [[13 14] [15 16]]]","title":"any depth vector \u00d7 vector"},{"location":"src/vector/stdVector_expansion.html#linking","text":"","title":"Linking &lt;&lt;"},{"location":"src/vector/stdVector_expansion.html#vector-scalar_1","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 }; int s = 4 ; sstd :: printn ( v << s ); sstd :: printn ( v ); sstd :: printn ( s ); } Execution result v << s = [1 2 3 4] v = [1 2 3] s = 4","title":"vector &lt;&lt; scalar"},{"location":"src/vector/stdVector_expansion.html#vector-vector_1","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { 4 , 5 , 6 }; sstd :: printn ( v1 << v2 ); sstd :: printn ( v1 ); sstd :: printn ( v2 ); } Execution result v1 << v2 = [1 2 3 4 5 6] v1 = [1 2 3] v2 = [4 5 6]","title":"vector &lt;&lt; vector"},{"location":"src/vector/stdVector_expansion.html#push_back","text":"","title":"push_back()"},{"location":"src/vector/stdVector_expansion.html#vector-scalar_2","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v ; v <<= 1 ; // same as a \"v.push_back(1);\" v <<= 2 ; // same as a \"v.push_back(2);\" v <<= 3 ; // same as a \"v.push_back(3);\" sstd :: printn ( v ); } Execution result v = [1 2 3]","title":"vector &lt;&lt;= scalar"},{"location":"src/vector/stdVector_expansion.html#vector-vector_2","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { 4 , 5 , 6 }; v1 <<= v2 ; sstd :: printn ( v1 ); sstd :: printn ( v2 ); } Execution result v1 = [1 2 3 4 5 6] v2 = [4 5 6]","title":"vector &lt;&lt;= vector"},{"location":"src/vector/stdVector_expansion.html#linking_1","text":"","title":"Linking &gt;&gt;"},{"location":"src/vector/stdVector_expansion.html#vector-scalar_3","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 }; int s = 0 ; sstd :: printn ( v >> s ); sstd :: printn ( v ); sstd :: printn ( s ); } Execution result v >> s = [0 1 2 3] v = [1 2 3] s = 0","title":"vector &gt;&gt; scalar"},{"location":"src/vector/stdVector_expansion.html#vector-vector_3","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { -2 , -1 , 0 }; sstd :: printn ( v1 >> v2 ); sstd :: printn ( v1 ); sstd :: printn ( v2 ); } Execution result v1 >> v2 = [-2 -1 0 1 2 3] v1 = [1 2 3] v2 = [-2 -1 0]","title":"vector &gt;&gt; vector"},{"location":"src/vector/stdVector_expansion.html#push_front","text":"","title":"push_front()"},{"location":"src/vector/stdVector_expansion.html#vector-scalar_4","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 }; v >>= 0 ; sstd :: printn ( v ); } Execution result v = [0 1 2 3]","title":"vector &gt;&gt;= scalar"},{"location":"src/vector/stdVector_expansion.html#vector-vector_4","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { -2 , -1 , 0 }; v1 >>= v2 ; sstd :: printn ( v1 ); sstd :: printn ( v2 ); } Execution result v1 = [-2 -1 0 1 2 3] v2 = [-2 -1 0]","title":"vector &gt;&gt;= vector"},{"location":"src/vector/stdVector_expansion.html#implementation","text":"Header: sstd/src/vector/stdVector_expansion.hpp Test: test/vector_stdVector_expansion.hpp","title":"Implementation"},{"location":"src/vector/vec_vvec.html","text":"vec / vvec Abstract Type definitions on SSTD. These definitions are read by #include <sstd/sstd.hpp> . SSTD \u306b\u304a\u3051\u308b\u578b\u306e\u5b9a\u7fa9\uff0e #include <sstd/sstd.hpp> \u306b\u3088\u308a\u5b9a\u7fa9\u304c\u8aad\u307f\u8fbc\u307e\u308c\u308b\uff0e Header file namespace sstd { template < class T > using vec = std :: vector < T > ; template < class T > using vvec = std :: vector < std :: vector < T >> ; } Usage main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: vec < int > v = { 1 , 2 , 3 }; // same as a \"std::vector<int> v = {1, 2, 3};\" sstd :: printn ( v ); sstd :: vvec < int > vv = {{ 1 , 2 , 3 }, { 4 , 5 , 6 }}; // same as a \"std::vector<vector<int>> vv = {{1, 2, 3}, {4, 5, 6}};\" sstd :: printn ( vv ); } Execution result v = [1 2 3] vv = [[1 2 3] [4 5 6]] Implementation Header: sstd/src/vector/typeDef.hpp Test: test/vector/typeDef.hpp (Not implemented yet)","title":"vec / vvec"},{"location":"src/vector/vec_vvec.html#vec-vvec","text":"","title":"vec / vvec"},{"location":"src/vector/vec_vvec.html#abstract","text":"Type definitions on SSTD. These definitions are read by #include <sstd/sstd.hpp> . SSTD \u306b\u304a\u3051\u308b\u578b\u306e\u5b9a\u7fa9\uff0e #include <sstd/sstd.hpp> \u306b\u3088\u308a\u5b9a\u7fa9\u304c\u8aad\u307f\u8fbc\u307e\u308c\u308b\uff0e","title":"Abstract"},{"location":"src/vector/vec_vvec.html#header-file","text":"namespace sstd { template < class T > using vec = std :: vector < T > ; template < class T > using vvec = std :: vector < std :: vector < T >> ; }","title":"Header file"},{"location":"src/vector/vec_vvec.html#usage","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: vec < int > v = { 1 , 2 , 3 }; // same as a \"std::vector<int> v = {1, 2, 3};\" sstd :: printn ( v ); sstd :: vvec < int > vv = {{ 1 , 2 , 3 }, { 4 , 5 , 6 }}; // same as a \"std::vector<vector<int>> vv = {{1, 2, 3}, {4, 5, 6}};\" sstd :: printn ( vv ); } Execution result v = [1 2 3] vv = [[1 2 3] [4 5 6]]","title":"Usage"},{"location":"src/vector/vec_vvec.html#implementation","text":"Header: sstd/src/vector/typeDef.hpp Test: test/vector/typeDef.hpp (Not implemented yet)","title":"Implementation"}]}
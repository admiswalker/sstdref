{"config":{"indexing":"full","lang":["en","ja"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":".img_overlay { /* parent div */ position: relative; } .img_overlay p { position: absolute; font-size: 40px; font-weight: normal; color: white; /* string color */ top: 0; left: 0; margin:0; padding:0; margin-top:-5px; } .img_overlay img { width: 100%; } SubStandardLibrary What is SSTD ? SubStandardLibrary (SSTD) is a convenient functions-set for the C++ which the author wished that the standard library has these convenient functions. This library works on the GCC (g++) on the Ubuntu OS. SubStandardLibrary (SSTD) \u306f\uff0c\u8457\u8005\u304c\u6a19\u6e96\u30e9\u30a4\u30d6\u30e9\u30ea\u306b\u3042\u3063\u3066\u6b32\u3057\u304b\u3063\u305f\u3068\u601d\u3046\u4fbf\u5229\u306a\u95a2\u6570\u7fa4\u3092\u53ce\u9332\u3057\u305f C++ \u5411\u3051\u306e\u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u3059\uff0eUbuntu OS \u4e0a\u306e GCC (g++) \u3067\u52d5\u4f5c\u3057\u307e\u3059\uff0e Installation Downloading source code from github.com/admiswalker/SubStandardLibrary . \u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3092 github.com/admiswalker/SubStandardLibrary \u304b\u3089\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9\u3057\u307e\u3059\uff0e Copying the ./sstd directory to the project directory ./sstd \u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u5bfe\u8c61\u306e\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u4e0b\u3078\u30b3\u30d4\u30fc\u3057\u307e\u3059\uff0e Compilling the sstd according to the commands below. \u4e0b\u8a18\u306e\u30b3\u30de\u30f3\u30c9\u306b\u5f93\u3044 sstd \u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u3057\u307e\u3059\uff0e $ cd ./sstd $ make Adding paths to the sstd as a compilation option in the makefile using sstd. sstd \u3078\u306e\u30d1\u30b9\u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u30aa\u30d7\u30b7\u30e7\u30f3\u3068\u3057\u3066 makefile \u306b\u8ffd\u52a0\u3057\u307e\u3059\uff0e CFLAGS += -I./sstd/include -L./sstd/lib -lsstd CFLAGS += -std=gnu++0x Including the #include <sstd/sstd.hpp> header in your code. #include <sstd/sstd.hpp> \u30d8\u30c3\u30c0\u3092\u30b3\u30fc\u30c9\u304b\u3089\u8aad\u307f\u8fbc\u307f\u307e\u3059\uff0e License MIT licence or Public domain. (This software is dual license, so you can choose whichever you want). MIT licence \u307e\u305f\u306f\u30d1\u30d6\u30ea\u30c3\u30af\u30c9\u30e1\u30a4\u30f3\uff0e\uff08\u3053\u306e\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u306f\u30c7\u30e5\u30a2\u30eb\u30e9\u30a4\u30bb\u30f3\u30b9\u306e\u305f\u3081\uff0c\u597d\u304d\u306a\u65b9\u3092\u9078\u3093\u3067\u3088\u3044\uff09\uff0e Repository Source code: github.com/admiswalker/SubStandardLibrary Documentation: github.com/admiswalker/sstdref","title":"What is SSTD ?"},{"location":"index.html#what-is-sstd","text":"SubStandardLibrary (SSTD) is a convenient functions-set for the C++ which the author wished that the standard library has these convenient functions. This library works on the GCC (g++) on the Ubuntu OS. SubStandardLibrary (SSTD) \u306f\uff0c\u8457\u8005\u304c\u6a19\u6e96\u30e9\u30a4\u30d6\u30e9\u30ea\u306b\u3042\u3063\u3066\u6b32\u3057\u304b\u3063\u305f\u3068\u601d\u3046\u4fbf\u5229\u306a\u95a2\u6570\u7fa4\u3092\u53ce\u9332\u3057\u305f C++ \u5411\u3051\u306e\u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u3059\uff0eUbuntu OS \u4e0a\u306e GCC (g++) \u3067\u52d5\u4f5c\u3057\u307e\u3059\uff0e","title":"What is SSTD ?"},{"location":"index.html#installation","text":"Downloading source code from github.com/admiswalker/SubStandardLibrary . \u30bd\u30fc\u30b9\u30b3\u30fc\u30c9\u3092 github.com/admiswalker/SubStandardLibrary \u304b\u3089\u30c0\u30a6\u30f3\u30ed\u30fc\u30c9\u3057\u307e\u3059\uff0e Copying the ./sstd directory to the project directory ./sstd \u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u5bfe\u8c61\u306e\u30d7\u30ed\u30b8\u30a7\u30af\u30c8\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u4e0b\u3078\u30b3\u30d4\u30fc\u3057\u307e\u3059\uff0e Compilling the sstd according to the commands below. \u4e0b\u8a18\u306e\u30b3\u30de\u30f3\u30c9\u306b\u5f93\u3044 sstd \u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u3057\u307e\u3059\uff0e $ cd ./sstd $ make Adding paths to the sstd as a compilation option in the makefile using sstd. sstd \u3078\u306e\u30d1\u30b9\u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u30aa\u30d7\u30b7\u30e7\u30f3\u3068\u3057\u3066 makefile \u306b\u8ffd\u52a0\u3057\u307e\u3059\uff0e CFLAGS += -I./sstd/include -L./sstd/lib -lsstd CFLAGS += -std=gnu++0x Including the #include <sstd/sstd.hpp> header in your code. #include <sstd/sstd.hpp> \u30d8\u30c3\u30c0\u3092\u30b3\u30fc\u30c9\u304b\u3089\u8aad\u307f\u8fbc\u307f\u307e\u3059\uff0e","title":"Installation"},{"location":"index.html#license","text":"MIT licence or Public domain. (This software is dual license, so you can choose whichever you want). MIT licence \u307e\u305f\u306f\u30d1\u30d6\u30ea\u30c3\u30af\u30c9\u30e1\u30a4\u30f3\uff0e\uff08\u3053\u306e\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u306f\u30c7\u30e5\u30a2\u30eb\u30e9\u30a4\u30bb\u30f3\u30b9\u306e\u305f\u3081\uff0c\u597d\u304d\u306a\u65b9\u3092\u9078\u3093\u3067\u3088\u3044\uff09\uff0e","title":"License"},{"location":"index.html#repository","text":"Source code: github.com/admiswalker/SubStandardLibrary Documentation: github.com/admiswalker/sstdref","title":"Repository"},{"location":"src/c2py.html","text":"c2py Abstract c2py() calls any Python functions with built-in, std::vector<T> , sstd::mat_c<T> and sstd::mat_r<T> ( T is limited by built-in types.) types of arguments from 2 lines of C++ codes. Data is sharing by the tmp directory. c2py() \u306f built-in \u578b\uff0c std::vector<T> \u578b, sstd::mat_c<T> \u578b\uff0c\u304a\u3088\u3073 sstd::mat_r<T> \u578b (\u305f\u3060\u3057\uff0c T \u306f built-in \u578b\u306b\u5236\u9650\u3055\u308c\u308b\uff0e) \u3092\u5f15\u6570\u306b\u6301\u3064 Python \u95a2\u6570\u3092 2 \u884c\u306e C++ \u30b3\u30fc\u30c9\u3067\u547c\u3073\u51fa\u3057\u307e\u3059\uff0e \u30c7\u30fc\u30bf\u306f tmp \u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306b\u3088\u308a\u5171\u6709\u3055\u308c\u307e\u3059\uff0e Header file namespace sstd { template < typename T > class c2py ; } template < typename T > class sstd :: c2py { public : c2py ( const char * temporarilyDir , const char * importFile , const char * functionName , const char * format ); ~ c2py (); template < typename ... ARGS > T operator ()( ARGS ... args ); }; c2py interface sstd :: c2py < ATypeOfReturnValue > FunctionName ( \"Tempolary directory\" , // Argument 1 \"A name of calling .py file (without extension)\" , // Argument 2 \"A function name calling from .py file\" , // Argument 3 \"Arguments types specification of Python function\" ); // Argument 4 c2py \u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u306e\u8a2d\u8a08 sstd :: c2py < \u623b\u308a\u5024\u306e\u578b > \u95a2\u6570\u540d ( \"\u4e00\u6642\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\" , // \u7b2c 1 \u5f15\u6570 \"\u547c\u3073\u51fa\u3057\u5148\u306e .py \u30d5\u30a1\u30a4\u30eb (\u305f\u3060\u3057\u62e1\u5f35\u5b50\u3092\u9664\u304f)\" , // \u7b2c 2 \u5f15\u6570 \".py \u30d5\u30a1\u30a4\u30eb\u4e2d\u304b\u3089\u547c\u3073\u51fa\u3059\u95a2\u6570\u540d\" , // \u7b2c 3 \u5f15\u6570 \"Python \u95a2\u6570\u306e\u578b\u6307\u5b9a\" ); // \u7b2c 4 \u5f15\u6570 Requirements c2py() requires the importlib , inspect , itertools , numpy , os and sys Python packages. See sstd/src/c2py.py for details. c2py() \u306f\uff0c importlib , inspect , itertools , numpy , os , sys \u306e Python \u30d1\u30c3\u30b1\u30fc\u30b8\u3092\u5fc5\u8981\u3068\u3057\u307e\u3059\uff0e\u8a73\u7d30\u306f sstd/src/c2py.py \u3092\u53c2\u7167\u3059\u308b\u3053\u3068\uff0e List of corresponding types. (\u5bfe\u5fdc\u3059\u308b\u578b\u306e\u4e00\u89a7) Table 1. shows the correspondence between the types on the C ++ side and the types on the Python side. Table 2. shows a list of type names given when specifying a type on the C ++ side. If not specifying type on the Python side, numpy will be selected. And selecting the conversion symbol ~ , the numpy type will be converted to the built-in type. The c2py is basically processed by numpy, because of the binary compatibility between C++ and Python, type conversion of numpy to built-in type will be overhead. \u8868 1. \u306b C++ \u5074\u306e\u578b\u3068\uff0cPython \u5074\u306e\u578b\u3068\u306e\u5bfe\u5fdc\u3092\u793a\u3059\uff0e \u8868 2. \u306b C++ \u5074\u306e\u578b\u3092\u6307\u5b9a\u3059\u308b\u969b\u306b\u4e0e\u3048\u308b\u578b\u540d\u306e\u4e00\u89a7\u3092\u793a\u3059\uff0e Python \u5074\u306e\u578b\u306b\u3064\u3044\u3066\uff0c\u4f55\u3082\u6307\u5b9a\u3057\u306a\u3044\u5834\u5408\u306f\uff0cnumpy \u578b\u304c\u9078\u629e\u3055\u308c\uff0c\u5909\u63db\u8a18\u53f7 ~ \u3092\u6307\u5b9a\u3059\u308b\u3053\u3068\u3067\uff0cbuilt-in \u578b\u306b\u5909\u63db\u3055\u308c\u308b\uff0e c2py \u4e0a\u306e\u51e6\u7406\u306f\uff0cC++ \u3068\u306e\u30d0\u30a4\u30ca\u30ea\u4e92\u63db\u6027\u306e\u554f\u984c\u304b\u3089\uff0c\u57fa\u672c\u7684\u306b numpy \u578b\u3067\u884c\u308f\u308c\u308b\u305f\u3081\uff0cbuilt-in \u578b\u3078\u306e\u5909\u63db\u306f\uff0c\u30aa\u30fc\u30d0\u30fc\u30d8\u30c3\u30c9\u3068\u306a\u308b\uff0e Table 1. Correspondence between types implemented in c2py and Python \u8868 1. c2py \u3067\u5b9f\u88c5\u3055\u308c\u3066\u3044\u308b\u578b\u3068 Python \u578b\u3068\u306e\u5bfe\u5fdc Types of C++ side Types of Python side Entity / Pointer / Pointer array Entity / Pointer Entity / Pointer Entity / Pointer Entity / Pointer bool std::vector<bool> sstd::mat_c<bool> sstd::mat_r<bool> numpy / built-in char std::vector<char> sstd::mat_c<char> sstd::mat_r<char> built-in uchar std::vector<uchar> sstd::mat_c<uchar> sstd::mat_r<uchar> built-in int8 std::vector<int8> sstd::mat_c<int8> sstd::mat_r<int8> numpy / built-in int16 std::vector<int16> sstd::mat_c<int16> sstd::mat_r<int16> numpy / built-in int32 std::vector<int32> sstd::mat_c<int32> sstd::mat_r<int32> numpy / built-in int64 std::vector<int64> sstd::mat_c<int64> sstd::mat_r<int64> numpy / built-in uint8 std::vector<uint8> sstd::mat_c<uint8> sstd::mat_r<uint8> numpy / built-in uint16 std::vector<uint16> sstd::mat_c<uint16> sstd::mat_r<uint16> numpy / built-in uint32 std::vector<uint32> sstd::mat_c<uint32> sstd::mat_r<uint32> numpy / built-in uint64 std::vector<uint64> sstd::mat_c<uint64> sstd::mat_r<uint64> numpy / built-in float std::vector<float> sstd::mat_c<float> sstd::mat_r<float> numpy / built-in double std::vector<double> sstd::mat_c<double> sstd::mat_r<double> numpy / built-in std::string std::vector<std::string> sstd::mat_c<std::string> sstd::mat_r<std::string> built-in Table 2. Type names giving to the 4th argument of c2py. \u8868 2. c2py \u306e\u7b2c 4 \u5f15\u6570\u306b\u4e0e\u3048\u308b\u578b\u540d\uff0e Types of C++ side Entity / Pointer / Pointer array Entity / Pointer Entity / Pointer Entity / Pointer bool vec<bool> mat_c<bool> mat_r<bool> char vec<char> mat_c<char> mat_r<char> uchar vec<uchar> mat_c<uchar> mat_r<uchar> int8 vec<int8> mat_c<int8> mat_r<int8> int16 vec<int16> mat_c<int16> mat_r<int16> int32 vec<int32> mat_c<int32> mat_r<int32> int64 vec<int64> mat_c<int64> mat_r<int64> uint8 vec<uint8> mat_c<uint8> mat_r<uint8> uint16 vec<uint16> mat_c<uint16> mat_r<uint16> uint32 vec<uint32> mat_c<uint32> mat_r<uint32> uint64 vec<uint64> mat_c<uint64> mat_r<uint64> float vec<float> mat_c<float> mat_r<float> double vec<double> mat_c<double> mat_r<double> str / string vec<str> / vec<string> mat_c<str> / mat_c<string> mat_r<str> / mat_r<string> Usage Sample1: (Return: \"int\" / Input: \"int\" and \"const int*\") pyFunction.py def plus_a_b ( a , b ): return a + b main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"echo 'def plus_a_b(a, b): return a+b' > ./tmp/pyFunction.py\" ); sstd :: c2py < int > plus_a_b ( \"./tmpDir\" , \"./tmp/pyFunction\" , \"plus_a_b\" , \"int, int, const int*\" ); int a = 1 , b = 2 ; int c = plus_a_b ( a , & b ); // Running Python here sstd :: printn ( c ); sstd :: rm ( \"./tmp\" ); return 0 ; } Execution result c = 3 Sample2: (Return: \"vec<int>\" / Input: \"const int*\", \"len\" and \"const vec<int>*\") pyFunction.py def plus_vecA_vecB ( vecA , vecB ): return vecA + vecB main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"echo 'def plus_vecA_vecB(vecA, vecB): return vecA+vecB' > ./tmp/pyFunction.py\" ); sstd :: c2py < std :: vector < int >> plus_vecA_vecB ( \"./tmpDir\" , \"./tmp/pyFunction\" , \"plus_vecA_vecB\" , \"vec<int>, const int*, len, const vec<int>*\" ); int arrA [] = { 1 , 2 , 3 }; std :: vector < int > vecB = { 4 , 5 , 6 }; std :: vector < int > vecC = plus_vecA_vecB ( arrA , 3 , & vecB ); // Running Python here sstd :: printn ( vecC ); sstd :: rm ( \"./tmp\" ); return 0 ; } Execution result vecC = [5 7 9] Sample3: (Return: \"void\" / Input: \"int*\", \"int*\", \"len\" and \"vec<int>*\") Writing back self multiplied value. \u81ea\u5df1\u4e57\u7b97\u5024\u3092\u66f8\u304d\u623b\u3059\uff0e pyFunction.py def selfMult ( a , vecB , vecC ): a [ 0 ] = a [ 0 ] * a [ 0 ] for i in range ( len ( vecB )): vecB [ i ] = vecB [ i ] * vecB [ i ] for i in range ( len ( vecC )): vecC [ i ] = vecC [ i ] * vecC [ i ] main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"echo 'def selfMult(a, vecB, vecC): \\n a[0]=a[0]*a[0] \\n for i in range(len(vecB)): vecB[i]=vecB[i]*vecB[i] \\n for i in range(len(vecC)): vecC[i]=vecC[i]*vecC[i]' > ./tmp/pyFunction.py\" ); sstd :: c2py < void > selfMult ( \"./tmpDir\" , \"./tmp/pyFunction\" , \"selfMult\" , \"void, int*, int*, len, vec<int>*\" ); int a = 2 ; int arrB [] = { 3 , 4 , 5 }; std :: vector < int > vecC = { 6 , 7 , 8 }; selfMult ( & a , arrB , 3 , & vecC ); sstd :: printn ( a ); printf ( \"arrB[3] = [ \" ); for ( uint i = 0 ; i < 3 ; i ++ ){ printf ( \"%d \" , arrB [ i ]); } printf ( \"] \\n \" ); sstd :: printn ( vecC ); sstd :: rm ( \"./tmp\" ); return 0 ; } Execution result a = 4 arrB[3] = [ 9 16 25 ] vecC = [36 49 64] Sample4: Types conversion of numpy to built-in Conversion types in Python side. Symbols on the right side of \"|\" (which is a separator symbol between C++ and Python) mean the symbols have effect on the Python side. On the right side of \"|\" enable to take \" \" or \"~\" and these order have no meaning. (There is no difference between \"| ~\" and \"|~*\", so it will work same.) *: A symbol have a meaning to convert input value on Python side to a pseudo pointer type (self inclusion list). ~: A symbol have a meaning to convert input value on Python side to a built-in type (instead of numpy type). Python \u5074\u3067\u578b\u5909\u63db\u3092\u884c\u3046\u5834\u5408\uff0e\u30bb\u30d1\u30ec\u30fc\u30bf\u8a18\u53f7 \"|\" \u306e\u5de6\u53f3\u306f\uff0c\u305d\u308c\u305e\u308c\uff0cC++ \u5074\u3068 Python \u5074\u3092\u8868\u3057\u3066\u3044\u308b\uff0e\u5206\u5272\u8a18\u53f7 \"|\" \u306e\u53f3\u5074\u306e\u578b\u306f \" \" \u307e\u305f\u306f \"~\" \u3092\u53d6\u308b\u3053\u3068\u304c\u3067\u304d\uff0c\u3053\u308c\u306f Python \u5074\u306b\u304a\u3051\u308b\u5909\u63db\u8a18\u53f7\u3067\u3042\u308b\uff0e\u3053\u306e\u3068\u304d\uff0c\u5909\u63db\u8a18\u53f7 \" \"\uff0c\"~\" \u306e\u9806\u5e8f\u306f\u610f\u5473\u3092\u306a\u3055\u306a\u3044\uff0e(\u3057\u305f\u304c\u3063\u3066\uff0c \"| ~\" \u3068 \"|~ \" \u306e\u9593\u306b\u5dee\u306f\u306a\u304f\uff0c\u540c\u3058\u3088\u3046\u306b\u52d5\u4f5c\u3059\u308b\uff0e) *: Python \u5074\u306e\u5165\u529b\u5024\u3092\u64ec\u4f3c\u30dd\u30a4\u30f3\u30bf\u578b (\u81ea\u5df1\u5305\u542b\u30ea\u30b9\u30c8) \u3078\u5909\u63db\u3059\u308b\uff0e ~: Python \u5074\u306e\u5165\u529b\u5024\u3092\uff08numpy \u578b\u306e\u4ee3\u308f\u308a\u306b\uff09\u7d44\u307f\u8fbc\u307f\u578b\u306b\u5909\u63db\u3059\u308b\uff0e pyFunction.py def checkTypes ( Numpy , builtIn , pNumpy , pBuiltIn ): print ( type ( Numpy ), Numpy ) print ( type ( builtIn ), builtIn ) print ( type ( pNumpy ), pNumpy ) print ( type ( pBuiltIn ), pBuiltIn ) main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"echo 'def checkTypes(Numpy, builtIn, pNumpy, pBuiltIn): \\n print(type(Numpy), Numpy) \\n print(type(builtIn), builtIn) \\n print(type(pNumpy), pNumpy) \\n print(type(pBuiltIn), pBuiltIn)' > ./tmp/pyFunction.py\" ); sstd :: c2py < void > checkTypes ( \"./tmpDir\" , \"./tmp/pyFunction\" , \"checkTypes\" , \"void, int, int|~, int|*, int|*~\" ); checkTypes ( 0 , 0 , 0 , 0 ); sstd :: rm ( \"./tmp\" ); return 0 ; } Execution result <class 'numpy.ndarray'> [0] <class 'list'> [0] <class 'list'> [array([0], dtype=int32)] <class 'list'> [[0]] Sample5: Writing back with changing the length of std::vector<T> Writing back with changing the length of std::vector<T> . (In order to get value from function, sending address is needed.) \u914d\u5217\u9577\u306e\u5909\u5316\u3092\u542b\u3080 std::vector<T> \u306e\u66f8\u304d\u623b\u3057\uff0e(\u95a2\u6570\u304b\u3089\u5024\u3092\u53d7\u3051\u53d6\u308b\u305f\u3081\uff0c\u30a2\u30c9\u30ec\u30b9\u3092\u53d7\u3051\u6e21\u3057\u3066\u3044\u308b) pyFunction.py import numpy as np def changeLen ( pVec1 , vec2 ): pVec1 [ 0 ] = np . append ( pVec1 [ 0 ], 4 ) # numpy # numpy is not able to add values without changing address of variables. so we need to treat as a pointer like objects (self inclusion list). vec2 . append ( 4 ) # built-in main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"echo 'import numpy as np \\n def changeLen(pVec1, vec2): \\n pVec1[0]=np.append(pVec1[0], 4) \\n vec2.append(4)' > ./tmp/pyFunction.py\" ); sstd :: c2py < void > changeLen ( \"./tmpDir\" , \"./tmp/pyFunction\" , \"changeLen\" , \"void, vec<int>*|*, vec<int>*|~\" ); std :: vector < int > vec1 = { 1 , 2 , 3 }, vec2 = { 1 , 2 , 3 }; changeLen ( & vec1 , & vec2 ); sstd :: printn ( vec1 ); sstd :: printn ( vec2 ); sstd :: rm ( \"./tmp\" ); return 0 ; } Execution result vec1 = [1 2 3 4] vec2 = [1 2 3 4] Sample6 Receiving multiple return values from python side. (\u203b \"ret\" which is a symbol of return value, must be continuous in arg 4. Interrupted ret occurs error.) Python \u5074\u304b\u3089\u8907\u6570\u306e\u623b\u308a\u5024\u3092\u53d7\u3051\u53d6\u308b\uff0e(\u203b \u623b\u308a\u5024\u8a18\u53f7 \"ret\" \u306f\uff0c\u7b2c 4 \u5f15\u6570\u4e2d\u3067\u9023\u7d9a\u3057\u3066\u3044\u308b\u5fc5\u8981\u304c\u3042\u308b\uff0e\u4e0d\u9023\u7d9a\u306a ret \u306f\u30a8\u30e9\u30fc\u3092\u5f15\u304d\u8d77\u3053\u3059\uff0e) pyFunction.py def multiRet (): return ( 9 , 9 , [ 1 , 2 , 3 ], [ 4 , 5 , 6 ]) main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"echo 'def multiRet(): return (9, 9, [1,2,3], [4,5,6])' > ./tmp/pyFunction.py\" ); sstd :: c2py < int > multiRet ( \"./tmpDir\" , \"./tmp/pyFunction\" , \"multiRet\" , \"int, ret int*, ret int*, len, ret vec<int>*\" ); int ret0 = 0 ; int ret1 = 0 ; int ret2 [] = { 0 , 0 , 0 }; std :: vector < int > ret3 ; ret0 = multiRet ( & ret1 , & ret2 , 3 , & ret3 ); sstd :: printn ( ret0 ); sstd :: printn ( ret1 ); printf ( \"ret2[3] = [ \" ); for ( uint i = 0 ; i < 3 ; i ++ ){ printf ( \"%d \" , ret2 [ i ]); } printf ( \"] \\n \" ); sstd :: printn ( ret3 ); sstd :: rm ( \"./tmp\" ); return 0 ; } Execution result ret0 = 9 ret1 = 9 ret2[3] = [ 1 2 3 ] ret3 = [4 5 6] Appendix Application sample 1 As one of the most convenient application, c2py enable to call matplotlib which is a famous graph plot library in python from C++. In the code below, generate sin wave on C++ and write graph by matplotlib in Python. \u6700\u3082\u4fbf\u5229\u306a\u5fdc\u7528\u306e 1 \u3064\u3068\u3057\u3066\uff0cc2py \u3067\u306f\uff0cPython \u3067\u6709\u540d\u306a\u30b0\u30e9\u30d5\u30d7\u30ed\u30c3\u30c8\u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u3042\u308b matplotlib \u3092 C++ \u304b\u3089\u547c\u3073\u51fa\u3059\u3053\u3068\u304c\u3067\u304d\u308b\uff0e\u4e0b\u8a18\u306e\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u3067\u306f\uff0cC++ \u5074\u3067\u751f\u6210\u3057\u305f sin \u6ce2\u3092\uff0cPython \u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u3042\u308b matplotlib \u3067\u63cf\u753b\u3057\u3066\u3044\u308b\uff0e pyFunction.py import matplotlib as mpl # \"QXcbConnection: Could not connect to display\" \u3078\u306e\u5bfe\u7b56 mpl . use ( 'Agg' ) # \"QXcbConnection: Could not connect to display\" \u3078\u306e\u5bfe\u7b56 import matplotlib.pyplot as plt # \"QXcbConnection: Could not connect to display\" \u3078\u306e\u5bfe\u7b56 import matplotlib.ticker as tick def vec2graph ( writeName , vecX , vecY ): plt . clf () fig = plt . figure ( figsize = ( 9 , 3 )) # \u30a2\u30b9\u30da\u30af\u30c8\u6bd4\u306e\u8a2d\u5b9a ax1 = fig . add_subplot ( 111 ) ax1 . plot ( vecX , vecY , color = 'k' , linewidth = 0.5 ) title = \"An example of Plotting a figure of sin wave data generated on C++, \\n \" title += \"using matplotlib which is a famous graph plotting library of python. \\n \" title += \" \\\" sstd::c2py() \\\" convertes a type of std::vector<double> on C++ to \\n \" title += \"numpy array type on Python, and calling a Python function from \\n \" title += \"only 2 lines of C++ code. \" ax1 . set_title ( title ) ax1 . grid ( which = 'minor' , linewidth = 0.5 , linestyle = ':' , color = 'gainsboro' ) ax1 . grid ( which = 'major' , linewidth = 0.5 , linestyle = '-' , color = 'silver' ) ax1 . tick_params ( pad = 5 , which = 'major' , direction = 'in' , bottom = True , top = True , left = True , right = True , length = 4 ) # \u8ef8\u306e\u4f59\u767d # which: major tick \u3068 minor tick \u306b\u5bfe\u3057\u3066\u5909\u66f4\u3092\u9069\u7528 # tick \u3092\u5185\u5074\u65b9\u5411\u306b # tick \u3092 bottom, top, left, right \u306b\u4ed8\u52a0 # tick width # tick length ax1 . tick_params ( pad = 5 , which = 'minor' , direction = 'in' , bottom = True , top = True , left = True , right = True , length = 2 ) # \u8ef8\u306e\u4f59\u767d # which: major tick \u3068 minor tick \u306b\u5bfe\u3057\u3066\u5909\u66f4\u3092\u9069\u7528 # tick \u3092\u5185\u5074\u65b9\u5411\u306b # tick \u3092 bottom, top, left, right \u306b\u4ed8\u52a0 # tick width # tick length ax1 . set_xlabel ( \"Time [sec] \\n Fig 1. 0.1 Hz sin wave sampled by 10 Hz, 0-60 sec.\" ) ax1 . set_xlim ( 0 - 1 , 60 + 1 ) ax1 . xaxis . set_major_locator ( tick . MultipleLocator ( 5 )) ax1 . xaxis . set_minor_locator ( tick . MultipleLocator ( 1 )) ax1 . set_ylabel ( \"Amplitude\" ) ax1 . set_ylim ( - 1.1 , 1.1 ) ax1 . yaxis . set_major_locator ( tick . MultipleLocator ( 0.5 )) ax1 . yaxis . set_minor_locator ( tick . MultipleLocator ( 0.1 )) plt . savefig ( writeName , bbox_inches = \"tight\" ) main.cpp #include <sstd/sstd.hpp> int main (){ double freq2generate = 0.1 ; // 0.1 Hz sin wave double freq2sample = 10 ; // 10 Hz sampling uint len = 60 * 10 + 1 ; // 60 sec std :: vector < double > vecY = sstd :: sinWave ( freq2generate , freq2sample , len ); std :: vector < double > vecX ( len ); for ( uint i = 0 ; i < vecX . size (); i ++ ){ vecX [ i ] = ( double ) i * ( 1 / freq2sample ); } sstd :: c2py < void > vec2graph ( \"./tmpDir\" , \"pyFunctions\" , \"vec2graph\" , \"void, const char*, vec<double>*, vec<double>*\" ); vec2graph ( \"./sin.png\" , & vecX , & vecY ); return 0 ; } Execution result Application sample 2 An example of the additional implementation of vvec<T> . Currently, only vvec is available. \u8ffd\u52a0\u5b9f\u88c5\u3055\u308c\u305f vvec<T> \u306e\u4f7f\u7528\u4f8b\uff0e\u73fe\u72b6\u3067\u306f\uff0c vvec<double> \u306e\u307f\u5229\u7528\u53ef\u80fd\uff0e Python def vvec2graph ( writeName , vLabel , vvecX , vvecY ): plt . clf () fig = plt . figure ( figsize = ( 8.5 , 3 )) # \u30a2\u30b9\u30da\u30af\u30c8\u6bd4\u306e\u8a2d\u5b9a ax1 = fig . add_subplot ( 111 ) #cmap = plt.get_cmap(\"tab10\") vColor = [ 'black' , 'blue' , 'red' ] vLineStyle = [ 'solid' , 'solid' , 'solid' ] # solid, dashed, dashdot, dotted for i in range ( len ( vvecX )): #ax1.plot(vvecX[i], vvecY[i], linewidth=0.5, color=cmap(i), linestyle=vLineStyle[i], label=vLabel[i]) ax1 . plot ( vvecX [ i ], vvecY [ i ], linewidth = 0.5 , color = vColor [ i ], linestyle = vLineStyle [ i ], label = vLabel [ i ]) ax1 . legend ( loc = 'upper right' ) ax1 . grid ( which = 'minor' , linewidth = 0.5 , linestyle = ':' , color = 'gainsboro' ) ax1 . grid ( which = 'major' , linewidth = 0.5 , linestyle = '-' , color = 'silver' ) ax1 . tick_params ( pad = 5 , which = 'major' , direction = 'in' , bottom = True , top = True , left = True , right = True , length = 4 ) # \u8ef8\u306e\u4f59\u767d # which: major tick \u3068 minor tick \u306b\u5bfe\u3057\u3066\u5909\u66f4\u3092\u9069\u7528 # tick \u3092\u5185\u5074\u65b9\u5411\u306b # tick \u3092 bottom, top, left, right \u306b\u4ed8\u52a0 # tick width # tick length ax1 . tick_params ( pad = 5 , which = 'minor' , direction = 'in' , bottom = True , top = True , left = True , right = True , length = 2 ) # \u8ef8\u306e\u4f59\u767d # which: major tick \u3068 minor tick \u306b\u5bfe\u3057\u3066\u5909\u66f4\u3092\u9069\u7528 # tick \u3092\u5185\u5074\u65b9\u5411\u306b # tick \u3092 bottom, top, left, right \u306b\u4ed8\u52a0 # tick width # tick length ax1 . set_xlabel ( \"Time [sec] \\n Fig 2. 0.1 Hz sin, cos and -cos wave sampled by 10 Hz, 0-60 sec.\" ) ax1 . set_xlim ( 0 - 1 , 60 + 1 ) ax1 . xaxis . set_major_locator ( tick . MultipleLocator ( 5 )) ax1 . xaxis . set_minor_locator ( tick . MultipleLocator ( 1 )) ax1 . set_ylabel ( \"Amplitude\" ) ax1 . set_ylim ( - 1.1 , 1.1 ) ax1 . yaxis . set_major_locator ( tick . MultipleLocator ( 0.5 )) ax1 . yaxis . set_minor_locator ( tick . MultipleLocator ( 0.1 )) plt . legend ( loc = 'best' ) plt . savefig ( writeName , bbox_inches = \"tight\" ) # , dpi=100 main.cpp #include <sstd/sstd.hpp> int main (){ double freq_generate = 0.1 ; // 0.1 Hz sin wave double freq_sample = 10 ; // 10 Hz sampling uint len = 60 * 10 + 1 ; // 60 sec std :: vector < double > sinY = sstd :: sinWave ( freq_generate , freq_sample , len ); std :: vector < double > sinX ( len ); for ( uint i = 0 ; i < sinX . size (); i ++ ){ sinX [ i ] = ( double ) i * ( 1 / freq_sample ); } std :: vector < double > cosY = sstd :: cosWave ( freq_generate , freq_sample , len ); std :: vector < double > cosX ( len ); for ( uint i = 0 ; i < cosX . size (); i ++ ){ cosX [ i ] = ( double ) i * ( 1 / freq_sample ); } std :: vector < std :: string > vLabel = { \"sin\" , \"cos\" , \"-cos\" }; std :: vector < std :: vector < double >> vvecX = { sinX , cosX , cosX }; std :: vector < std :: vector < double >> vvecY = { sinY , cosY , -1 * cosY }; sstd :: c2py < void > vvec2graph ( tmpDir , fileName , \"vvec2graph\" , \"void, const char*, const vec<str>*, const vvec<double>*, const vvec<double>*\" ); vvec2graph ( \"./sin_cos.png\" , & vLabel , & vvecX , & vvecY ); return 0 ; } Execution result Application sample 3 In the code below, reading png image from Python, editing on C++ and writing to png file by Python again. Python \u95a2\u6570\u304b\u3089 png \u30d5\u30a1\u30a4\u30eb\u3092\u8aad\u307f\u8fbc\u307f\uff0cC++ \u3067\u8272\u3092\u7de8\u96c6\u3057\u305f\u5f8c\uff0c\u518d\u5ea6 Python \u95a2\u6570\u3067 png \u30d5\u30a1\u30a4\u30eb\u3078\u66f8\u304d\u51fa\u3059\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u3092\u793a\u3059\uff0e Python import numpy as np from PIL import Image def imgPath2mat_rRGB ( path ): imgRaw = Image . open ( path ) imgRGB = imgRaw . split () imgR = imgRGB [ 0 ] imgG = imgRGB [ 1 ] imgB = imgRGB [ 2 ] return ( imgR , imgG , imgB ) def mat_rRGB2img ( path , imgR , imgG , imgB ): imgCombined = np . dstack (( np . dstack (( imgR , imgG )), imgB )) imgPIL = Image . fromarray ( imgCombined ) imgPIL . save ( path ) main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: c2py < void > imgPath2mat_rRGB ( \"./tmpDir\" , \"pyFunctions\" , \"imgPath2mat_rRGB\" , \"void, ret mat_r<uint8>*, ret mat_r<uint8>*, ret mat_r<uint8>*, const char*\" ); sstd :: mat_r < uint8 > imgR , imgG , imgB ; imgPath2mat_rRGB ( & imgR , & imgG , & imgB , \"./sample.png\" ); for ( uint p = 0 ; p < imgG . rows (); p ++ ){ for ( uint q = 0 ; q < imgG . cols (); q ++ ){ imgG ( p , q ) = sstd :: round2even ( 0.5 * (( double ) imgG ( p , q ))); } } sstd :: c2py < void > mat_rRGB2img ( \"./tmpDir\" , \"pyFunctions\" , \"mat_rRGB2img\" , \"void, const char*, mat_r<uint8>*, mat_r<uint8>*, mat_r<uint8>*\" ); mat_rRGB2img ( \"./sample_reCombined.png\" , & imgR , & imgG , & imgB ); return 0 ; } Execution result Input image (sample.png) Output image (sample_reCombined.png) Implementation Source: sstd/src/c2py.cpp Header: sstd/src/c2py.hpp Python: sstd/src/c2py.py Test: test/c2py.hpp","title":"c2py"},{"location":"src/c2py.html#c2py","text":"","title":"c2py"},{"location":"src/c2py.html#abstract","text":"c2py() calls any Python functions with built-in, std::vector<T> , sstd::mat_c<T> and sstd::mat_r<T> ( T is limited by built-in types.) types of arguments from 2 lines of C++ codes. Data is sharing by the tmp directory. c2py() \u306f built-in \u578b\uff0c std::vector<T> \u578b, sstd::mat_c<T> \u578b\uff0c\u304a\u3088\u3073 sstd::mat_r<T> \u578b (\u305f\u3060\u3057\uff0c T \u306f built-in \u578b\u306b\u5236\u9650\u3055\u308c\u308b\uff0e) \u3092\u5f15\u6570\u306b\u6301\u3064 Python \u95a2\u6570\u3092 2 \u884c\u306e C++ \u30b3\u30fc\u30c9\u3067\u547c\u3073\u51fa\u3057\u307e\u3059\uff0e \u30c7\u30fc\u30bf\u306f tmp \u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306b\u3088\u308a\u5171\u6709\u3055\u308c\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/c2py.html#header-file","text":"namespace sstd { template < typename T > class c2py ; } template < typename T > class sstd :: c2py { public : c2py ( const char * temporarilyDir , const char * importFile , const char * functionName , const char * format ); ~ c2py (); template < typename ... ARGS > T operator ()( ARGS ... args ); }; c2py interface sstd :: c2py < ATypeOfReturnValue > FunctionName ( \"Tempolary directory\" , // Argument 1 \"A name of calling .py file (without extension)\" , // Argument 2 \"A function name calling from .py file\" , // Argument 3 \"Arguments types specification of Python function\" ); // Argument 4 c2py \u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u306e\u8a2d\u8a08 sstd :: c2py < \u623b\u308a\u5024\u306e\u578b > \u95a2\u6570\u540d ( \"\u4e00\u6642\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\" , // \u7b2c 1 \u5f15\u6570 \"\u547c\u3073\u51fa\u3057\u5148\u306e .py \u30d5\u30a1\u30a4\u30eb (\u305f\u3060\u3057\u62e1\u5f35\u5b50\u3092\u9664\u304f)\" , // \u7b2c 2 \u5f15\u6570 \".py \u30d5\u30a1\u30a4\u30eb\u4e2d\u304b\u3089\u547c\u3073\u51fa\u3059\u95a2\u6570\u540d\" , // \u7b2c 3 \u5f15\u6570 \"Python \u95a2\u6570\u306e\u578b\u6307\u5b9a\" ); // \u7b2c 4 \u5f15\u6570","title":"Header file"},{"location":"src/c2py.html#requirements","text":"c2py() requires the importlib , inspect , itertools , numpy , os and sys Python packages. See sstd/src/c2py.py for details. c2py() \u306f\uff0c importlib , inspect , itertools , numpy , os , sys \u306e Python \u30d1\u30c3\u30b1\u30fc\u30b8\u3092\u5fc5\u8981\u3068\u3057\u307e\u3059\uff0e\u8a73\u7d30\u306f sstd/src/c2py.py \u3092\u53c2\u7167\u3059\u308b\u3053\u3068\uff0e","title":"Requirements"},{"location":"src/c2py.html#list-of-corresponding-types","text":"Table 1. shows the correspondence between the types on the C ++ side and the types on the Python side. Table 2. shows a list of type names given when specifying a type on the C ++ side. If not specifying type on the Python side, numpy will be selected. And selecting the conversion symbol ~ , the numpy type will be converted to the built-in type. The c2py is basically processed by numpy, because of the binary compatibility between C++ and Python, type conversion of numpy to built-in type will be overhead. \u8868 1. \u306b C++ \u5074\u306e\u578b\u3068\uff0cPython \u5074\u306e\u578b\u3068\u306e\u5bfe\u5fdc\u3092\u793a\u3059\uff0e \u8868 2. \u306b C++ \u5074\u306e\u578b\u3092\u6307\u5b9a\u3059\u308b\u969b\u306b\u4e0e\u3048\u308b\u578b\u540d\u306e\u4e00\u89a7\u3092\u793a\u3059\uff0e Python \u5074\u306e\u578b\u306b\u3064\u3044\u3066\uff0c\u4f55\u3082\u6307\u5b9a\u3057\u306a\u3044\u5834\u5408\u306f\uff0cnumpy \u578b\u304c\u9078\u629e\u3055\u308c\uff0c\u5909\u63db\u8a18\u53f7 ~ \u3092\u6307\u5b9a\u3059\u308b\u3053\u3068\u3067\uff0cbuilt-in \u578b\u306b\u5909\u63db\u3055\u308c\u308b\uff0e c2py \u4e0a\u306e\u51e6\u7406\u306f\uff0cC++ \u3068\u306e\u30d0\u30a4\u30ca\u30ea\u4e92\u63db\u6027\u306e\u554f\u984c\u304b\u3089\uff0c\u57fa\u672c\u7684\u306b numpy \u578b\u3067\u884c\u308f\u308c\u308b\u305f\u3081\uff0cbuilt-in \u578b\u3078\u306e\u5909\u63db\u306f\uff0c\u30aa\u30fc\u30d0\u30fc\u30d8\u30c3\u30c9\u3068\u306a\u308b\uff0e Table 1. Correspondence between types implemented in c2py and Python \u8868 1. c2py \u3067\u5b9f\u88c5\u3055\u308c\u3066\u3044\u308b\u578b\u3068 Python \u578b\u3068\u306e\u5bfe\u5fdc Types of C++ side Types of Python side Entity / Pointer / Pointer array Entity / Pointer Entity / Pointer Entity / Pointer Entity / Pointer bool std::vector<bool> sstd::mat_c<bool> sstd::mat_r<bool> numpy / built-in char std::vector<char> sstd::mat_c<char> sstd::mat_r<char> built-in uchar std::vector<uchar> sstd::mat_c<uchar> sstd::mat_r<uchar> built-in int8 std::vector<int8> sstd::mat_c<int8> sstd::mat_r<int8> numpy / built-in int16 std::vector<int16> sstd::mat_c<int16> sstd::mat_r<int16> numpy / built-in int32 std::vector<int32> sstd::mat_c<int32> sstd::mat_r<int32> numpy / built-in int64 std::vector<int64> sstd::mat_c<int64> sstd::mat_r<int64> numpy / built-in uint8 std::vector<uint8> sstd::mat_c<uint8> sstd::mat_r<uint8> numpy / built-in uint16 std::vector<uint16> sstd::mat_c<uint16> sstd::mat_r<uint16> numpy / built-in uint32 std::vector<uint32> sstd::mat_c<uint32> sstd::mat_r<uint32> numpy / built-in uint64 std::vector<uint64> sstd::mat_c<uint64> sstd::mat_r<uint64> numpy / built-in float std::vector<float> sstd::mat_c<float> sstd::mat_r<float> numpy / built-in double std::vector<double> sstd::mat_c<double> sstd::mat_r<double> numpy / built-in std::string std::vector<std::string> sstd::mat_c<std::string> sstd::mat_r<std::string> built-in Table 2. Type names giving to the 4th argument of c2py. \u8868 2. c2py \u306e\u7b2c 4 \u5f15\u6570\u306b\u4e0e\u3048\u308b\u578b\u540d\uff0e Types of C++ side Entity / Pointer / Pointer array Entity / Pointer Entity / Pointer Entity / Pointer bool vec<bool> mat_c<bool> mat_r<bool> char vec<char> mat_c<char> mat_r<char> uchar vec<uchar> mat_c<uchar> mat_r<uchar> int8 vec<int8> mat_c<int8> mat_r<int8> int16 vec<int16> mat_c<int16> mat_r<int16> int32 vec<int32> mat_c<int32> mat_r<int32> int64 vec<int64> mat_c<int64> mat_r<int64> uint8 vec<uint8> mat_c<uint8> mat_r<uint8> uint16 vec<uint16> mat_c<uint16> mat_r<uint16> uint32 vec<uint32> mat_c<uint32> mat_r<uint32> uint64 vec<uint64> mat_c<uint64> mat_r<uint64> float vec<float> mat_c<float> mat_r<float> double vec<double> mat_c<double> mat_r<double> str / string vec<str> / vec<string> mat_c<str> / mat_c<string> mat_r<str> / mat_r<string>","title":"List of corresponding types. (\u5bfe\u5fdc\u3059\u308b\u578b\u306e\u4e00\u89a7)"},{"location":"src/c2py.html#usage","text":"","title":"Usage"},{"location":"src/c2py.html#sample1-return-int-input-int-and-const-int","text":"pyFunction.py def plus_a_b ( a , b ): return a + b main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"echo 'def plus_a_b(a, b): return a+b' > ./tmp/pyFunction.py\" ); sstd :: c2py < int > plus_a_b ( \"./tmpDir\" , \"./tmp/pyFunction\" , \"plus_a_b\" , \"int, int, const int*\" ); int a = 1 , b = 2 ; int c = plus_a_b ( a , & b ); // Running Python here sstd :: printn ( c ); sstd :: rm ( \"./tmp\" ); return 0 ; } Execution result c = 3","title":"Sample1: (Return: \"int\" / Input: \"int\" and \"const int\u000242\u0003\")"},{"location":"src/c2py.html#sample2-return-vecint-input-const-int-len-and-const-vecint","text":"pyFunction.py def plus_vecA_vecB ( vecA , vecB ): return vecA + vecB main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"echo 'def plus_vecA_vecB(vecA, vecB): return vecA+vecB' > ./tmp/pyFunction.py\" ); sstd :: c2py < std :: vector < int >> plus_vecA_vecB ( \"./tmpDir\" , \"./tmp/pyFunction\" , \"plus_vecA_vecB\" , \"vec<int>, const int*, len, const vec<int>*\" ); int arrA [] = { 1 , 2 , 3 }; std :: vector < int > vecB = { 4 , 5 , 6 }; std :: vector < int > vecC = plus_vecA_vecB ( arrA , 3 , & vecB ); // Running Python here sstd :: printn ( vecC ); sstd :: rm ( \"./tmp\" ); return 0 ; } Execution result vecC = [5 7 9]","title":"Sample2: (Return: \"vec&lt;int&gt;\" / Input: \"const int\u000242\u0003\", \"len\" and \"const vec&lt;int&gt;\u000242\u0003\")"},{"location":"src/c2py.html#sample3-return-void-input-int-int-len-and-vecint","text":"Writing back self multiplied value. \u81ea\u5df1\u4e57\u7b97\u5024\u3092\u66f8\u304d\u623b\u3059\uff0e pyFunction.py def selfMult ( a , vecB , vecC ): a [ 0 ] = a [ 0 ] * a [ 0 ] for i in range ( len ( vecB )): vecB [ i ] = vecB [ i ] * vecB [ i ] for i in range ( len ( vecC )): vecC [ i ] = vecC [ i ] * vecC [ i ] main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"echo 'def selfMult(a, vecB, vecC): \\n a[0]=a[0]*a[0] \\n for i in range(len(vecB)): vecB[i]=vecB[i]*vecB[i] \\n for i in range(len(vecC)): vecC[i]=vecC[i]*vecC[i]' > ./tmp/pyFunction.py\" ); sstd :: c2py < void > selfMult ( \"./tmpDir\" , \"./tmp/pyFunction\" , \"selfMult\" , \"void, int*, int*, len, vec<int>*\" ); int a = 2 ; int arrB [] = { 3 , 4 , 5 }; std :: vector < int > vecC = { 6 , 7 , 8 }; selfMult ( & a , arrB , 3 , & vecC ); sstd :: printn ( a ); printf ( \"arrB[3] = [ \" ); for ( uint i = 0 ; i < 3 ; i ++ ){ printf ( \"%d \" , arrB [ i ]); } printf ( \"] \\n \" ); sstd :: printn ( vecC ); sstd :: rm ( \"./tmp\" ); return 0 ; } Execution result a = 4 arrB[3] = [ 9 16 25 ] vecC = [36 49 64]","title":"Sample3: (Return: \"void\" / Input: \"int\u000242\u0003\", \"int\u000242\u0003\", \"len\" and \"vec&lt;int&gt;\u000242\u0003\")"},{"location":"src/c2py.html#sample4-types-conversion-of-numpy-to-built-in","text":"Conversion types in Python side. Symbols on the right side of \"|\" (which is a separator symbol between C++ and Python) mean the symbols have effect on the Python side. On the right side of \"|\" enable to take \" \" or \"~\" and these order have no meaning. (There is no difference between \"| ~\" and \"|~*\", so it will work same.) *: A symbol have a meaning to convert input value on Python side to a pseudo pointer type (self inclusion list). ~: A symbol have a meaning to convert input value on Python side to a built-in type (instead of numpy type). Python \u5074\u3067\u578b\u5909\u63db\u3092\u884c\u3046\u5834\u5408\uff0e\u30bb\u30d1\u30ec\u30fc\u30bf\u8a18\u53f7 \"|\" \u306e\u5de6\u53f3\u306f\uff0c\u305d\u308c\u305e\u308c\uff0cC++ \u5074\u3068 Python \u5074\u3092\u8868\u3057\u3066\u3044\u308b\uff0e\u5206\u5272\u8a18\u53f7 \"|\" \u306e\u53f3\u5074\u306e\u578b\u306f \" \" \u307e\u305f\u306f \"~\" \u3092\u53d6\u308b\u3053\u3068\u304c\u3067\u304d\uff0c\u3053\u308c\u306f Python \u5074\u306b\u304a\u3051\u308b\u5909\u63db\u8a18\u53f7\u3067\u3042\u308b\uff0e\u3053\u306e\u3068\u304d\uff0c\u5909\u63db\u8a18\u53f7 \" \"\uff0c\"~\" \u306e\u9806\u5e8f\u306f\u610f\u5473\u3092\u306a\u3055\u306a\u3044\uff0e(\u3057\u305f\u304c\u3063\u3066\uff0c \"| ~\" \u3068 \"|~ \" \u306e\u9593\u306b\u5dee\u306f\u306a\u304f\uff0c\u540c\u3058\u3088\u3046\u306b\u52d5\u4f5c\u3059\u308b\uff0e) *: Python \u5074\u306e\u5165\u529b\u5024\u3092\u64ec\u4f3c\u30dd\u30a4\u30f3\u30bf\u578b (\u81ea\u5df1\u5305\u542b\u30ea\u30b9\u30c8) \u3078\u5909\u63db\u3059\u308b\uff0e ~: Python \u5074\u306e\u5165\u529b\u5024\u3092\uff08numpy \u578b\u306e\u4ee3\u308f\u308a\u306b\uff09\u7d44\u307f\u8fbc\u307f\u578b\u306b\u5909\u63db\u3059\u308b\uff0e pyFunction.py def checkTypes ( Numpy , builtIn , pNumpy , pBuiltIn ): print ( type ( Numpy ), Numpy ) print ( type ( builtIn ), builtIn ) print ( type ( pNumpy ), pNumpy ) print ( type ( pBuiltIn ), pBuiltIn ) main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"echo 'def checkTypes(Numpy, builtIn, pNumpy, pBuiltIn): \\n print(type(Numpy), Numpy) \\n print(type(builtIn), builtIn) \\n print(type(pNumpy), pNumpy) \\n print(type(pBuiltIn), pBuiltIn)' > ./tmp/pyFunction.py\" ); sstd :: c2py < void > checkTypes ( \"./tmpDir\" , \"./tmp/pyFunction\" , \"checkTypes\" , \"void, int, int|~, int|*, int|*~\" ); checkTypes ( 0 , 0 , 0 , 0 ); sstd :: rm ( \"./tmp\" ); return 0 ; } Execution result <class 'numpy.ndarray'> [0] <class 'list'> [0] <class 'list'> [array([0], dtype=int32)] <class 'list'> [[0]]","title":"Sample4: Types conversion of numpy to built-in"},{"location":"src/c2py.html#sample5-writing-back-with-changing-the-length-of-stdvectort","text":"Writing back with changing the length of std::vector<T> . (In order to get value from function, sending address is needed.) \u914d\u5217\u9577\u306e\u5909\u5316\u3092\u542b\u3080 std::vector<T> \u306e\u66f8\u304d\u623b\u3057\uff0e(\u95a2\u6570\u304b\u3089\u5024\u3092\u53d7\u3051\u53d6\u308b\u305f\u3081\uff0c\u30a2\u30c9\u30ec\u30b9\u3092\u53d7\u3051\u6e21\u3057\u3066\u3044\u308b) pyFunction.py import numpy as np def changeLen ( pVec1 , vec2 ): pVec1 [ 0 ] = np . append ( pVec1 [ 0 ], 4 ) # numpy # numpy is not able to add values without changing address of variables. so we need to treat as a pointer like objects (self inclusion list). vec2 . append ( 4 ) # built-in main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"echo 'import numpy as np \\n def changeLen(pVec1, vec2): \\n pVec1[0]=np.append(pVec1[0], 4) \\n vec2.append(4)' > ./tmp/pyFunction.py\" ); sstd :: c2py < void > changeLen ( \"./tmpDir\" , \"./tmp/pyFunction\" , \"changeLen\" , \"void, vec<int>*|*, vec<int>*|~\" ); std :: vector < int > vec1 = { 1 , 2 , 3 }, vec2 = { 1 , 2 , 3 }; changeLen ( & vec1 , & vec2 ); sstd :: printn ( vec1 ); sstd :: printn ( vec2 ); sstd :: rm ( \"./tmp\" ); return 0 ; } Execution result vec1 = [1 2 3 4] vec2 = [1 2 3 4]","title":"Sample5: Writing back with changing the length of std::vector&lt;T&gt;"},{"location":"src/c2py.html#sample6","text":"Receiving multiple return values from python side. (\u203b \"ret\" which is a symbol of return value, must be continuous in arg 4. Interrupted ret occurs error.) Python \u5074\u304b\u3089\u8907\u6570\u306e\u623b\u308a\u5024\u3092\u53d7\u3051\u53d6\u308b\uff0e(\u203b \u623b\u308a\u5024\u8a18\u53f7 \"ret\" \u306f\uff0c\u7b2c 4 \u5f15\u6570\u4e2d\u3067\u9023\u7d9a\u3057\u3066\u3044\u308b\u5fc5\u8981\u304c\u3042\u308b\uff0e\u4e0d\u9023\u7d9a\u306a ret \u306f\u30a8\u30e9\u30fc\u3092\u5f15\u304d\u8d77\u3053\u3059\uff0e) pyFunction.py def multiRet (): return ( 9 , 9 , [ 1 , 2 , 3 ], [ 4 , 5 , 6 ]) main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"echo 'def multiRet(): return (9, 9, [1,2,3], [4,5,6])' > ./tmp/pyFunction.py\" ); sstd :: c2py < int > multiRet ( \"./tmpDir\" , \"./tmp/pyFunction\" , \"multiRet\" , \"int, ret int*, ret int*, len, ret vec<int>*\" ); int ret0 = 0 ; int ret1 = 0 ; int ret2 [] = { 0 , 0 , 0 }; std :: vector < int > ret3 ; ret0 = multiRet ( & ret1 , & ret2 , 3 , & ret3 ); sstd :: printn ( ret0 ); sstd :: printn ( ret1 ); printf ( \"ret2[3] = [ \" ); for ( uint i = 0 ; i < 3 ; i ++ ){ printf ( \"%d \" , ret2 [ i ]); } printf ( \"] \\n \" ); sstd :: printn ( ret3 ); sstd :: rm ( \"./tmp\" ); return 0 ; } Execution result ret0 = 9 ret1 = 9 ret2[3] = [ 1 2 3 ] ret3 = [4 5 6]","title":"Sample6"},{"location":"src/c2py.html#appendix","text":"","title":"Appendix"},{"location":"src/c2py.html#application-sample-1","text":"As one of the most convenient application, c2py enable to call matplotlib which is a famous graph plot library in python from C++. In the code below, generate sin wave on C++ and write graph by matplotlib in Python. \u6700\u3082\u4fbf\u5229\u306a\u5fdc\u7528\u306e 1 \u3064\u3068\u3057\u3066\uff0cc2py \u3067\u306f\uff0cPython \u3067\u6709\u540d\u306a\u30b0\u30e9\u30d5\u30d7\u30ed\u30c3\u30c8\u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u3042\u308b matplotlib \u3092 C++ \u304b\u3089\u547c\u3073\u51fa\u3059\u3053\u3068\u304c\u3067\u304d\u308b\uff0e\u4e0b\u8a18\u306e\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u3067\u306f\uff0cC++ \u5074\u3067\u751f\u6210\u3057\u305f sin \u6ce2\u3092\uff0cPython \u30e9\u30a4\u30d6\u30e9\u30ea\u3067\u3042\u308b matplotlib \u3067\u63cf\u753b\u3057\u3066\u3044\u308b\uff0e pyFunction.py import matplotlib as mpl # \"QXcbConnection: Could not connect to display\" \u3078\u306e\u5bfe\u7b56 mpl . use ( 'Agg' ) # \"QXcbConnection: Could not connect to display\" \u3078\u306e\u5bfe\u7b56 import matplotlib.pyplot as plt # \"QXcbConnection: Could not connect to display\" \u3078\u306e\u5bfe\u7b56 import matplotlib.ticker as tick def vec2graph ( writeName , vecX , vecY ): plt . clf () fig = plt . figure ( figsize = ( 9 , 3 )) # \u30a2\u30b9\u30da\u30af\u30c8\u6bd4\u306e\u8a2d\u5b9a ax1 = fig . add_subplot ( 111 ) ax1 . plot ( vecX , vecY , color = 'k' , linewidth = 0.5 ) title = \"An example of Plotting a figure of sin wave data generated on C++, \\n \" title += \"using matplotlib which is a famous graph plotting library of python. \\n \" title += \" \\\" sstd::c2py() \\\" convertes a type of std::vector<double> on C++ to \\n \" title += \"numpy array type on Python, and calling a Python function from \\n \" title += \"only 2 lines of C++ code. \" ax1 . set_title ( title ) ax1 . grid ( which = 'minor' , linewidth = 0.5 , linestyle = ':' , color = 'gainsboro' ) ax1 . grid ( which = 'major' , linewidth = 0.5 , linestyle = '-' , color = 'silver' ) ax1 . tick_params ( pad = 5 , which = 'major' , direction = 'in' , bottom = True , top = True , left = True , right = True , length = 4 ) # \u8ef8\u306e\u4f59\u767d # which: major tick \u3068 minor tick \u306b\u5bfe\u3057\u3066\u5909\u66f4\u3092\u9069\u7528 # tick \u3092\u5185\u5074\u65b9\u5411\u306b # tick \u3092 bottom, top, left, right \u306b\u4ed8\u52a0 # tick width # tick length ax1 . tick_params ( pad = 5 , which = 'minor' , direction = 'in' , bottom = True , top = True , left = True , right = True , length = 2 ) # \u8ef8\u306e\u4f59\u767d # which: major tick \u3068 minor tick \u306b\u5bfe\u3057\u3066\u5909\u66f4\u3092\u9069\u7528 # tick \u3092\u5185\u5074\u65b9\u5411\u306b # tick \u3092 bottom, top, left, right \u306b\u4ed8\u52a0 # tick width # tick length ax1 . set_xlabel ( \"Time [sec] \\n Fig 1. 0.1 Hz sin wave sampled by 10 Hz, 0-60 sec.\" ) ax1 . set_xlim ( 0 - 1 , 60 + 1 ) ax1 . xaxis . set_major_locator ( tick . MultipleLocator ( 5 )) ax1 . xaxis . set_minor_locator ( tick . MultipleLocator ( 1 )) ax1 . set_ylabel ( \"Amplitude\" ) ax1 . set_ylim ( - 1.1 , 1.1 ) ax1 . yaxis . set_major_locator ( tick . MultipleLocator ( 0.5 )) ax1 . yaxis . set_minor_locator ( tick . MultipleLocator ( 0.1 )) plt . savefig ( writeName , bbox_inches = \"tight\" ) main.cpp #include <sstd/sstd.hpp> int main (){ double freq2generate = 0.1 ; // 0.1 Hz sin wave double freq2sample = 10 ; // 10 Hz sampling uint len = 60 * 10 + 1 ; // 60 sec std :: vector < double > vecY = sstd :: sinWave ( freq2generate , freq2sample , len ); std :: vector < double > vecX ( len ); for ( uint i = 0 ; i < vecX . size (); i ++ ){ vecX [ i ] = ( double ) i * ( 1 / freq2sample ); } sstd :: c2py < void > vec2graph ( \"./tmpDir\" , \"pyFunctions\" , \"vec2graph\" , \"void, const char*, vec<double>*, vec<double>*\" ); vec2graph ( \"./sin.png\" , & vecX , & vecY ); return 0 ; } Execution result","title":"Application sample 1"},{"location":"src/c2py.html#application-sample-2","text":"An example of the additional implementation of vvec<T> . Currently, only vvec is available. \u8ffd\u52a0\u5b9f\u88c5\u3055\u308c\u305f vvec<T> \u306e\u4f7f\u7528\u4f8b\uff0e\u73fe\u72b6\u3067\u306f\uff0c vvec<double> \u306e\u307f\u5229\u7528\u53ef\u80fd\uff0e Python def vvec2graph ( writeName , vLabel , vvecX , vvecY ): plt . clf () fig = plt . figure ( figsize = ( 8.5 , 3 )) # \u30a2\u30b9\u30da\u30af\u30c8\u6bd4\u306e\u8a2d\u5b9a ax1 = fig . add_subplot ( 111 ) #cmap = plt.get_cmap(\"tab10\") vColor = [ 'black' , 'blue' , 'red' ] vLineStyle = [ 'solid' , 'solid' , 'solid' ] # solid, dashed, dashdot, dotted for i in range ( len ( vvecX )): #ax1.plot(vvecX[i], vvecY[i], linewidth=0.5, color=cmap(i), linestyle=vLineStyle[i], label=vLabel[i]) ax1 . plot ( vvecX [ i ], vvecY [ i ], linewidth = 0.5 , color = vColor [ i ], linestyle = vLineStyle [ i ], label = vLabel [ i ]) ax1 . legend ( loc = 'upper right' ) ax1 . grid ( which = 'minor' , linewidth = 0.5 , linestyle = ':' , color = 'gainsboro' ) ax1 . grid ( which = 'major' , linewidth = 0.5 , linestyle = '-' , color = 'silver' ) ax1 . tick_params ( pad = 5 , which = 'major' , direction = 'in' , bottom = True , top = True , left = True , right = True , length = 4 ) # \u8ef8\u306e\u4f59\u767d # which: major tick \u3068 minor tick \u306b\u5bfe\u3057\u3066\u5909\u66f4\u3092\u9069\u7528 # tick \u3092\u5185\u5074\u65b9\u5411\u306b # tick \u3092 bottom, top, left, right \u306b\u4ed8\u52a0 # tick width # tick length ax1 . tick_params ( pad = 5 , which = 'minor' , direction = 'in' , bottom = True , top = True , left = True , right = True , length = 2 ) # \u8ef8\u306e\u4f59\u767d # which: major tick \u3068 minor tick \u306b\u5bfe\u3057\u3066\u5909\u66f4\u3092\u9069\u7528 # tick \u3092\u5185\u5074\u65b9\u5411\u306b # tick \u3092 bottom, top, left, right \u306b\u4ed8\u52a0 # tick width # tick length ax1 . set_xlabel ( \"Time [sec] \\n Fig 2. 0.1 Hz sin, cos and -cos wave sampled by 10 Hz, 0-60 sec.\" ) ax1 . set_xlim ( 0 - 1 , 60 + 1 ) ax1 . xaxis . set_major_locator ( tick . MultipleLocator ( 5 )) ax1 . xaxis . set_minor_locator ( tick . MultipleLocator ( 1 )) ax1 . set_ylabel ( \"Amplitude\" ) ax1 . set_ylim ( - 1.1 , 1.1 ) ax1 . yaxis . set_major_locator ( tick . MultipleLocator ( 0.5 )) ax1 . yaxis . set_minor_locator ( tick . MultipleLocator ( 0.1 )) plt . legend ( loc = 'best' ) plt . savefig ( writeName , bbox_inches = \"tight\" ) # , dpi=100 main.cpp #include <sstd/sstd.hpp> int main (){ double freq_generate = 0.1 ; // 0.1 Hz sin wave double freq_sample = 10 ; // 10 Hz sampling uint len = 60 * 10 + 1 ; // 60 sec std :: vector < double > sinY = sstd :: sinWave ( freq_generate , freq_sample , len ); std :: vector < double > sinX ( len ); for ( uint i = 0 ; i < sinX . size (); i ++ ){ sinX [ i ] = ( double ) i * ( 1 / freq_sample ); } std :: vector < double > cosY = sstd :: cosWave ( freq_generate , freq_sample , len ); std :: vector < double > cosX ( len ); for ( uint i = 0 ; i < cosX . size (); i ++ ){ cosX [ i ] = ( double ) i * ( 1 / freq_sample ); } std :: vector < std :: string > vLabel = { \"sin\" , \"cos\" , \"-cos\" }; std :: vector < std :: vector < double >> vvecX = { sinX , cosX , cosX }; std :: vector < std :: vector < double >> vvecY = { sinY , cosY , -1 * cosY }; sstd :: c2py < void > vvec2graph ( tmpDir , fileName , \"vvec2graph\" , \"void, const char*, const vec<str>*, const vvec<double>*, const vvec<double>*\" ); vvec2graph ( \"./sin_cos.png\" , & vLabel , & vvecX , & vvecY ); return 0 ; } Execution result","title":"Application sample 2"},{"location":"src/c2py.html#application-sample-3","text":"In the code below, reading png image from Python, editing on C++ and writing to png file by Python again. Python \u95a2\u6570\u304b\u3089 png \u30d5\u30a1\u30a4\u30eb\u3092\u8aad\u307f\u8fbc\u307f\uff0cC++ \u3067\u8272\u3092\u7de8\u96c6\u3057\u305f\u5f8c\uff0c\u518d\u5ea6 Python \u95a2\u6570\u3067 png \u30d5\u30a1\u30a4\u30eb\u3078\u66f8\u304d\u51fa\u3059\u30b5\u30f3\u30d7\u30eb\u30b3\u30fc\u30c9\u3092\u793a\u3059\uff0e Python import numpy as np from PIL import Image def imgPath2mat_rRGB ( path ): imgRaw = Image . open ( path ) imgRGB = imgRaw . split () imgR = imgRGB [ 0 ] imgG = imgRGB [ 1 ] imgB = imgRGB [ 2 ] return ( imgR , imgG , imgB ) def mat_rRGB2img ( path , imgR , imgG , imgB ): imgCombined = np . dstack (( np . dstack (( imgR , imgG )), imgB )) imgPIL = Image . fromarray ( imgCombined ) imgPIL . save ( path ) main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: c2py < void > imgPath2mat_rRGB ( \"./tmpDir\" , \"pyFunctions\" , \"imgPath2mat_rRGB\" , \"void, ret mat_r<uint8>*, ret mat_r<uint8>*, ret mat_r<uint8>*, const char*\" ); sstd :: mat_r < uint8 > imgR , imgG , imgB ; imgPath2mat_rRGB ( & imgR , & imgG , & imgB , \"./sample.png\" ); for ( uint p = 0 ; p < imgG . rows (); p ++ ){ for ( uint q = 0 ; q < imgG . cols (); q ++ ){ imgG ( p , q ) = sstd :: round2even ( 0.5 * (( double ) imgG ( p , q ))); } } sstd :: c2py < void > mat_rRGB2img ( \"./tmpDir\" , \"pyFunctions\" , \"mat_rRGB2img\" , \"void, const char*, mat_r<uint8>*, mat_r<uint8>*, mat_r<uint8>*\" ); mat_rRGB2img ( \"./sample_reCombined.png\" , & imgR , & imgG , & imgB ); return 0 ; } Execution result Input image (sample.png) Output image (sample_reCombined.png)","title":"Application sample 3"},{"location":"src/c2py.html#implementation","text":"Source: sstd/src/c2py.cpp Header: sstd/src/c2py.hpp Python: sstd/src/c2py.py Test: test/c2py.hpp","title":"Implementation"},{"location":"src/encode_decode.html","text":"encode / decode Abstract encode_decode.hpp contains functions for encoding and decoding operations. encode_decode.hpp \u306f\u30a8\u30f3\u30b3\u30fc\u30c9\u30fb\u30c7\u30b3\u30fc\u30c9\u306b\u307e\u3064\u308f\u308b\u95a2\u6570\u3092\u53ce\u9332\u3057\u307e\u3059\uff0e Header file namespace sstd { std :: string base64_encode ( const uchar * str , size_t strLen ); std :: string base64_encode ( const uchar * str ); std :: string base64_encode ( const std :: string & str ); std :: string base64_decode ( const uchar * str , size_t strLen ); // when it was an error, 0 size std::string is returned. std :: string base64_decode ( const uchar * str ); // when it was an error, 0 size std::string is returned. std :: string base64_decode ( const std :: string & str ); // when it was an error, 0 size std::string is returned. void print_base64_decode_table (); // for developers extern const char bin2str_table [ 256 ][ 3 ]; std :: string url_encode ( const char * str , size_t strLen ); std :: string url_encode ( const char * str ); std :: string url_encode ( std :: string & str ); std :: string url_encode_type2 ( const char * str , size_t strLen ); // for developers void url_encode_compare_speed (); // for developers std :: string url_decode ( const char * str , size_t strLen ); // when it was an error, 0 size std::string is returned. std :: string url_decode ( const char * str ); // when it was an error, 0 size std::string is returned. std :: string url_decode ( std :: string & str ); // when it was an error, 0 size std::string is returned. void print_url_decode_table (); // for developers // std::u16string utf8_to_utf16(const std::string& str); // std::string utf16_to_utf8(const std::u16string& str); // utf functions are not checked yet. std :: u32string utf16_to_utf32 ( const std :: u16string & str ); std :: u16string utf32_to_utf16 ( const std :: u32string & str ); std :: string utf32_to_utf8 ( const std :: u32string & str ); std :: u32string utf8_to_utf32 ( const std :: string & str ); std :: u16string utf8_to_utf16 ( const std :: string & str ); std :: string utf16_to_utf8 ( const std :: u16string & str ); extern const uchar str2bin_table [ 256 ]; std :: string unicodeEscape_encode ( const std :: u16string & str ); std :: u16string unicodeEscape_decode ( const char * str , size_t strLen ); std :: u16string unicodeEscape_decode ( const char * str ); std :: u16string unicodeEscape_decode ( const std :: string & str ); std :: u16string unicodeEscape_decode_type2 ( const char * str , size_t strLen ); // for developers void unicodeEscape_compare_speed (); // for developers void print_unicodeEscape_decode_table (); }; Usage main.cpp #include <sstd/sstd.hpp> int main (){ return 0 ; } Execution result Implementation Source: sstd/src/encode_decode.cpp Header: sstd/src/encode_decode.hpp Test: test/encode_decode.hpp (Not implemented yet)","title":"encode / decode"},{"location":"src/encode_decode.html#encode-decode","text":"","title":"encode / decode"},{"location":"src/encode_decode.html#abstract","text":"encode_decode.hpp contains functions for encoding and decoding operations. encode_decode.hpp \u306f\u30a8\u30f3\u30b3\u30fc\u30c9\u30fb\u30c7\u30b3\u30fc\u30c9\u306b\u307e\u3064\u308f\u308b\u95a2\u6570\u3092\u53ce\u9332\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/encode_decode.html#header-file","text":"namespace sstd { std :: string base64_encode ( const uchar * str , size_t strLen ); std :: string base64_encode ( const uchar * str ); std :: string base64_encode ( const std :: string & str ); std :: string base64_decode ( const uchar * str , size_t strLen ); // when it was an error, 0 size std::string is returned. std :: string base64_decode ( const uchar * str ); // when it was an error, 0 size std::string is returned. std :: string base64_decode ( const std :: string & str ); // when it was an error, 0 size std::string is returned. void print_base64_decode_table (); // for developers extern const char bin2str_table [ 256 ][ 3 ]; std :: string url_encode ( const char * str , size_t strLen ); std :: string url_encode ( const char * str ); std :: string url_encode ( std :: string & str ); std :: string url_encode_type2 ( const char * str , size_t strLen ); // for developers void url_encode_compare_speed (); // for developers std :: string url_decode ( const char * str , size_t strLen ); // when it was an error, 0 size std::string is returned. std :: string url_decode ( const char * str ); // when it was an error, 0 size std::string is returned. std :: string url_decode ( std :: string & str ); // when it was an error, 0 size std::string is returned. void print_url_decode_table (); // for developers // std::u16string utf8_to_utf16(const std::string& str); // std::string utf16_to_utf8(const std::u16string& str); // utf functions are not checked yet. std :: u32string utf16_to_utf32 ( const std :: u16string & str ); std :: u16string utf32_to_utf16 ( const std :: u32string & str ); std :: string utf32_to_utf8 ( const std :: u32string & str ); std :: u32string utf8_to_utf32 ( const std :: string & str ); std :: u16string utf8_to_utf16 ( const std :: string & str ); std :: string utf16_to_utf8 ( const std :: u16string & str ); extern const uchar str2bin_table [ 256 ]; std :: string unicodeEscape_encode ( const std :: u16string & str ); std :: u16string unicodeEscape_decode ( const char * str , size_t strLen ); std :: u16string unicodeEscape_decode ( const char * str ); std :: u16string unicodeEscape_decode ( const std :: string & str ); std :: u16string unicodeEscape_decode_type2 ( const char * str , size_t strLen ); // for developers void unicodeEscape_compare_speed (); // for developers void print_unicodeEscape_decode_table (); };","title":"Header file"},{"location":"src/encode_decode.html#usage","text":"main.cpp #include <sstd/sstd.hpp> int main (){ return 0 ; } Execution result","title":"Usage"},{"location":"src/encode_decode.html#implementation","text":"Source: sstd/src/encode_decode.cpp Header: sstd/src/encode_decode.hpp Test: test/encode_decode.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/itr.html","text":"itr Abstract sstd::begin() and sstd::end() are the definitions for SSTD iterator. sstd::begin() \u3068 sstd::end() \u306f SSTD \u306e\u30a4\u30c6\u30ec\u30fc\u30bf\u306b\u5229\u7528\u3059\u308b\u305f\u3081\u306e\u5b9a\u7fa9\u3067\u3059\uff0e Header file namespace sstd { class begin ; class end ; } Usage main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced = v && sstd :: slice ( sstd :: begin (), sstd :: end ()); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } Execution result v = [1 2 3 4 5] v_sliced = [1 2 3 4 5] Implementation Header: sstd/src/itr.hpp","title":"itr"},{"location":"src/itr.html#itr","text":"","title":"itr"},{"location":"src/itr.html#abstract","text":"sstd::begin() and sstd::end() are the definitions for SSTD iterator. sstd::begin() \u3068 sstd::end() \u306f SSTD \u306e\u30a4\u30c6\u30ec\u30fc\u30bf\u306b\u5229\u7528\u3059\u308b\u305f\u3081\u306e\u5b9a\u7fa9\u3067\u3059\uff0e","title":"Abstract"},{"location":"src/itr.html#header-file","text":"namespace sstd { class begin ; class end ; }","title":"Header file"},{"location":"src/itr.html#usage","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced = v && sstd :: slice ( sstd :: begin (), sstd :: end ()); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } Execution result v = [1 2 3 4 5] v_sliced = [1 2 3 4 5]","title":"Usage"},{"location":"src/itr.html#implementation","text":"Header: sstd/src/itr.hpp","title":"Implementation"},{"location":"src/math.html","text":"math Abstract math.hpp contains functions for mathematical and statistical calculations. math.hpp \u306f\u6570\u5b66\u30fb\u7d71\u8a08\u8a08\u7b97\u7528\u306e\u95a2\u6570\u3092\u53ce\u9332\u3057\u307e\u3059\uff0e Header file namespace sstd { float round2even ( float n ); double round2even ( double n ); float round2odd ( float n ); double round2odd ( double n ); template < typename T > T sum ( const std :: vector < T >& rhs ); template < typename T > T sum ( const std :: vector < T >& rhs , uint a , uint b ); template < class Itr > typename std :: iterator_traits < Itr >:: value_type sum ( const Itr first , const Itr last ); // using Pairwise summation algorithm. float sum ( const std :: vector < float >:: iterator first , const std :: vector < float >:: iterator last ); float sum ( const std :: vector < float >& rhs , uint a , uint b ); // \u914d\u5217\u306e a \u756a\u76ee\u304b\u3089 b \u756a\u76ee\u307e\u3067\u306e\u5408\u8a08. sum of the a th to b th of array. float sum ( const std :: vector < float >& rhs ); float sum_abs ( const std :: vector < float >& rhs ); float ave ( const std :: vector < float >& rhs ); // \u5e73\u5747\u5024: average float med ( std :: vector < float > rhs ); // \u4e2d\u592e\u5024: median // copy rhs // If rhs.size () is even, average of the two median values is returned. // float mod (const std::vector<float>& rhs); // \u6700\u983b\u5024: mode float var ( const std :: vector < float >& rhs ); // \u4e0d\u504f\u5206\u6563/\u6a19\u672c\u5206\u6563 (variance): u^2 = (1/(n-1))*\u03a3(x_i-\u03bc)^2 float var_p ( const std :: vector < float >& rhs ); // \u6bcd\u5206\u6563 (variance population): \u03c3^2 = (1/n)*\u03a3(x_i-\u03bc)^2 float stdev ( const std :: vector < float >& rhs ); // \u6a19\u672c\u6a19\u6e96\u504f\u5dee (sample standard deviation): u = SQRT( (1/(n-1))*\u03a3(x_i-\u03bc)^2 ) float stdev_p ( const std :: vector < float >& rhs ); // \u6a19\u6e96\u504f\u5dee (standard deviation): \u03c3 = SQRT( (1/n)*\u03a3(x_i-\u03bc)^2 ) double sum ( const std :: vector < double >:: iterator first , const std :: vector < double >:: iterator last ); double sum ( const std :: vector < double >& rhs , uint a , uint b ); // \u914d\u5217\u306e a \u756a\u76ee\u304b\u3089 b \u756a\u76ee\u307e\u3067\u306e\u5408\u8a08. sum of the a th to b th of array. double sum ( const std :: vector < double >& rhs ); double sum_abs ( const std :: vector < double >& rhs ); double ave ( const std :: vector < double >& rhs ); // \u5e73\u5747\u5024: average double med ( std :: vector < double > rhs ); // \u4e2d\u592e\u5024: median // copy rhs // If rhs.size () is even, average of the two median values is returned. // double mod (const std::vector<double>& rhs); // \u6700\u983b\u5024: mode double var ( const std :: vector < double >& rhs ); // \u4e0d\u504f\u5206\u6563/\u6a19\u672c\u5206\u6563 (variance): u^2 = (1/(n-1))*\u03a3(x_i-\u03bc)^2 double var_p ( const std :: vector < double >& rhs ); // \u6bcd\u5206\u6563 (variance population): \u03c3^2 = (1/n)*\u03a3(x_i-\u03bc)^2 double stdev ( const std :: vector < double >& rhs ); // \u6a19\u672c\u6a19\u6e96\u504f\u5dee (sample standard deviation): u = SQRT( (1/(n-1))*\u03a3(x_i-\u03bc)^2 ) double stdev_p ( const std :: vector < double >& rhs ); // \u6a19\u6e96\u504f\u5dee (standard deviation): \u03c3 = SQRT( (1/n)*\u03a3(x_i-\u03bc)^2 ) // K: using Kahan summation algorithm float sumK ( const std :: vector < float >& rhs , uint a , uint b ); // \u914d\u5217\u306e a \u756a\u76ee\u304b\u3089 b \u756a\u76ee\u307e\u3067\u306e\u5408\u8a08. sum of the a th to b th of array. float sumK ( const std :: vector < float >& rhs ); float sumK_abs ( const std :: vector < float >& rhs ); float aveK ( const std :: vector < float >& rhs ); // \u5e73\u5747\u5024: average float aveK ( const std :: vector < float >& rhs , uint num ); // \u5e73\u5747\u5024: average in the first num elements. float varK ( const std :: vector < float >& rhs ); // \u4e0d\u504f\u5206\u6563/\u6a19\u672c\u5206\u6563 (variance): u^2 = (1/(n-1))*\u03a3(x_i-\u03bc)^2 float varK_p ( const std :: vector < float >& rhs ); // \u6bcd\u5206\u6563 (variance population): \u03c3^2 = (1/n)*\u03a3(x_i-\u03bc)^2 float stdevK ( const std :: vector < float >& rhs ); // \u6a19\u672c\u6a19\u6e96\u504f\u5dee (sample standard deviation): u = SQRT( (1/(n-1))*\u03a3(x_i-\u03bc)^2 ) float stdevK_p ( const std :: vector < float >& rhs ); // \u6a19\u6e96\u504f\u5dee (standard deviation): \u03c3 = SQRT( (1/n)*\u03a3(x_i-\u03bc)^2 ) double sumK ( const std :: vector < double >& rhs ); double sumK ( const std :: vector < double >& rhs , uint a , uint b ); // \u914d\u5217\u306e a \u756a\u76ee\u304b\u3089 b \u756a\u76ee\u307e\u3067\u306e\u5408\u8a08. sum of the a th to b th of array. double sumK_abs ( const std :: vector < double >& rhs ); double aveK ( const std :: vector < double >& rhs ); // \u5e73\u5747\u5024: average double aveK ( const std :: vector < double >& rhs , uint num ); // \u5e73\u5747\u5024: average in the first num elements. double varK ( const std :: vector < double >& rhs ); // \u4e0d\u504f\u5206\u6563/\u6a19\u672c\u5206\u6563 (variance): u^2 = (1/(n-1))*\u03a3(x_i-\u03bc)^2 double varK_p ( const std :: vector < double >& rhs ); // \u6bcd\u5206\u6563 (variance population): \u03c3^2 = (1/n)*\u03a3(x_i-\u03bc)^2 double stdevK ( const std :: vector < double >& rhs ); // \u6a19\u672c\u6a19\u6e96\u504f\u5dee (sample standard deviation): u = SQRT( (1/(n-1))*\u03a3(x_i-\u03bc)^2 ) double stdevK_p ( const std :: vector < double >& rhs ); // \u6a19\u6e96\u504f\u5dee (standard deviation): \u03c3 = SQRT( (1/n)*\u03a3(x_i-\u03bc)^2 ) std :: vector < uint64 > prime ( uint64 rhs ); // get a list of prime number under rhs. struct fact { uint64 prime ; uint64 num ; }; std :: vector < struct fact > factor ( uint64 rhs ); // get a list of prime factorization std :: vector < uint64 > divisor ( const std :: vector < struct sstd :: fact >& rhs ); // get a list of all divisors std :: vector < uint64 > divisor ( uint64 rhs ); // get a list of all of the divisors. uint8 pow ( const uint8 & base , const uint8 & exp ); uint16 pow ( const uint16 & base , const uint16 & exp ); uint32 pow ( const uint32 & base , const uint32 & exp ); uint64 pow ( const uint64 & base , const uint64 & exp ); float pow ( const float & base , const float & exp ); double pow ( const double & base , const double & exp ); //----------------------------------------------------------------------------------------------------------------------------------------------- template < typename T > inline T min ( const std :: vector < T >& rhs ); template < typename T > inline T min_abs ( const std :: vector < T >& rhs ); template < typename T > inline T max ( const std :: vector < T >& rhs ); template < typename T > inline T max_abs ( const std :: vector < T >& rhs ); template < typename T > inline T min ( const sstd :: mat_c < T >& rhs ); template < typename T > inline T min_abs ( const sstd :: mat_c < T >& rhs ); template < typename T > inline T max ( const sstd :: mat_c < T >& rhs ); template < typename T > inline T max_abs ( const sstd :: mat_c < T >& rhs ); template < typename T > inline T min ( const sstd :: mat_r < T >& rhs ); template < typename T > inline T min_abs ( const sstd :: mat_r < T >& rhs ); template < typename T > inline T max ( const sstd :: mat_r < T >& rhs ); template < typename T > inline T max_abs ( const sstd :: mat_r < T >& rhs ); template < typename T > inline T min ( T && lhs , T && rhs ); template < typename T > inline T min ( T && head1 , T && head2 , T && tail ); template < typename Head , typename ... Tail > inline Head min ( Head && head1 , Head && head2 , Tail && ... tail ); template < typename T > inline T max ( T && lhs , T && rhs ); template < typename T > inline T max ( T && head1 , T && head2 , T && tail ); template < typename Head , typename ... Tail > inline Head max ( Head && head1 , Head && head2 , Tail && ... tail ); //----------------------------------------------------------------------------------------------------------------------------------------------- template < typename T > uint argmin ( const std :: vector < T >& rhs ); template < typename T > uint argmin_abs ( const std :: vector < T >& rhs ); template < typename T > uint argmax ( const std :: vector < T >& rhs ); template < typename T > uint argmax_abs ( const std :: vector < T >& rhs ); template < typename T > uint argmin ( const sstd :: mat_c < T >& rhs ); template < typename T > uint argmin_abs ( const sstd :: mat_c < T >& rhs ); template < typename T > uint argmax ( const sstd :: mat_c < T >& rhs ); template < typename T > uint argmax_abs ( const sstd :: mat_c < T >& rhs ); template < typename T > uint argmin ( const sstd :: mat_r < T >& rhs ); template < typename T > uint argmin_abs ( const sstd :: mat_r < T >& rhs ); template < typename T > uint argmax ( const sstd :: mat_r < T >& rhs ); template < typename T > uint argmax_abs ( const sstd :: mat_r < T >& rhs ); /* // TODO: argmin // TODO: argmax template<typename T> std::tuple<uint,uint> argminXY (const sstd::mat_c<T>& rhs); template<typename T> std::tuple<uint,uint> argminXY_abs(const sstd::mat_c<T>& rhs); template<typename T> std::tuple<uint,uint> argmaxXY (const sstd::mat_c<T>& rhs); template<typename T> std::tuple<uint,uint> argmaxXY_abs(const sstd::mat_c<T>& rhs); template<typename T> std::tuple<uint,uint> argminXY (const sstd::mat_r<T>& rhs); template<typename T> std::tuple<uint,uint> argminXY_abs(const sstd::mat_r<T>& rhs); template<typename T> std::tuple<uint,uint> argmaxXY (const sstd::mat_r<T>& rhs); template<typename T> std::tuple<uint,uint> argmaxXY_abs(const sstd::mat_r<T>& rhs); //*/ //----------------------------------------------------------------------------------------------------------------------------------------------- // binary search template < typename T > T nearest_down ( const std :: vector < T >& v , const T & value ); template < typename T > T nearest_up ( const std :: vector < T >& v , const T & value ); template < typename T > uint argnearest_down ( const std :: vector < T >& v , const T & value ); template < typename T > uint argnearest_up ( const std :: vector < T >& v , const T & value ); //----------------------------------------------------------------------------------------------------------------------------------------------- // sort template < typename T > inline void sort ( std :: vector < T >& rhs ){ std :: sort ( rhs . begin (), rhs . end ()); } // Ascending: \u6607\u9806: 0, 1, 2, ... template < typename T > inline std :: vector < T > sorted ( const std :: vector < T >& rhs_in ){ std :: vector < T > rhs = rhs_in ; std :: sort ( rhs . begin (), rhs . end ()); return rhs ; } // Ascending: \u6607\u9806: 0, 1, 2, ... template < typename T > inline std :: vector < T > sorted ( std :: vector < T >&& rhs ){ std :: sort ( rhs . begin (), rhs . end ()); return rhs ; } // Ascending: \u6607\u9806: 0, 1, 2, ... template < typename T > inline void sort_gr ( std :: vector < T >& rhs ){ std :: sort ( rhs . begin (), rhs . end (), std :: greater < T > ()); } // Descending: \u964d\u9806: 9, 8, 7, ... template < typename T > inline std :: vector < T > sorted_gr ( const std :: vector < T >& rhs_in ){ std :: vector < T > rhs = rhs_in ; std :: sort ( rhs . begin (), rhs . end (), std :: greater < T > ()); return rhs ; } // Descending: \u964d\u9806: 9, 8, 7, ... template < typename T > inline std :: vector < T > sorted_gr ( std :: vector < T >&& rhs ){ std :: sort ( rhs . begin (), rhs . end (), std :: greater < T > ()); return rhs ; } // Descending: \u964d\u9806: 9, 8, 7, ... //----------------------------------------------------------------------------------------------------------------------------------------------- // sort for multiple vector template < typename Head , typename ... Tail > inline void sort ( Head && head , Tail && ... tail ); // Ascending: \u6607\u9806: 0, 1, 2, ... template < typename Head , typename ... Tail > inline void sort_gr ( Head && head , Tail && ... tail ); // Descending: \u964d\u9806: 9, 8, 7, ... //----------------------------------------------------------------------------------------------------------------------------------------------- template < typename T > std :: vector < T > nonzero ( const std :: vector < T >& rhs ); // template <typename T> void padding (std::vector<T>& vecLhs, std::vector<T>& vecRhs); // <--> sstd::suppress(); // template <typename T> void suppress(std::vector<T>& vecLhs, std::vector<T>& vecRhs); // <--> sstd::padding(); or zfill template < typename ... Args > void suppress ( Args & ... args ); } Description Numerical calculation Function name Description round2even() round2odd() sum() sum_abs() ave() med() var() var_p() stdev() stdev_p() sumK() sumK_abs() aveK() varK() varK_p() stdevK() stdevK_p() pow() prime number calculation Function name Description prime() factor() divisor() search Function name Description min() returns minimum value of given arg(s). min() can specifies multiple args while args have the same type and is defined < operator. \u4e0e\u3048\u3089\u308c\u305f\u5024\u306e\u5185\uff0c\u6700\u3082\u5c0f\u3055\u3044\u5024\u3092\u8fd4\u3057\u307e\u3059\uff0e\u540c\u4e00\u578b\u3067 operator < \u304c\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\u578b\u3067\u3042\u308c\u3070\uff0c\u8907\u6570\u306e\u5f15\u6570\u3092\u6307\u5b9a\u3067\u304d\u307e\u3059\uff0e min_abs() max() returns minimum value of given arg(s). min() can specifies multiple args while args have the same type and is defined < operator. \u4e0e\u3048\u3089\u308c\u305f\u5024\u306e\u5185\uff0c\u6700\u3082\u5927\u304d\u3044\u5024\u3092\u8fd4\u3057\u307e\u3059\uff0e\u540c\u4e00\u578b\u3067 operator < \u304c\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\u578b\u3067\u3042\u308c\u3070\uff0c\u8907\u6570\u306e\u5f15\u6570\u3092\u6307\u5b9a\u3067\u304d\u307e\u3059\uff0e max_abs() argmin() argmin_abs() argmax() argmax_abs() nearest_down() nearest_up() argnearest_down() argnearest_up() sort Function name Description sort() sorts arg(s) value directly in ascending order. When multiple std::vector<T> s are specified to arg, all std::vector<T> s will be sorted according to the 1st arg. There is no limit to the number or type of std::vector<T> specified in the argument. \u5f15\u6570\u306e\u5024\u3092\u76f4\u63a5\u30bd\u30fc\u30c8\u3059\u308b\uff0e\u5024\u306f\u6607\u9806\u306b\u30bd\u30fc\u30c8\u3055\u308c\u308b\uff0e\u5f15\u6570\u306b std::vector<T> \u304c\u8907\u6570\u4e0e\u3048\u3089\u308c\u305f\u5834\u5408\u306f\uff0c\u7b2c\uff11\u5f15\u6570\u306e\u9806\u5e8f\u306b\u5f93\u3063\u3066\u4ed6\u306e\u5f15\u6570\u3092\u30bd\u30fc\u30c8\u3059\u308b\uff0e\u5f15\u6570\u306b\u6307\u5b9a\u3059\u308b std::vector<T> \u306e\u6570\u3084\u578b\u306b\u5236\u9650\u306f\u306a\u3044\uff0e sorted() returns sorted value of arg(s) in ascending order, and arg(s) will not changed. \u30bd\u30fc\u30c8\u7d50\u679c\u3092\u6607\u9806\u3067\u8fd4\u3059\uff0e\u5f15\u6570\u306f\u5909\u66f4\u3055\u308c\u306a\u3044\uff0e sort_gr() sorts arg(s) value directly in descending order. When multiple std::vector<T> s are specified to arg, all std::vector<T> s will be sorted according to the 1st arg. There is no limit to the number or type of std::vector<T> specified in the argument. \u5f15\u6570\u306e\u5024\u3092\u76f4\u63a5\u30bd\u30fc\u30c8\u3059\u308b\uff0e\u5024\u306f\u964d\u9806\u306b\u30bd\u30fc\u30c8\u3055\u308c\u308b\uff0e\u5f15\u6570\u306b std::vector<T> \u304c\u8907\u6570\u4e0e\u3048\u3089\u308c\u305f\u5834\u5408\u306f\uff0c\u7b2c\uff11\u5f15\u6570\u306e\u9806\u5e8f\u306b\u5f93\u3063\u3066\u4ed6\u306e\u5f15\u6570\u3092\u30bd\u30fc\u30c8\u3059\u308b\uff0e\u5f15\u6570\u306b\u6307\u5b9a\u3059\u308b std::vector<T> \u306e\u6570\u3084\u578b\u306b\u5236\u9650\u306f\u306a\u3044\uff0e sorted_gr() returns sorted value of arg(s) in descending order, and arg(s) will not changed. \u30bd\u30fc\u30c8\u7d50\u679c\u3092\u964d\u9806\u3067\u8fd4\u3059\uff0e\u5f15\u6570\u306f\u5909\u66f4\u3055\u308c\u306a\u3044\uff0e preprocess Function name Description nonzero() suppress() Usage Rounding main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: round2even ( 1.5 ) ); sstd :: printn ( sstd :: round2even ( 2.5 ) ); sstd :: printn ( sstd :: round2odd ( 1.5 ) ); sstd :: printn ( sstd :: round2odd ( 2.5 ) ); } Execution result sstd::round2even(1.5) = 2. sstd::round2even(2.5) = 2. sstd::round2odd(1.5) = 1. sstd::round2odd(2.5) = 3. Statistical processing sum(), sum_abs(), ave(), med(), var(), var_p(), min(), min_abs(), max(), max_abs(), argmin(), argmin_abs(), argmax() and argmax_abs() main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < double > v = { -5 , -4 , -3 , -2 , -1 , 0 , 1 , 2 , 3 , 4 }; sstd :: printn ( sstd :: sum ( v ) ); sstd :: printn ( sstd :: sum_abs ( v ) ); sstd :: printn ( sstd :: ave ( v ) ); sstd :: printn ( sstd :: med ( v ) ); sstd :: printn ( sstd :: var ( v ) ); sstd :: printn ( sstd :: var_p ( v ) ); sstd :: printn ( sstd :: stdev ( v ) ); sstd :: printn ( sstd :: stdev_p ( v ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: min ( v ) ); sstd :: printn ( sstd :: min_abs ( v ) ); sstd :: printn ( sstd :: max ( v ) ); sstd :: printn ( sstd :: max_abs ( v ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: argmin ( v ) ); sstd :: printn ( sstd :: argmin_abs ( v ) ); sstd :: printn ( sstd :: argmax ( v ) ); sstd :: printn ( sstd :: argmax_abs ( v ) ); } Execution result sstd::sum( v ) = -5. sstd::sum_abs( v ) = 25. sstd::ave( v ) = -0.5 sstd::med( v ) = -0.5 sstd::var( v ) = 9.16667 sstd::var_p( v ) = 8.25 sstd::stdev( v ) = 3.02765 sstd::stdev_p( v ) = 2.87228 sstd::min( v ) = -5. sstd::min_abs( v ) = 0. sstd::max( v ) = 4. sstd::max_abs( v ) = -5. sstd::argmin( v ) = 0 sstd::argmin_abs( v ) = 5 sstd::argmax( v ) = 9 sstd::argmax_abs( v ) = 0 min() and max() for equal or more than three args main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: min ( -5 , -4 , -3 , -2 , -1 , 0 , 1 , 2 , 3 , 4 ) ); sstd :: printn ( sstd :: max ( -5 , -4 , -3 , -2 , -1 , 0 , 1 , 2 , 3 , 4 ) ); } Execution result sstd::min(-5,-4,-3,-2,-1,0,1,2,3,4) = -5 sstd::max(-5,-4,-3,-2,-1,0,1,2,3,4) = 4 Searching main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < double > v = { -5 , -4 , -3 , -2 , -1 , 0 , 1 , 2 , 3 , 4 }; sstd :: printn ( sstd :: nearest_down ( v , 0.5 ) ); sstd :: printn ( sstd :: nearest_up ( v , 0.5 ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: argnearest_down ( v , 0.5 ) ); sstd :: printn ( sstd :: argnearest_up ( v , 0.5 ) ); } Execution result sstd::nearest_down(v, 0.5) = 0. sstd::nearest_up(v, 0.5) = 1. sstd::argnearest_down(v, 0.5) = 5 sstd::argnearest_up(v, 0.5) = 6 Sorting sort(), sort_gr() main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < double > v_base = { -1 , -5 , 2 , -3 , 3 , 4 , -2 , 0 , 1 , -4 }; sstd :: sort ( v_base ); sstd :: printn ( v_base ); sstd :: sort_gr ( v_base ); sstd :: printn ( v_base ); } Execution result v_base = [-5. -4. -3. -2. -1. 0. 1. 2. 3. 4.] v_base = [4. 3. 2. 1. 0. -1. -2. -3. -4. -5.] sort() for multiple vector main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1_sorting_seed = { 1 , 3 , 5 , 2 , 4 }; std :: vector < std :: string > v2 = { \"one\" , \"three\" , \"five\" , \"two\" , \"four\" }; std :: vector < std :: string > v3 = { \"1\" , \"3\" , \"5\" , \"2\" , \"4\" }; std :: vector < std :: string > v4 = { \"a\" , \"c\" , \"e\" , \"b\" , \"d\" }; std :: vector < std :: string > v5 = { \"A\" , \"C\" , \"E\" , \"B\" , \"D\" }; sstd :: sort ( v1_sorting_seed , v2 , v3 , v4 , v5 ); sstd :: printn ( v1_sorting_seed ); sstd :: printn ( v2 ); sstd :: printn ( v3 ); sstd :: printn ( v4 ); sstd :: printn ( v5 ); } Execution result v1_sorting_seed = [1 2 3 4 5] v2 = [\"one\" \"two\" \"three\" \"four\" \"five\"] v3 = [\"1\" \"2\" \"3\" \"4\" \"5\"] v4 = [\"a\" \"b\" \"c\" \"d\" \"e\"] v5 = [\"A\" \"B\" \"C\" \"D\" \"E\"] sort_gr() for multiple vector main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1_sorting_seed = { 1 , 3 , 5 , 2 , 4 }; std :: vector < std :: string > v2 = { \"one\" , \"three\" , \"five\" , \"two\" , \"four\" }; std :: vector < std :: string > v3 = { \"1\" , \"3\" , \"5\" , \"2\" , \"4\" }; std :: vector < std :: string > v4 = { \"a\" , \"c\" , \"e\" , \"b\" , \"d\" }; std :: vector < std :: string > v5 = { \"A\" , \"C\" , \"E\" , \"B\" , \"D\" }; sstd :: sort_gr ( v1_sorting_seed , v2 , v3 , v4 , v5 ); sstd :: printn ( v1_sorting_seed ); sstd :: printn ( v2 ); sstd :: printn ( v3 ); sstd :: printn ( v4 ); sstd :: printn ( v5 ); } Execution result v1_sorting_seed = [5 4 3 2 1] v2 = [\"five\" \"four\" \"three\" \"two\" \"one\"] v3 = [\"5\" \"4\" \"3\" \"2\" \"1\"] v4 = [\"e\" \"d\" \"c\" \"b\" \"a\"] v5 = [\"E\" \"D\" \"C\" \"B\" \"A\"] sorted(), sorted_gr() main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < double > v_base = { -1 , -5 , 2 , -3 , 3 , 4 , -2 , 0 , 1 , -4 }; sstd :: printn ( sstd :: sorted ( v_base ) ); sstd :: printn ( sstd :: sorted_gr ( v_base ) ); printf ( \" \\n \" ); sstd :: printn ( v_base ); } Execution result sstd::sorted( v_base ) = [-5. -4. -3. -2. -1. 0. 1. 2. 3. 4.] sstd::sorted_gr( v_base ) = [4. 3. 2. 1. 0. -1. -2. -3. -4. -5.] v_base = [-1. -5. 2. -3. 3. 4. -2. 0. 1. -4.] Preprocessing main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < double > v = { 1 , 2 , 3 , 0 , 4 }; sstd :: printn ( sstd :: nonzero ( v ) ); // suppressing vector to the same length before 0. std :: vector < double > in1 = { 1 , 2 , 3 , 0 , 4 }; std :: vector < double > in2 = { 1 , 2 , 3 }; std :: vector < uint > in3 = { 1 , 2 , 3 }; std :: vector < double > in4 = { 1 , 2 , 3 , 4 }; sstd :: suppress ( in1 , in2 , in3 , in4 ); sstd :: printn ( in1 ); sstd :: printn ( in2 ); sstd :: printn ( in3 ); sstd :: printn ( in4 ); } Execution result sstd::nonzero(v) = [1. 2. 3.] in1 = [1. 2. 3.] in2 = [1. 2. 3.] in3 = [1 2 3] in4 = [1. 2. 3.] Implementation Source: sstd/src/math.cpp Header: sstd/src/math.hpp Test: test/math.hpp","title":"math"},{"location":"src/math.html#math","text":"","title":"math"},{"location":"src/math.html#abstract","text":"math.hpp contains functions for mathematical and statistical calculations. math.hpp \u306f\u6570\u5b66\u30fb\u7d71\u8a08\u8a08\u7b97\u7528\u306e\u95a2\u6570\u3092\u53ce\u9332\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/math.html#header-file","text":"namespace sstd { float round2even ( float n ); double round2even ( double n ); float round2odd ( float n ); double round2odd ( double n ); template < typename T > T sum ( const std :: vector < T >& rhs ); template < typename T > T sum ( const std :: vector < T >& rhs , uint a , uint b ); template < class Itr > typename std :: iterator_traits < Itr >:: value_type sum ( const Itr first , const Itr last ); // using Pairwise summation algorithm. float sum ( const std :: vector < float >:: iterator first , const std :: vector < float >:: iterator last ); float sum ( const std :: vector < float >& rhs , uint a , uint b ); // \u914d\u5217\u306e a \u756a\u76ee\u304b\u3089 b \u756a\u76ee\u307e\u3067\u306e\u5408\u8a08. sum of the a th to b th of array. float sum ( const std :: vector < float >& rhs ); float sum_abs ( const std :: vector < float >& rhs ); float ave ( const std :: vector < float >& rhs ); // \u5e73\u5747\u5024: average float med ( std :: vector < float > rhs ); // \u4e2d\u592e\u5024: median // copy rhs // If rhs.size () is even, average of the two median values is returned. // float mod (const std::vector<float>& rhs); // \u6700\u983b\u5024: mode float var ( const std :: vector < float >& rhs ); // \u4e0d\u504f\u5206\u6563/\u6a19\u672c\u5206\u6563 (variance): u^2 = (1/(n-1))*\u03a3(x_i-\u03bc)^2 float var_p ( const std :: vector < float >& rhs ); // \u6bcd\u5206\u6563 (variance population): \u03c3^2 = (1/n)*\u03a3(x_i-\u03bc)^2 float stdev ( const std :: vector < float >& rhs ); // \u6a19\u672c\u6a19\u6e96\u504f\u5dee (sample standard deviation): u = SQRT( (1/(n-1))*\u03a3(x_i-\u03bc)^2 ) float stdev_p ( const std :: vector < float >& rhs ); // \u6a19\u6e96\u504f\u5dee (standard deviation): \u03c3 = SQRT( (1/n)*\u03a3(x_i-\u03bc)^2 ) double sum ( const std :: vector < double >:: iterator first , const std :: vector < double >:: iterator last ); double sum ( const std :: vector < double >& rhs , uint a , uint b ); // \u914d\u5217\u306e a \u756a\u76ee\u304b\u3089 b \u756a\u76ee\u307e\u3067\u306e\u5408\u8a08. sum of the a th to b th of array. double sum ( const std :: vector < double >& rhs ); double sum_abs ( const std :: vector < double >& rhs ); double ave ( const std :: vector < double >& rhs ); // \u5e73\u5747\u5024: average double med ( std :: vector < double > rhs ); // \u4e2d\u592e\u5024: median // copy rhs // If rhs.size () is even, average of the two median values is returned. // double mod (const std::vector<double>& rhs); // \u6700\u983b\u5024: mode double var ( const std :: vector < double >& rhs ); // \u4e0d\u504f\u5206\u6563/\u6a19\u672c\u5206\u6563 (variance): u^2 = (1/(n-1))*\u03a3(x_i-\u03bc)^2 double var_p ( const std :: vector < double >& rhs ); // \u6bcd\u5206\u6563 (variance population): \u03c3^2 = (1/n)*\u03a3(x_i-\u03bc)^2 double stdev ( const std :: vector < double >& rhs ); // \u6a19\u672c\u6a19\u6e96\u504f\u5dee (sample standard deviation): u = SQRT( (1/(n-1))*\u03a3(x_i-\u03bc)^2 ) double stdev_p ( const std :: vector < double >& rhs ); // \u6a19\u6e96\u504f\u5dee (standard deviation): \u03c3 = SQRT( (1/n)*\u03a3(x_i-\u03bc)^2 ) // K: using Kahan summation algorithm float sumK ( const std :: vector < float >& rhs , uint a , uint b ); // \u914d\u5217\u306e a \u756a\u76ee\u304b\u3089 b \u756a\u76ee\u307e\u3067\u306e\u5408\u8a08. sum of the a th to b th of array. float sumK ( const std :: vector < float >& rhs ); float sumK_abs ( const std :: vector < float >& rhs ); float aveK ( const std :: vector < float >& rhs ); // \u5e73\u5747\u5024: average float aveK ( const std :: vector < float >& rhs , uint num ); // \u5e73\u5747\u5024: average in the first num elements. float varK ( const std :: vector < float >& rhs ); // \u4e0d\u504f\u5206\u6563/\u6a19\u672c\u5206\u6563 (variance): u^2 = (1/(n-1))*\u03a3(x_i-\u03bc)^2 float varK_p ( const std :: vector < float >& rhs ); // \u6bcd\u5206\u6563 (variance population): \u03c3^2 = (1/n)*\u03a3(x_i-\u03bc)^2 float stdevK ( const std :: vector < float >& rhs ); // \u6a19\u672c\u6a19\u6e96\u504f\u5dee (sample standard deviation): u = SQRT( (1/(n-1))*\u03a3(x_i-\u03bc)^2 ) float stdevK_p ( const std :: vector < float >& rhs ); // \u6a19\u6e96\u504f\u5dee (standard deviation): \u03c3 = SQRT( (1/n)*\u03a3(x_i-\u03bc)^2 ) double sumK ( const std :: vector < double >& rhs ); double sumK ( const std :: vector < double >& rhs , uint a , uint b ); // \u914d\u5217\u306e a \u756a\u76ee\u304b\u3089 b \u756a\u76ee\u307e\u3067\u306e\u5408\u8a08. sum of the a th to b th of array. double sumK_abs ( const std :: vector < double >& rhs ); double aveK ( const std :: vector < double >& rhs ); // \u5e73\u5747\u5024: average double aveK ( const std :: vector < double >& rhs , uint num ); // \u5e73\u5747\u5024: average in the first num elements. double varK ( const std :: vector < double >& rhs ); // \u4e0d\u504f\u5206\u6563/\u6a19\u672c\u5206\u6563 (variance): u^2 = (1/(n-1))*\u03a3(x_i-\u03bc)^2 double varK_p ( const std :: vector < double >& rhs ); // \u6bcd\u5206\u6563 (variance population): \u03c3^2 = (1/n)*\u03a3(x_i-\u03bc)^2 double stdevK ( const std :: vector < double >& rhs ); // \u6a19\u672c\u6a19\u6e96\u504f\u5dee (sample standard deviation): u = SQRT( (1/(n-1))*\u03a3(x_i-\u03bc)^2 ) double stdevK_p ( const std :: vector < double >& rhs ); // \u6a19\u6e96\u504f\u5dee (standard deviation): \u03c3 = SQRT( (1/n)*\u03a3(x_i-\u03bc)^2 ) std :: vector < uint64 > prime ( uint64 rhs ); // get a list of prime number under rhs. struct fact { uint64 prime ; uint64 num ; }; std :: vector < struct fact > factor ( uint64 rhs ); // get a list of prime factorization std :: vector < uint64 > divisor ( const std :: vector < struct sstd :: fact >& rhs ); // get a list of all divisors std :: vector < uint64 > divisor ( uint64 rhs ); // get a list of all of the divisors. uint8 pow ( const uint8 & base , const uint8 & exp ); uint16 pow ( const uint16 & base , const uint16 & exp ); uint32 pow ( const uint32 & base , const uint32 & exp ); uint64 pow ( const uint64 & base , const uint64 & exp ); float pow ( const float & base , const float & exp ); double pow ( const double & base , const double & exp ); //----------------------------------------------------------------------------------------------------------------------------------------------- template < typename T > inline T min ( const std :: vector < T >& rhs ); template < typename T > inline T min_abs ( const std :: vector < T >& rhs ); template < typename T > inline T max ( const std :: vector < T >& rhs ); template < typename T > inline T max_abs ( const std :: vector < T >& rhs ); template < typename T > inline T min ( const sstd :: mat_c < T >& rhs ); template < typename T > inline T min_abs ( const sstd :: mat_c < T >& rhs ); template < typename T > inline T max ( const sstd :: mat_c < T >& rhs ); template < typename T > inline T max_abs ( const sstd :: mat_c < T >& rhs ); template < typename T > inline T min ( const sstd :: mat_r < T >& rhs ); template < typename T > inline T min_abs ( const sstd :: mat_r < T >& rhs ); template < typename T > inline T max ( const sstd :: mat_r < T >& rhs ); template < typename T > inline T max_abs ( const sstd :: mat_r < T >& rhs ); template < typename T > inline T min ( T && lhs , T && rhs ); template < typename T > inline T min ( T && head1 , T && head2 , T && tail ); template < typename Head , typename ... Tail > inline Head min ( Head && head1 , Head && head2 , Tail && ... tail ); template < typename T > inline T max ( T && lhs , T && rhs ); template < typename T > inline T max ( T && head1 , T && head2 , T && tail ); template < typename Head , typename ... Tail > inline Head max ( Head && head1 , Head && head2 , Tail && ... tail ); //----------------------------------------------------------------------------------------------------------------------------------------------- template < typename T > uint argmin ( const std :: vector < T >& rhs ); template < typename T > uint argmin_abs ( const std :: vector < T >& rhs ); template < typename T > uint argmax ( const std :: vector < T >& rhs ); template < typename T > uint argmax_abs ( const std :: vector < T >& rhs ); template < typename T > uint argmin ( const sstd :: mat_c < T >& rhs ); template < typename T > uint argmin_abs ( const sstd :: mat_c < T >& rhs ); template < typename T > uint argmax ( const sstd :: mat_c < T >& rhs ); template < typename T > uint argmax_abs ( const sstd :: mat_c < T >& rhs ); template < typename T > uint argmin ( const sstd :: mat_r < T >& rhs ); template < typename T > uint argmin_abs ( const sstd :: mat_r < T >& rhs ); template < typename T > uint argmax ( const sstd :: mat_r < T >& rhs ); template < typename T > uint argmax_abs ( const sstd :: mat_r < T >& rhs ); /* // TODO: argmin // TODO: argmax template<typename T> std::tuple<uint,uint> argminXY (const sstd::mat_c<T>& rhs); template<typename T> std::tuple<uint,uint> argminXY_abs(const sstd::mat_c<T>& rhs); template<typename T> std::tuple<uint,uint> argmaxXY (const sstd::mat_c<T>& rhs); template<typename T> std::tuple<uint,uint> argmaxXY_abs(const sstd::mat_c<T>& rhs); template<typename T> std::tuple<uint,uint> argminXY (const sstd::mat_r<T>& rhs); template<typename T> std::tuple<uint,uint> argminXY_abs(const sstd::mat_r<T>& rhs); template<typename T> std::tuple<uint,uint> argmaxXY (const sstd::mat_r<T>& rhs); template<typename T> std::tuple<uint,uint> argmaxXY_abs(const sstd::mat_r<T>& rhs); //*/ //----------------------------------------------------------------------------------------------------------------------------------------------- // binary search template < typename T > T nearest_down ( const std :: vector < T >& v , const T & value ); template < typename T > T nearest_up ( const std :: vector < T >& v , const T & value ); template < typename T > uint argnearest_down ( const std :: vector < T >& v , const T & value ); template < typename T > uint argnearest_up ( const std :: vector < T >& v , const T & value ); //----------------------------------------------------------------------------------------------------------------------------------------------- // sort template < typename T > inline void sort ( std :: vector < T >& rhs ){ std :: sort ( rhs . begin (), rhs . end ()); } // Ascending: \u6607\u9806: 0, 1, 2, ... template < typename T > inline std :: vector < T > sorted ( const std :: vector < T >& rhs_in ){ std :: vector < T > rhs = rhs_in ; std :: sort ( rhs . begin (), rhs . end ()); return rhs ; } // Ascending: \u6607\u9806: 0, 1, 2, ... template < typename T > inline std :: vector < T > sorted ( std :: vector < T >&& rhs ){ std :: sort ( rhs . begin (), rhs . end ()); return rhs ; } // Ascending: \u6607\u9806: 0, 1, 2, ... template < typename T > inline void sort_gr ( std :: vector < T >& rhs ){ std :: sort ( rhs . begin (), rhs . end (), std :: greater < T > ()); } // Descending: \u964d\u9806: 9, 8, 7, ... template < typename T > inline std :: vector < T > sorted_gr ( const std :: vector < T >& rhs_in ){ std :: vector < T > rhs = rhs_in ; std :: sort ( rhs . begin (), rhs . end (), std :: greater < T > ()); return rhs ; } // Descending: \u964d\u9806: 9, 8, 7, ... template < typename T > inline std :: vector < T > sorted_gr ( std :: vector < T >&& rhs ){ std :: sort ( rhs . begin (), rhs . end (), std :: greater < T > ()); return rhs ; } // Descending: \u964d\u9806: 9, 8, 7, ... //----------------------------------------------------------------------------------------------------------------------------------------------- // sort for multiple vector template < typename Head , typename ... Tail > inline void sort ( Head && head , Tail && ... tail ); // Ascending: \u6607\u9806: 0, 1, 2, ... template < typename Head , typename ... Tail > inline void sort_gr ( Head && head , Tail && ... tail ); // Descending: \u964d\u9806: 9, 8, 7, ... //----------------------------------------------------------------------------------------------------------------------------------------------- template < typename T > std :: vector < T > nonzero ( const std :: vector < T >& rhs ); // template <typename T> void padding (std::vector<T>& vecLhs, std::vector<T>& vecRhs); // <--> sstd::suppress(); // template <typename T> void suppress(std::vector<T>& vecLhs, std::vector<T>& vecRhs); // <--> sstd::padding(); or zfill template < typename ... Args > void suppress ( Args & ... args ); }","title":"Header file"},{"location":"src/math.html#description","text":"","title":"Description"},{"location":"src/math.html#numerical-calculation","text":"Function name Description round2even() round2odd() sum() sum_abs() ave() med() var() var_p() stdev() stdev_p() sumK() sumK_abs() aveK() varK() varK_p() stdevK() stdevK_p() pow()","title":"Numerical calculation"},{"location":"src/math.html#prime-number-calculation","text":"Function name Description prime() factor() divisor()","title":"prime number calculation"},{"location":"src/math.html#search","text":"Function name Description min() returns minimum value of given arg(s). min() can specifies multiple args while args have the same type and is defined < operator. \u4e0e\u3048\u3089\u308c\u305f\u5024\u306e\u5185\uff0c\u6700\u3082\u5c0f\u3055\u3044\u5024\u3092\u8fd4\u3057\u307e\u3059\uff0e\u540c\u4e00\u578b\u3067 operator < \u304c\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\u578b\u3067\u3042\u308c\u3070\uff0c\u8907\u6570\u306e\u5f15\u6570\u3092\u6307\u5b9a\u3067\u304d\u307e\u3059\uff0e min_abs() max() returns minimum value of given arg(s). min() can specifies multiple args while args have the same type and is defined < operator. \u4e0e\u3048\u3089\u308c\u305f\u5024\u306e\u5185\uff0c\u6700\u3082\u5927\u304d\u3044\u5024\u3092\u8fd4\u3057\u307e\u3059\uff0e\u540c\u4e00\u578b\u3067 operator < \u304c\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\u578b\u3067\u3042\u308c\u3070\uff0c\u8907\u6570\u306e\u5f15\u6570\u3092\u6307\u5b9a\u3067\u304d\u307e\u3059\uff0e max_abs() argmin() argmin_abs() argmax() argmax_abs() nearest_down() nearest_up() argnearest_down() argnearest_up()","title":"search"},{"location":"src/math.html#sort","text":"Function name Description sort() sorts arg(s) value directly in ascending order. When multiple std::vector<T> s are specified to arg, all std::vector<T> s will be sorted according to the 1st arg. There is no limit to the number or type of std::vector<T> specified in the argument. \u5f15\u6570\u306e\u5024\u3092\u76f4\u63a5\u30bd\u30fc\u30c8\u3059\u308b\uff0e\u5024\u306f\u6607\u9806\u306b\u30bd\u30fc\u30c8\u3055\u308c\u308b\uff0e\u5f15\u6570\u306b std::vector<T> \u304c\u8907\u6570\u4e0e\u3048\u3089\u308c\u305f\u5834\u5408\u306f\uff0c\u7b2c\uff11\u5f15\u6570\u306e\u9806\u5e8f\u306b\u5f93\u3063\u3066\u4ed6\u306e\u5f15\u6570\u3092\u30bd\u30fc\u30c8\u3059\u308b\uff0e\u5f15\u6570\u306b\u6307\u5b9a\u3059\u308b std::vector<T> \u306e\u6570\u3084\u578b\u306b\u5236\u9650\u306f\u306a\u3044\uff0e sorted() returns sorted value of arg(s) in ascending order, and arg(s) will not changed. \u30bd\u30fc\u30c8\u7d50\u679c\u3092\u6607\u9806\u3067\u8fd4\u3059\uff0e\u5f15\u6570\u306f\u5909\u66f4\u3055\u308c\u306a\u3044\uff0e sort_gr() sorts arg(s) value directly in descending order. When multiple std::vector<T> s are specified to arg, all std::vector<T> s will be sorted according to the 1st arg. There is no limit to the number or type of std::vector<T> specified in the argument. \u5f15\u6570\u306e\u5024\u3092\u76f4\u63a5\u30bd\u30fc\u30c8\u3059\u308b\uff0e\u5024\u306f\u964d\u9806\u306b\u30bd\u30fc\u30c8\u3055\u308c\u308b\uff0e\u5f15\u6570\u306b std::vector<T> \u304c\u8907\u6570\u4e0e\u3048\u3089\u308c\u305f\u5834\u5408\u306f\uff0c\u7b2c\uff11\u5f15\u6570\u306e\u9806\u5e8f\u306b\u5f93\u3063\u3066\u4ed6\u306e\u5f15\u6570\u3092\u30bd\u30fc\u30c8\u3059\u308b\uff0e\u5f15\u6570\u306b\u6307\u5b9a\u3059\u308b std::vector<T> \u306e\u6570\u3084\u578b\u306b\u5236\u9650\u306f\u306a\u3044\uff0e sorted_gr() returns sorted value of arg(s) in descending order, and arg(s) will not changed. \u30bd\u30fc\u30c8\u7d50\u679c\u3092\u964d\u9806\u3067\u8fd4\u3059\uff0e\u5f15\u6570\u306f\u5909\u66f4\u3055\u308c\u306a\u3044\uff0e","title":"sort"},{"location":"src/math.html#preprocess","text":"Function name Description nonzero() suppress()","title":"preprocess"},{"location":"src/math.html#usage","text":"","title":"Usage"},{"location":"src/math.html#rounding","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: round2even ( 1.5 ) ); sstd :: printn ( sstd :: round2even ( 2.5 ) ); sstd :: printn ( sstd :: round2odd ( 1.5 ) ); sstd :: printn ( sstd :: round2odd ( 2.5 ) ); } Execution result sstd::round2even(1.5) = 2. sstd::round2even(2.5) = 2. sstd::round2odd(1.5) = 1. sstd::round2odd(2.5) = 3.","title":"Rounding"},{"location":"src/math.html#statistical-processing","text":"","title":"Statistical processing"},{"location":"src/math.html#sum-sum_abs-ave-med-var-var_p-min-min_abs-max-max_abs-argmin-argmin_abs-argmax-and-argmax_abs","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < double > v = { -5 , -4 , -3 , -2 , -1 , 0 , 1 , 2 , 3 , 4 }; sstd :: printn ( sstd :: sum ( v ) ); sstd :: printn ( sstd :: sum_abs ( v ) ); sstd :: printn ( sstd :: ave ( v ) ); sstd :: printn ( sstd :: med ( v ) ); sstd :: printn ( sstd :: var ( v ) ); sstd :: printn ( sstd :: var_p ( v ) ); sstd :: printn ( sstd :: stdev ( v ) ); sstd :: printn ( sstd :: stdev_p ( v ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: min ( v ) ); sstd :: printn ( sstd :: min_abs ( v ) ); sstd :: printn ( sstd :: max ( v ) ); sstd :: printn ( sstd :: max_abs ( v ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: argmin ( v ) ); sstd :: printn ( sstd :: argmin_abs ( v ) ); sstd :: printn ( sstd :: argmax ( v ) ); sstd :: printn ( sstd :: argmax_abs ( v ) ); } Execution result sstd::sum( v ) = -5. sstd::sum_abs( v ) = 25. sstd::ave( v ) = -0.5 sstd::med( v ) = -0.5 sstd::var( v ) = 9.16667 sstd::var_p( v ) = 8.25 sstd::stdev( v ) = 3.02765 sstd::stdev_p( v ) = 2.87228 sstd::min( v ) = -5. sstd::min_abs( v ) = 0. sstd::max( v ) = 4. sstd::max_abs( v ) = -5. sstd::argmin( v ) = 0 sstd::argmin_abs( v ) = 5 sstd::argmax( v ) = 9 sstd::argmax_abs( v ) = 0","title":"sum(), sum_abs(), ave(), med(), var(), var_p(), min(), min_abs(), max(), max_abs(), argmin(), argmin_abs(), argmax() and argmax_abs()"},{"location":"src/math.html#min-and-max-for-equal-or-more-than-three-args","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: min ( -5 , -4 , -3 , -2 , -1 , 0 , 1 , 2 , 3 , 4 ) ); sstd :: printn ( sstd :: max ( -5 , -4 , -3 , -2 , -1 , 0 , 1 , 2 , 3 , 4 ) ); } Execution result sstd::min(-5,-4,-3,-2,-1,0,1,2,3,4) = -5 sstd::max(-5,-4,-3,-2,-1,0,1,2,3,4) = 4","title":"min() and max() for equal or more than three args"},{"location":"src/math.html#searching","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < double > v = { -5 , -4 , -3 , -2 , -1 , 0 , 1 , 2 , 3 , 4 }; sstd :: printn ( sstd :: nearest_down ( v , 0.5 ) ); sstd :: printn ( sstd :: nearest_up ( v , 0.5 ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: argnearest_down ( v , 0.5 ) ); sstd :: printn ( sstd :: argnearest_up ( v , 0.5 ) ); } Execution result sstd::nearest_down(v, 0.5) = 0. sstd::nearest_up(v, 0.5) = 1. sstd::argnearest_down(v, 0.5) = 5 sstd::argnearest_up(v, 0.5) = 6","title":"Searching"},{"location":"src/math.html#sorting","text":"","title":"Sorting"},{"location":"src/math.html#sort-sort_gr","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < double > v_base = { -1 , -5 , 2 , -3 , 3 , 4 , -2 , 0 , 1 , -4 }; sstd :: sort ( v_base ); sstd :: printn ( v_base ); sstd :: sort_gr ( v_base ); sstd :: printn ( v_base ); } Execution result v_base = [-5. -4. -3. -2. -1. 0. 1. 2. 3. 4.] v_base = [4. 3. 2. 1. 0. -1. -2. -3. -4. -5.]","title":"sort(), sort_gr()"},{"location":"src/math.html#sort-for-multiple-vector","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1_sorting_seed = { 1 , 3 , 5 , 2 , 4 }; std :: vector < std :: string > v2 = { \"one\" , \"three\" , \"five\" , \"two\" , \"four\" }; std :: vector < std :: string > v3 = { \"1\" , \"3\" , \"5\" , \"2\" , \"4\" }; std :: vector < std :: string > v4 = { \"a\" , \"c\" , \"e\" , \"b\" , \"d\" }; std :: vector < std :: string > v5 = { \"A\" , \"C\" , \"E\" , \"B\" , \"D\" }; sstd :: sort ( v1_sorting_seed , v2 , v3 , v4 , v5 ); sstd :: printn ( v1_sorting_seed ); sstd :: printn ( v2 ); sstd :: printn ( v3 ); sstd :: printn ( v4 ); sstd :: printn ( v5 ); } Execution result v1_sorting_seed = [1 2 3 4 5] v2 = [\"one\" \"two\" \"three\" \"four\" \"five\"] v3 = [\"1\" \"2\" \"3\" \"4\" \"5\"] v4 = [\"a\" \"b\" \"c\" \"d\" \"e\"] v5 = [\"A\" \"B\" \"C\" \"D\" \"E\"]","title":"sort() for multiple vector"},{"location":"src/math.html#sort_gr-for-multiple-vector","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1_sorting_seed = { 1 , 3 , 5 , 2 , 4 }; std :: vector < std :: string > v2 = { \"one\" , \"three\" , \"five\" , \"two\" , \"four\" }; std :: vector < std :: string > v3 = { \"1\" , \"3\" , \"5\" , \"2\" , \"4\" }; std :: vector < std :: string > v4 = { \"a\" , \"c\" , \"e\" , \"b\" , \"d\" }; std :: vector < std :: string > v5 = { \"A\" , \"C\" , \"E\" , \"B\" , \"D\" }; sstd :: sort_gr ( v1_sorting_seed , v2 , v3 , v4 , v5 ); sstd :: printn ( v1_sorting_seed ); sstd :: printn ( v2 ); sstd :: printn ( v3 ); sstd :: printn ( v4 ); sstd :: printn ( v5 ); } Execution result v1_sorting_seed = [5 4 3 2 1] v2 = [\"five\" \"four\" \"three\" \"two\" \"one\"] v3 = [\"5\" \"4\" \"3\" \"2\" \"1\"] v4 = [\"e\" \"d\" \"c\" \"b\" \"a\"] v5 = [\"E\" \"D\" \"C\" \"B\" \"A\"]","title":"sort_gr() for multiple vector"},{"location":"src/math.html#sorted-sorted_gr","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < double > v_base = { -1 , -5 , 2 , -3 , 3 , 4 , -2 , 0 , 1 , -4 }; sstd :: printn ( sstd :: sorted ( v_base ) ); sstd :: printn ( sstd :: sorted_gr ( v_base ) ); printf ( \" \\n \" ); sstd :: printn ( v_base ); } Execution result sstd::sorted( v_base ) = [-5. -4. -3. -2. -1. 0. 1. 2. 3. 4.] sstd::sorted_gr( v_base ) = [4. 3. 2. 1. 0. -1. -2. -3. -4. -5.] v_base = [-1. -5. 2. -3. 3. 4. -2. 0. 1. -4.]","title":"sorted(), sorted_gr()"},{"location":"src/math.html#preprocessing","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < double > v = { 1 , 2 , 3 , 0 , 4 }; sstd :: printn ( sstd :: nonzero ( v ) ); // suppressing vector to the same length before 0. std :: vector < double > in1 = { 1 , 2 , 3 , 0 , 4 }; std :: vector < double > in2 = { 1 , 2 , 3 }; std :: vector < uint > in3 = { 1 , 2 , 3 }; std :: vector < double > in4 = { 1 , 2 , 3 , 4 }; sstd :: suppress ( in1 , in2 , in3 , in4 ); sstd :: printn ( in1 ); sstd :: printn ( in2 ); sstd :: printn ( in3 ); sstd :: printn ( in4 ); } Execution result sstd::nonzero(v) = [1. 2. 3.] in1 = [1. 2. 3.] in2 = [1. 2. 3.] in3 = [1 2 3] in4 = [1. 2. 3.]","title":"Preprocessing"},{"location":"src/math.html#implementation","text":"Source: sstd/src/math.cpp Header: sstd/src/math.hpp Test: test/math.hpp","title":"Implementation"},{"location":"src/typeDef.h.html","text":"typeDef.h Abstract Type definitions on SSTD. These definitions are read by #include <sstd/sstd.hpp> . SSTD \u306b\u304a\u3051\u308b\u578b\u306e\u5b9a\u7fa9\uff0e #include <sstd/sstd.hpp> \u306b\u3088\u308a\u5b9a\u7fa9\u304c\u8aad\u307f\u8fbc\u307e\u308c\u308b\uff0e Header file #pragma once #ifdef _WIN32 typedef unsigned char uchar ; typedef __int8 int8 ; typedef __int16 int16 ; typedef __int32 int32 ; typedef __int64 int64 ; typedef unsigned __int8 uint8 ; typedef unsigned __int16 uint16 ; typedef unsigned __int32 uint32 ; typedef unsigned __int64 uint64 ; #else #include <stdint.h> // intXX_t, uintXX_t \u304c\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b typedef unsigned char uchar ; typedef int8_t int8 ; typedef int16_t int16 ; typedef int32_t int32 ; typedef int64_t int64 ; typedef uint8_t uint8 ; typedef uint16_t uint16 ; typedef uint32_t uint32 ; typedef uint64_t uint64 ; #endif #ifndef uint typedef unsigned int uint ; #endif Implementation Header: sstd/src/typeDef.hpp","title":"typeDef.h"},{"location":"src/typeDef.h.html#typedefh","text":"","title":"typeDef.h"},{"location":"src/typeDef.h.html#abstract","text":"Type definitions on SSTD. These definitions are read by #include <sstd/sstd.hpp> . SSTD \u306b\u304a\u3051\u308b\u578b\u306e\u5b9a\u7fa9\uff0e #include <sstd/sstd.hpp> \u306b\u3088\u308a\u5b9a\u7fa9\u304c\u8aad\u307f\u8fbc\u307e\u308c\u308b\uff0e","title":"Abstract"},{"location":"src/typeDef.h.html#header-file","text":"#pragma once #ifdef _WIN32 typedef unsigned char uchar ; typedef __int8 int8 ; typedef __int16 int16 ; typedef __int32 int32 ; typedef __int64 int64 ; typedef unsigned __int8 uint8 ; typedef unsigned __int16 uint16 ; typedef unsigned __int32 uint32 ; typedef unsigned __int64 uint64 ; #else #include <stdint.h> // intXX_t, uintXX_t \u304c\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b typedef unsigned char uchar ; typedef int8_t int8 ; typedef int16_t int16 ; typedef int32_t int32 ; typedef int64_t int64 ; typedef uint8_t uint8 ; typedef uint16_t uint16 ; typedef uint32_t uint32 ; typedef uint64_t uint64 ; #endif #ifndef uint typedef unsigned int uint ; #endif","title":"Header file"},{"location":"src/typeDef.h.html#implementation","text":"Header: sstd/src/typeDef.hpp","title":"Implementation"},{"location":"src/file/cp.html","text":"cp Abstract Functions to copy files and directories Header file namespace sstd { bool copy ( const char * pPath_src , const char * pPath_dst , const char * opt ); bool copy ( const std :: string & path_src , const char * pPath_dst , const char * opt ); bool copy ( const char * pPath_src , const std :: string & path_dst , const char * opt ); bool copy ( const std :: string & path_src , const std :: string & path_dst , const char * opt ); bool copy ( const char * pPath_src , const char * pPath_dst ); bool copy ( const std :: string & path_src , const char * pPath_dst ); bool copy ( const char * pPath_src , const std :: string & path_dst ); bool copy ( const std :: string & path_src , const std :: string & path_dst ); bool cp ( const char * pPath_src , const char * pPath_dst , const char * opt ); bool cp ( const std :: string & path_src , const char * pPath_dst , const char * opt ); bool cp ( const char * pPath_src , const std :: string & path_dst , const char * opt ); bool cp ( const std :: string & path_src , const std :: string & path_dst , const char * opt ); bool cp ( const char * pPath_src , const char * pPath_dst ); bool cp ( const std :: string & path_src , const char * pPath_dst ); bool cp ( const char * pPath_src , const std :: string & path_dst ); bool cp ( const std :: string & path_src , const std :: string & path_dst ); } Description Function name Description copy() A function to copy a single file, and give the same permission as the source. 1 \u3064\u306e\u30d5\u30a1\u30a4\u30eb\u3092\u30b3\u30d4\u30fc\u3059\u308b\u95a2\u6570\uff0e\u30b3\u30d4\u30fc\u5143\u306e\u30d5\u30a1\u30a4\u30eb\u3068\u540c\u4e00\u306e\u30d1\u30fc\u30df\u30c3\u30b7\u30e7\u30f3\u3092\u4ed8\u4e0e\u3057\u307e\u3059\uff0e cp() A function to copy files and directories, and give the same permission as the source. \u8907\u6570\u306e\u30d5\u30a1\u30a4\u30eb\u3084\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u30b3\u30d4\u30fc\u3059\u308b\u95a2\u6570\uff0e\u30b3\u30d4\u30fc\u5143\u306e\u30d5\u30a1\u30a4\u30eb\u3084\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3068\u540c\u4e00\u306e\u30d1\u30fc\u30df\u30c3\u30b7\u30e7\u30f3\u3092\u4ed8\u4e0e\u3057\u307e\u3059\uff0e options - n : (n: no overwrite) do not to overwrite the existing file. - p : (p: permission) copy file with the same permission and timestamp. - u : (u: update) update the file only when the dst file is older than src file. Usage copy(): copy a file main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"dd if=/dev/urandom of=./tmp/rand.bin bs=1M count=10 > /dev/null 2>&1\" ); sstd :: copy ( \"./tmp/rand.bin\" , \"./tmp/rand_copy.bin\" ); sstd :: system ( \"ls ./tmp\" ); sstd :: system ( \"sha256sum ./tmp/rand.bin | cut -d \\\" \\\" -f 1\" ); sstd :: system ( \"sha256sum ./tmp/rand_copy.bin | cut -d \\\" \\\" -f 1\" ); sstd :: rm ( \"./tmp\" ); } Execution result rand.bin rand_copy.bin 0771a17784e1e82cf88728e39f9232bd2d5120e8c4d06f9b7f445a06bbe32aa2 0771a17784e1e82cf88728e39f9232bd2d5120e8c4d06f9b7f445a06bbe32aa2 cp(): copy a directory main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: cp ( \"./sstd\" , \"./tmp\" ); sstd :: system ( \"ls ./tmp\" ); sstd :: rm ( \"./tmp\" ); } Execution result sstd cp(): copy under the directory main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: cp ( \"./sstd/*\" , \"./tmp\" ); sstd :: system ( \"ls ./tmp\" ); sstd :: rm ( \"./tmp\" ); } Execution result LICENSE Makefile compileOption.hpp include lib src sstd.hpp tmpMake Implementation Source: sstd/src/file/cp.cpp Header: sstd/src/file/cp.hpp Test: test/file/cp.hpp","title":"cp"},{"location":"src/file/cp.html#cp","text":"","title":"cp"},{"location":"src/file/cp.html#abstract","text":"Functions to copy files and directories","title":"Abstract"},{"location":"src/file/cp.html#header-file","text":"namespace sstd { bool copy ( const char * pPath_src , const char * pPath_dst , const char * opt ); bool copy ( const std :: string & path_src , const char * pPath_dst , const char * opt ); bool copy ( const char * pPath_src , const std :: string & path_dst , const char * opt ); bool copy ( const std :: string & path_src , const std :: string & path_dst , const char * opt ); bool copy ( const char * pPath_src , const char * pPath_dst ); bool copy ( const std :: string & path_src , const char * pPath_dst ); bool copy ( const char * pPath_src , const std :: string & path_dst ); bool copy ( const std :: string & path_src , const std :: string & path_dst ); bool cp ( const char * pPath_src , const char * pPath_dst , const char * opt ); bool cp ( const std :: string & path_src , const char * pPath_dst , const char * opt ); bool cp ( const char * pPath_src , const std :: string & path_dst , const char * opt ); bool cp ( const std :: string & path_src , const std :: string & path_dst , const char * opt ); bool cp ( const char * pPath_src , const char * pPath_dst ); bool cp ( const std :: string & path_src , const char * pPath_dst ); bool cp ( const char * pPath_src , const std :: string & path_dst ); bool cp ( const std :: string & path_src , const std :: string & path_dst ); }","title":"Header file"},{"location":"src/file/cp.html#description","text":"Function name Description copy() A function to copy a single file, and give the same permission as the source. 1 \u3064\u306e\u30d5\u30a1\u30a4\u30eb\u3092\u30b3\u30d4\u30fc\u3059\u308b\u95a2\u6570\uff0e\u30b3\u30d4\u30fc\u5143\u306e\u30d5\u30a1\u30a4\u30eb\u3068\u540c\u4e00\u306e\u30d1\u30fc\u30df\u30c3\u30b7\u30e7\u30f3\u3092\u4ed8\u4e0e\u3057\u307e\u3059\uff0e cp() A function to copy files and directories, and give the same permission as the source. \u8907\u6570\u306e\u30d5\u30a1\u30a4\u30eb\u3084\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u30b3\u30d4\u30fc\u3059\u308b\u95a2\u6570\uff0e\u30b3\u30d4\u30fc\u5143\u306e\u30d5\u30a1\u30a4\u30eb\u3084\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3068\u540c\u4e00\u306e\u30d1\u30fc\u30df\u30c3\u30b7\u30e7\u30f3\u3092\u4ed8\u4e0e\u3057\u307e\u3059\uff0e options - n : (n: no overwrite) do not to overwrite the existing file. - p : (p: permission) copy file with the same permission and timestamp. - u : (u: update) update the file only when the dst file is older than src file.","title":"Description"},{"location":"src/file/cp.html#usage","text":"","title":"Usage"},{"location":"src/file/cp.html#copy-copy-a-file","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"dd if=/dev/urandom of=./tmp/rand.bin bs=1M count=10 > /dev/null 2>&1\" ); sstd :: copy ( \"./tmp/rand.bin\" , \"./tmp/rand_copy.bin\" ); sstd :: system ( \"ls ./tmp\" ); sstd :: system ( \"sha256sum ./tmp/rand.bin | cut -d \\\" \\\" -f 1\" ); sstd :: system ( \"sha256sum ./tmp/rand_copy.bin | cut -d \\\" \\\" -f 1\" ); sstd :: rm ( \"./tmp\" ); } Execution result rand.bin rand_copy.bin 0771a17784e1e82cf88728e39f9232bd2d5120e8c4d06f9b7f445a06bbe32aa2 0771a17784e1e82cf88728e39f9232bd2d5120e8c4d06f9b7f445a06bbe32aa2","title":"copy(): copy a file"},{"location":"src/file/cp.html#cp-copy-a-directory","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: cp ( \"./sstd\" , \"./tmp\" ); sstd :: system ( \"ls ./tmp\" ); sstd :: rm ( \"./tmp\" ); } Execution result sstd","title":"cp(): copy a directory"},{"location":"src/file/cp.html#cp-copy-under-the-directory","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: cp ( \"./sstd/*\" , \"./tmp\" ); sstd :: system ( \"ls ./tmp\" ); sstd :: rm ( \"./tmp\" ); } Execution result LICENSE Makefile compileOption.hpp include lib src sstd.hpp tmpMake","title":"cp(): copy under the directory"},{"location":"src/file/cp.html#implementation","text":"Source: sstd/src/file/cp.cpp Header: sstd/src/file/cp.hpp Test: test/file/cp.hpp","title":"Implementation"},{"location":"src/file/csv.html","text":"csv Abstract csv2vvec() Parsing CSV file to std::vector<std::vector<std::string>> . CSV \u30d5\u30a1\u30a4\u30eb\u3092\u30d1\u30fc\u30b9\u3057\u3066 std::vector<std::vector<std::string>> \u306b\u5909\u63db\u3057\u307e\u3059. vvec2csv() Converting std::vector<std::vector<std::string>> to CSV file. std::vector<std::vector<std::string>> \u3092 CSV \u30d5\u30a1\u30a4\u30eb\u306b\u5909\u63db\u3057\u307e\u3059. Header file namespace sstd { std :: vector < std :: vector < std :: string >> csv2vvec ( const char * pReadFile ); std :: vector < std :: vector < std :: string >> csv2vvec ( const std :: string & readFile ); bool vvec2csv ( const char * pSavePath , const std :: vector < std :: vector < std :: string >>& vecCSV ); bool vvec2csv ( const std :: string & savePath , const std :: vector < std :: vector < std :: string >>& vecCSV ); } Usage csv2vvec() example.csv a, bcd \"hello, world\", \"efg\" main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < std :: string >> vv = sstd :: csv2vvec ( \"example.csv\" ); sstd :: printn ( vv ); } Execution result vv = [[\"a\" \"bcd\"] [\"hello, world\" \"efg\"]] vvec2csv() main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); std :: vector < std :: vector < std :: string >> vv = {{ \"a\" , \"bcd\" }, { \"hello, world\" , \"efg\" }}; sstd :: vvec2csv ( \"./tmp/example.csv\" , vv ); printf ( \"$ cat ./tmp/example.csv \\n \" ); fflush ( stdout ); sstd :: system ( \"cat ./tmp/example.csv\" ); sstd :: rm ( \"./tmp\" ); } Execution result $ cat ./tmp/example.csv \"a\",\"bcd\", \"hello, world\",\"efg\", Appendix CSV with header (string) Below C++ code gets string CSV data removing header descriptions. \u4e0b\u8a18\u306e C++ \u30b3\u30fc\u30c9\u306f\uff0c\u8aac\u660e\u30d8\u30c3\u30c0\u3092\u53d6\u308a\u9664\u3044\u305f\u6587\u5b57\u5217\u306e CSV \u30c7\u30fc\u30bf\u3092\u53d6\u5f97\u3057\u307e\u3059\uff0e CSV example Range of Integers Type name Bytes Range of values int8_t 1 -128 ~ 127 int16_t 2 -32,768 ~ 32,767 int32_t 4 -2,147,483,648 ~ 2,147,483,647 int64_t 8 -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); { // write to CSV sstd :: vvec < std :: string > header = { // sstd::vvec<T> is same as a std::vector<std::vector<T>>. { \"Type name\" , \"Bytes\" , \"Range of values\" } }; sstd :: vvec < std :: string > vvTable = { { \"int8_t\" , \"1\" , \"-128 ~ 127\" }, { \"int16_t\" , \"2\" , \"-32,768 ~ 32,767\" }, { \"int32_t\" , \"4\" , \"-2,147,483,648 ~ 2,147,483,647\" }, { \"int64_t\" , \"8\" , \"-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807\" } }; sstd :: vvec < std :: string > vv = header << vvTable ; sstd :: vvec2csv ( \"./tmp/example.csv\" , vv ); } { // Read from CSV sstd :: vvec < std :: string > vvecOrig = sstd :: csv2vvec ( \"./tmp/example.csv\" ); sstd :: vvec < std :: string > header = vvecOrig && sstd :: slice_mv ( sstd :: begin (), 1 ); sstd :: vvec < std :: string > vvS = vvecOrig && sstd :: slice_mv ( 1 , sstd :: end ()); sstd :: printn ( vvS ); } sstd :: rm ( \"./tmp\" ); } Execution result vvS = [[\"int8_t\" \"1\" \"-128 ~ 127\"] [\"int16_t\" \"2\" \"-32,768 ~ 32,767\"] [\"int32_t\" \"4\" \"-2,147,483,648 ~ 2,147,483,647\"] [\"int64_t\" \"8\" \"-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807\"]] CSV with header (double) Below C++ code gets floating points CSV data removing header descriptions. \u4e0b\u8a18\u306e C++ \u30b3\u30fc\u30c9\u306f\uff0c\u8aac\u660e\u30d8\u30c3\u30c0\u3092\u53d6\u308a\u9664\u3044\u305f\u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u306e CSV \u30c7\u30fc\u30bf\u3092\u53d6\u5f97\u3057\u307e\u3059\uff0e CSV example sin(\u03a0x) and cos(\u03a0x) x sin(\u03c0x) cos(\u03c0x) 0.00 0.00 1.00 0.10 0.31 0.95 0.20 0.59 0.81 0.30 0.81 0.59 0.40 0.95 0.31 0.50 1.00 0.00 0.60 0.95 -0.31 0.70 0.81 -0.59 0.80 0.59 -0.81 0.90 0.31 -0.95 1.00 0.00 -1.00 1.10 -0.31 -0.95 1.20 -0.59 -0.81 1.30 -0.81 -0.59 1.40 -0.95 -0.31 1.50 -1.00 0.00 1.60 -0.95 0.31 1.70 -0.81 0.59 1.80 -0.59 0.81 1.90 -0.31 0.95 2.00 0.00 1.00 main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); { // write to CSV sstd :: vvec < std :: string > header = { // sstd::vvec<T> is same as a std::vector<std::vector<T>>. { \"x\" , \"sin(\u03c0x)\" , \"cos(\u03c0x)\" } }; std :: vector < double > vX = { 0.00 , 0.10 , 0.20 , 0.30 , 0.40 , 0.50 , 0.60 , 0.70 , 0.80 , 0.90 , 1.00 , 1.10 , 1.20 , 1.30 , 1.40 , 1.50 , 1.60 , 1.70 , 1.80 , 1.90 , 2.00 }; std :: vector < double > vSin = { 0.00 , 0.31 , 0.59 , 0.81 , 0.95 , 1.00 , 0.95 , 0.81 , 0.59 , 0.31 , 0.00 , -0.31 , -0.59 , -0.81 , -0.95 , -1.00 , -0.95 , -0.81 , -0.59 , -0.31 , 0.00 }; std :: vector < double > vCos = { 1.00 , 0.95 , 0.81 , 0.59 , 0.31 , 0.00 , -0.31 , -0.59 , -0.81 , -0.95 , -1.00 , -0.95 , -0.81 , -0.59 , -0.31 , 0.00 , 0.31 , 0.59 , 0.81 , 0.95 , 1.00 }; sstd :: vvec < double > vvD = {{ vX }, { vSin }, { vCos }}; sstd :: vvec < double > vvTable = sstd :: Tr ( vvD ); /* // up is same as a below. sstd::vvec<double> vvTable = { {0.00, 0.00, 1.00}, {0.10, 0.31, 0.95}, {0.20, 0.59, 0.81}, {0.30, 0.81, 0.59}, {0.40, 0.95, 0.31}, {0.50, 1.00, 0.00}, {0.60, 0.95, -0.31}, {0.70, 0.81, -0.59}, {0.80, 0.59, -0.81}, {0.90, 0.31, -0.95}, {1.00, 0.00, -1.00}, {1.10, -0.31, -0.95}, {1.20, -0.59, -0.81}, {1.30, -0.81, -0.59}, {1.40, -0.95, -0.31}, {1.50, -1.00, 0.00}, {1.60, -0.95, 0.31}, {1.70, -0.81, 0.59}, {1.80, -0.59, 0.81}, {1.90, -0.31, 0.95}, {2.00, 0.00, 1.00} };*/ sstd :: vvec < std :: string > vv = header << sstd :: double2str ( vvTable ); sstd :: vvec2csv ( \"./tmp/example.csv\" , vv ); } { // Read from CSV sstd :: vvec < std :: string > vvecOrig = sstd :: csv2vvec ( \"./tmp/example.csv\" ); sstd :: vvec < std :: string > header = vvecOrig && sstd :: slice_mv ( sstd :: begin (), 1 ); sstd :: vvec < std :: string > vvS = vvecOrig && sstd :: slice_mv ( 1 , sstd :: end ()); sstd :: vvec < double > vvD = sstd :: Tr ( sstd :: str2double ( vvS )); sstd :: printn ( header ); sstd :: printn ( vvD [ 0 ]); sstd :: printn ( vvD [ 1 ]); sstd :: printn ( vvD [ 2 ]); } sstd :: rm ( \"./tmp\" ); } Execution result header = [[\"x\" \"sin(\u03c0x)\" \"cos(\u03c0x)\"]] vvD[0] = [0. 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1. 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.] vvD[1] = [0. 0.31 0.59 0.81 0.95 1. 0.95 0.81 0.59 0.31 0. -0.31 -0.59 -0.81 -0.95 -1. -0.95 -0.81 -0.59 -0.31 0.] vvD[2] = [1. 0.95 0.81 0.59 0.31 0. -0.31 -0.59 -0.81 -0.95 -1. -0.95 -0.81 -0.59 -0.31 0. 0.31 0.59 0.81 0.95 1.] Implementation Source: sstd/src/file/csv.cpp Header: sstd/src/file/csv.hpp Test: test/file/csv.hpp (Not implemented yet)","title":"csv"},{"location":"src/file/csv.html#csv","text":"","title":"csv"},{"location":"src/file/csv.html#abstract","text":"csv2vvec() Parsing CSV file to std::vector<std::vector<std::string>> . CSV \u30d5\u30a1\u30a4\u30eb\u3092\u30d1\u30fc\u30b9\u3057\u3066 std::vector<std::vector<std::string>> \u306b\u5909\u63db\u3057\u307e\u3059. vvec2csv() Converting std::vector<std::vector<std::string>> to CSV file. std::vector<std::vector<std::string>> \u3092 CSV \u30d5\u30a1\u30a4\u30eb\u306b\u5909\u63db\u3057\u307e\u3059.","title":"Abstract"},{"location":"src/file/csv.html#header-file","text":"namespace sstd { std :: vector < std :: vector < std :: string >> csv2vvec ( const char * pReadFile ); std :: vector < std :: vector < std :: string >> csv2vvec ( const std :: string & readFile ); bool vvec2csv ( const char * pSavePath , const std :: vector < std :: vector < std :: string >>& vecCSV ); bool vvec2csv ( const std :: string & savePath , const std :: vector < std :: vector < std :: string >>& vecCSV ); }","title":"Header file"},{"location":"src/file/csv.html#usage","text":"","title":"Usage"},{"location":"src/file/csv.html#csv2vvec","text":"example.csv a, bcd \"hello, world\", \"efg\" main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < std :: string >> vv = sstd :: csv2vvec ( \"example.csv\" ); sstd :: printn ( vv ); } Execution result vv = [[\"a\" \"bcd\"] [\"hello, world\" \"efg\"]]","title":"csv2vvec()"},{"location":"src/file/csv.html#vvec2csv","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); std :: vector < std :: vector < std :: string >> vv = {{ \"a\" , \"bcd\" }, { \"hello, world\" , \"efg\" }}; sstd :: vvec2csv ( \"./tmp/example.csv\" , vv ); printf ( \"$ cat ./tmp/example.csv \\n \" ); fflush ( stdout ); sstd :: system ( \"cat ./tmp/example.csv\" ); sstd :: rm ( \"./tmp\" ); } Execution result $ cat ./tmp/example.csv \"a\",\"bcd\", \"hello, world\",\"efg\",","title":"vvec2csv()"},{"location":"src/file/csv.html#appendix","text":"","title":"Appendix"},{"location":"src/file/csv.html#csv-with-header-string","text":"Below C++ code gets string CSV data removing header descriptions. \u4e0b\u8a18\u306e C++ \u30b3\u30fc\u30c9\u306f\uff0c\u8aac\u660e\u30d8\u30c3\u30c0\u3092\u53d6\u308a\u9664\u3044\u305f\u6587\u5b57\u5217\u306e CSV \u30c7\u30fc\u30bf\u3092\u53d6\u5f97\u3057\u307e\u3059\uff0e","title":"CSV with header (string)"},{"location":"src/file/csv.html#csv-example","text":"Range of Integers Type name Bytes Range of values int8_t 1 -128 ~ 127 int16_t 2 -32,768 ~ 32,767 int32_t 4 -2,147,483,648 ~ 2,147,483,647 int64_t 8 -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); { // write to CSV sstd :: vvec < std :: string > header = { // sstd::vvec<T> is same as a std::vector<std::vector<T>>. { \"Type name\" , \"Bytes\" , \"Range of values\" } }; sstd :: vvec < std :: string > vvTable = { { \"int8_t\" , \"1\" , \"-128 ~ 127\" }, { \"int16_t\" , \"2\" , \"-32,768 ~ 32,767\" }, { \"int32_t\" , \"4\" , \"-2,147,483,648 ~ 2,147,483,647\" }, { \"int64_t\" , \"8\" , \"-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807\" } }; sstd :: vvec < std :: string > vv = header << vvTable ; sstd :: vvec2csv ( \"./tmp/example.csv\" , vv ); } { // Read from CSV sstd :: vvec < std :: string > vvecOrig = sstd :: csv2vvec ( \"./tmp/example.csv\" ); sstd :: vvec < std :: string > header = vvecOrig && sstd :: slice_mv ( sstd :: begin (), 1 ); sstd :: vvec < std :: string > vvS = vvecOrig && sstd :: slice_mv ( 1 , sstd :: end ()); sstd :: printn ( vvS ); } sstd :: rm ( \"./tmp\" ); } Execution result vvS = [[\"int8_t\" \"1\" \"-128 ~ 127\"] [\"int16_t\" \"2\" \"-32,768 ~ 32,767\"] [\"int32_t\" \"4\" \"-2,147,483,648 ~ 2,147,483,647\"] [\"int64_t\" \"8\" \"-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807\"]]","title":"CSV example"},{"location":"src/file/csv.html#csv-with-header-double","text":"Below C++ code gets floating points CSV data removing header descriptions. \u4e0b\u8a18\u306e C++ \u30b3\u30fc\u30c9\u306f\uff0c\u8aac\u660e\u30d8\u30c3\u30c0\u3092\u53d6\u308a\u9664\u3044\u305f\u6d6e\u52d5\u5c0f\u6570\u70b9\u6570\u306e CSV \u30c7\u30fc\u30bf\u3092\u53d6\u5f97\u3057\u307e\u3059\uff0e","title":"CSV with header (double)"},{"location":"src/file/csv.html#csv-example_1","text":"sin(\u03a0x) and cos(\u03a0x) x sin(\u03c0x) cos(\u03c0x) 0.00 0.00 1.00 0.10 0.31 0.95 0.20 0.59 0.81 0.30 0.81 0.59 0.40 0.95 0.31 0.50 1.00 0.00 0.60 0.95 -0.31 0.70 0.81 -0.59 0.80 0.59 -0.81 0.90 0.31 -0.95 1.00 0.00 -1.00 1.10 -0.31 -0.95 1.20 -0.59 -0.81 1.30 -0.81 -0.59 1.40 -0.95 -0.31 1.50 -1.00 0.00 1.60 -0.95 0.31 1.70 -0.81 0.59 1.80 -0.59 0.81 1.90 -0.31 0.95 2.00 0.00 1.00 main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); { // write to CSV sstd :: vvec < std :: string > header = { // sstd::vvec<T> is same as a std::vector<std::vector<T>>. { \"x\" , \"sin(\u03c0x)\" , \"cos(\u03c0x)\" } }; std :: vector < double > vX = { 0.00 , 0.10 , 0.20 , 0.30 , 0.40 , 0.50 , 0.60 , 0.70 , 0.80 , 0.90 , 1.00 , 1.10 , 1.20 , 1.30 , 1.40 , 1.50 , 1.60 , 1.70 , 1.80 , 1.90 , 2.00 }; std :: vector < double > vSin = { 0.00 , 0.31 , 0.59 , 0.81 , 0.95 , 1.00 , 0.95 , 0.81 , 0.59 , 0.31 , 0.00 , -0.31 , -0.59 , -0.81 , -0.95 , -1.00 , -0.95 , -0.81 , -0.59 , -0.31 , 0.00 }; std :: vector < double > vCos = { 1.00 , 0.95 , 0.81 , 0.59 , 0.31 , 0.00 , -0.31 , -0.59 , -0.81 , -0.95 , -1.00 , -0.95 , -0.81 , -0.59 , -0.31 , 0.00 , 0.31 , 0.59 , 0.81 , 0.95 , 1.00 }; sstd :: vvec < double > vvD = {{ vX }, { vSin }, { vCos }}; sstd :: vvec < double > vvTable = sstd :: Tr ( vvD ); /* // up is same as a below. sstd::vvec<double> vvTable = { {0.00, 0.00, 1.00}, {0.10, 0.31, 0.95}, {0.20, 0.59, 0.81}, {0.30, 0.81, 0.59}, {0.40, 0.95, 0.31}, {0.50, 1.00, 0.00}, {0.60, 0.95, -0.31}, {0.70, 0.81, -0.59}, {0.80, 0.59, -0.81}, {0.90, 0.31, -0.95}, {1.00, 0.00, -1.00}, {1.10, -0.31, -0.95}, {1.20, -0.59, -0.81}, {1.30, -0.81, -0.59}, {1.40, -0.95, -0.31}, {1.50, -1.00, 0.00}, {1.60, -0.95, 0.31}, {1.70, -0.81, 0.59}, {1.80, -0.59, 0.81}, {1.90, -0.31, 0.95}, {2.00, 0.00, 1.00} };*/ sstd :: vvec < std :: string > vv = header << sstd :: double2str ( vvTable ); sstd :: vvec2csv ( \"./tmp/example.csv\" , vv ); } { // Read from CSV sstd :: vvec < std :: string > vvecOrig = sstd :: csv2vvec ( \"./tmp/example.csv\" ); sstd :: vvec < std :: string > header = vvecOrig && sstd :: slice_mv ( sstd :: begin (), 1 ); sstd :: vvec < std :: string > vvS = vvecOrig && sstd :: slice_mv ( 1 , sstd :: end ()); sstd :: vvec < double > vvD = sstd :: Tr ( sstd :: str2double ( vvS )); sstd :: printn ( header ); sstd :: printn ( vvD [ 0 ]); sstd :: printn ( vvD [ 1 ]); sstd :: printn ( vvD [ 2 ]); } sstd :: rm ( \"./tmp\" ); } Execution result header = [[\"x\" \"sin(\u03c0x)\" \"cos(\u03c0x)\"]] vvD[0] = [0. 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1. 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.] vvD[1] = [0. 0.31 0.59 0.81 0.95 1. 0.95 0.81 0.59 0.31 0. -0.31 -0.59 -0.81 -0.95 -1. -0.95 -0.81 -0.59 -0.31 0.] vvD[2] = [1. 0.95 0.81 0.59 0.31 0. -0.31 -0.59 -0.81 -0.95 -1. -0.95 -0.81 -0.59 -0.31 0. 0.31 0.59 0.81 0.95 1.]","title":"CSV example"},{"location":"src/file/csv.html#implementation","text":"Source: sstd/src/file/csv.cpp Header: sstd/src/file/csv.hpp Test: test/file/csv.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/file/file.html","text":"file Abstract The file class is used to manage file pointers. file \u30af\u30e9\u30b9\u306f\uff0cfile \u30dd\u30a4\u30f3\u30bf\u306e\u7ba1\u7406\u306b\u5229\u7528\u3057\u307e\u3059\uff0e Header file namespace sstd { class file ; } class sstd :: file { private : FILE * fp ; int type ; // 0: fopen(), 1: popen(). public : file (); ~ file (); bool fopen ( const char * fileName , const char * mode ); bool fopen ( const std :: string & fileName , const char * mode ); bool popen ( const char * fileName , const char * mode ); bool popen ( const std :: string & fileName , const char * mode ); bool close (); char * fgets ( char * s , int size ); size_t fread ( void * ptr , const size_t & size , const size_t & nmemb ); template < typename ... Args > int fscanf ( const char * format , Args const & ... args ){ return :: fscanf ( this -> fp , format , args ...); } int fseek ( const long & offset , const int & whence ); size_t fsize (); long ftell (); size_t fwrite ( const void * ptr , const size_t & size , const size_t & nmemb ); }; Usage example.txt abc def main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: file fp ; if ( ! fp . fopen ( \"example.txt\" , \"rb\" )){ sstd :: pdbg ( \"ERROR: fopen was failed. \\n \" ); return -1 ; } size_t size = fp . fsize (); std :: vector < char > raw ( size + 1 , 0 ); if ( fp . fread (( uchar * ) & raw [ 0 ], sizeof ( char ), size ) != size ){ sstd :: pdbg ( \"ERROR: fread was failed. \\n \" ); return -1 ; } printf ( \"&raw[0] = %s \\n \" , & raw [ 0 ]); return 0 ; // fp is automatically closed by RAII. } Execution result &raw[0] = abc def Implementation Source: sstd/src/file/file.cpp Header: sstd/src/file/file.hpp Test: test/file/file.hpp","title":"file"},{"location":"src/file/file.html#file","text":"","title":"file"},{"location":"src/file/file.html#abstract","text":"The file class is used to manage file pointers. file \u30af\u30e9\u30b9\u306f\uff0cfile \u30dd\u30a4\u30f3\u30bf\u306e\u7ba1\u7406\u306b\u5229\u7528\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/file/file.html#header-file","text":"namespace sstd { class file ; } class sstd :: file { private : FILE * fp ; int type ; // 0: fopen(), 1: popen(). public : file (); ~ file (); bool fopen ( const char * fileName , const char * mode ); bool fopen ( const std :: string & fileName , const char * mode ); bool popen ( const char * fileName , const char * mode ); bool popen ( const std :: string & fileName , const char * mode ); bool close (); char * fgets ( char * s , int size ); size_t fread ( void * ptr , const size_t & size , const size_t & nmemb ); template < typename ... Args > int fscanf ( const char * format , Args const & ... args ){ return :: fscanf ( this -> fp , format , args ...); } int fseek ( const long & offset , const int & whence ); size_t fsize (); long ftell (); size_t fwrite ( const void * ptr , const size_t & size , const size_t & nmemb ); };","title":"Header file"},{"location":"src/file/file.html#usage","text":"example.txt abc def main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: file fp ; if ( ! fp . fopen ( \"example.txt\" , \"rb\" )){ sstd :: pdbg ( \"ERROR: fopen was failed. \\n \" ); return -1 ; } size_t size = fp . fsize (); std :: vector < char > raw ( size + 1 , 0 ); if ( fp . fread (( uchar * ) & raw [ 0 ], sizeof ( char ), size ) != size ){ sstd :: pdbg ( \"ERROR: fread was failed. \\n \" ); return -1 ; } printf ( \"&raw[0] = %s \\n \" , & raw [ 0 ]); return 0 ; // fp is automatically closed by RAII. } Execution result &raw[0] = abc def","title":"Usage"},{"location":"src/file/file.html#implementation","text":"Source: sstd/src/file/file.cpp Header: sstd/src/file/file.hpp Test: test/file/file.hpp","title":"Implementation"},{"location":"src/file/file_operations.html","text":"file_operations Abstract This file contains the file operations. \u3053\u306e\u30d5\u30a1\u30a4\u30eb\u3067\u306f\uff0c\u30d5\u30a1\u30a4\u30eb\u3078\u306e\u64cd\u4f5c\u3092\u53ce\u9332\u3057\u307e\u3059\uff0e Header file namespace sstd { bool file_size ( size_t & ret_size , const char * path ); } Description Function name Description file_size() gets the size of the file in the path. path \u306b\u6307\u5b9a\u3055\u308c\u305f\u30d5\u30a1\u30a4\u30eb\u306e\u30b5\u30a4\u30ba\u3092\u53d6\u5f97\u3057\u307e\u3059\uff0e Usage main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); const char * path = \"./tmp/dummy_file\" ; sstd :: system ( sstd :: ssprintf ( \"head -c 19842 /dev/urandom > %s\" , path )); // generate 19842 Byte random file size_t ret_size = 0ull ; bool ret = sstd :: file_size ( ret_size , path ); sstd :: printn ( ret ); sstd :: printn ( ret_size ); return 0 ; } Execution result ret = true ret_size = 19842 Implementation Source: sstd/src/file/file_operations.cpp Header: sstd/src/file/file_operations.hpp Test: test/file/file_operations.hpp","title":"file_operations"},{"location":"src/file/file_operations.html#file_operations","text":"","title":"file_operations"},{"location":"src/file/file_operations.html#abstract","text":"This file contains the file operations. \u3053\u306e\u30d5\u30a1\u30a4\u30eb\u3067\u306f\uff0c\u30d5\u30a1\u30a4\u30eb\u3078\u306e\u64cd\u4f5c\u3092\u53ce\u9332\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/file/file_operations.html#header-file","text":"namespace sstd { bool file_size ( size_t & ret_size , const char * path ); }","title":"Header file"},{"location":"src/file/file_operations.html#description","text":"Function name Description file_size() gets the size of the file in the path. path \u306b\u6307\u5b9a\u3055\u308c\u305f\u30d5\u30a1\u30a4\u30eb\u306e\u30b5\u30a4\u30ba\u3092\u53d6\u5f97\u3057\u307e\u3059\uff0e","title":"Description"},{"location":"src/file/file_operations.html#usage","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); const char * path = \"./tmp/dummy_file\" ; sstd :: system ( sstd :: ssprintf ( \"head -c 19842 /dev/urandom > %s\" , path )); // generate 19842 Byte random file size_t ret_size = 0ull ; bool ret = sstd :: file_size ( ret_size , path ); sstd :: printn ( ret ); sstd :: printn ( ret_size ); return 0 ; } Execution result ret = true ret_size = 19842","title":"Usage"},{"location":"src/file/file_operations.html#implementation","text":"Source: sstd/src/file/file_operations.cpp Header: sstd/src/file/file_operations.hpp Test: test/file/file_operations.hpp","title":"Implementation"},{"location":"src/file/glob.html","text":"glob Abstract Functions to search files and directories Header file namespace sstd { struct pathAndType { std :: string path ; char type ; // 'f': file, 'd': directory bool operator < ( const struct pathAndType & rhs ){ return ( * this ). path < rhs . path ; } }; std :: vector < std :: string > glob ( const char * path , const char * opt ); std :: vector < std :: string > glob ( const std :: string & path , const char * opt ); std :: vector < std :: string > glob ( const char * path ); std :: vector < std :: string > glob ( const std :: string & path ); std :: vector < struct pathAndType > glob_pt ( const char * path , const char * opt ); // _pt: with path type std :: vector < struct pathAndType > glob_pt ( const std :: string & path , const char * opt ); std :: vector < struct pathAndType > glob_pt ( const char * path ); std :: vector < struct pathAndType > glob_pt ( const std :: string & path ); } Description Function name Description glob() glob can search file and directory with wildcard ( * and ? ). glob \u306f\uff0cwildcard ( * \u3068 ? ) \u3092\u7528\u3044\u305f\uff0c\u30d5\u30a1\u30a4\u30eb\u3068\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u63a2\u7d22\u3067\u304d\u307e\u3059\uff0e glob_pt() glob_pt is a type of glob with a variable indicating the file type in the returning value. Options can take d , f , r and p . There options can be specified independently in no particular order. Options: - d : getting directory name - f : getting file name - r : recursive directory - p : using sstd::pathmatch() instead of sstd::strmatch() internally glob_pt \u306f\uff0c glob \u306e\u623b\u308a\u5024\u306b\u30d5\u30a1\u30a4\u30eb\u30bf\u30a4\u30d7\u3092\u793a\u3059\u5909\u6570\u304c\u8ffd\u52a0\u3055\u308c\u305f\u30d0\u30fc\u30b8\u30e7\u30f3\u3067\u3059\uff0e\u30aa\u30d7\u30b7\u30e7\u30f3\u306b\u306f d , f , r , p \u304c\u3042\u308a\uff0c\u305d\u308c\u305e\u308c\u72ec\u7acb\u306b\uff0c\u9806\u4e0d\u540c\u3067\u6307\u5b9a\u3067\u304d\u307e\u3059\uff0e Usage01: getting only file without recursive option main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"touch ./tmp/a.txt\" ); sstd :: system ( \"touch ./tmp/b.csv\" ); sstd :: system ( \"touch ./tmp/c.txt\" ); std :: vector < std :: string > vStr = sstd :: glob ( \"./tmp/*.txt\" ); sstd :: printn ( vStr ); std :: vector < struct sstd :: pathAndType > vPt = sstd :: glob_pt ( \"./tmp/*.txt\" ); sstd :: printn ( vPt ); sstd :: rm ( \"./tmp\" ); } example.txt vStr = [\"./tmp/a.txt\" \"./tmp/c.txt\"] vPt = [\"path: ./tmp/a.txt, type: file\" \"path: ./tmp/c.txt, type: file\"] Usage02: getting file and directory with recursive option main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: mkdir ( \"./tmp/a\" ); sstd :: mkdir ( \"./tmp/b\" ); sstd :: mkdir ( \"./tmp/c\" ); sstd :: system ( \"touch ./tmp/a.txt\" ); sstd :: system ( \"touch ./tmp/b.csv\" ); sstd :: system ( \"touch ./tmp/c.txt\" ); std :: vector < std :: string > vStr = sstd :: glob ( \"./tmp/*\" , \"dfr\" ); sstd :: printn ( vStr ); std :: vector < struct sstd :: pathAndType > vPt = sstd :: glob_pt ( \"./tmp/*\" , \"dfr\" ); sstd :: printn ( vPt ); sstd :: rm ( \"./tmp\" ); } example.txt vStr = [\"./tmp/a\" \"./tmp/a.txt\" \"./tmp/b\" \"./tmp/b.csv\" \"./tmp/c\" \"./tmp/c.txt\"] vPt = [\"path: ./tmp/a, type: directory\" \"path: ./tmp/a.txt, type: file\" \"path: ./tmp/b, type: directory\" \"path: ./tmp/b.csv, type: file\" \"path: ./tmp/c, type: directory\" \"path: ./tmp/c.txt, type: file\"] Implementation Source: sstd/src/file/glob.cpp Header: sstd/src/file/glob.hpp Test: test/file/glob.hpp","title":"glob"},{"location":"src/file/glob.html#glob","text":"","title":"glob"},{"location":"src/file/glob.html#abstract","text":"Functions to search files and directories","title":"Abstract"},{"location":"src/file/glob.html#header-file","text":"namespace sstd { struct pathAndType { std :: string path ; char type ; // 'f': file, 'd': directory bool operator < ( const struct pathAndType & rhs ){ return ( * this ). path < rhs . path ; } }; std :: vector < std :: string > glob ( const char * path , const char * opt ); std :: vector < std :: string > glob ( const std :: string & path , const char * opt ); std :: vector < std :: string > glob ( const char * path ); std :: vector < std :: string > glob ( const std :: string & path ); std :: vector < struct pathAndType > glob_pt ( const char * path , const char * opt ); // _pt: with path type std :: vector < struct pathAndType > glob_pt ( const std :: string & path , const char * opt ); std :: vector < struct pathAndType > glob_pt ( const char * path ); std :: vector < struct pathAndType > glob_pt ( const std :: string & path ); }","title":"Header file"},{"location":"src/file/glob.html#description","text":"Function name Description glob() glob can search file and directory with wildcard ( * and ? ). glob \u306f\uff0cwildcard ( * \u3068 ? ) \u3092\u7528\u3044\u305f\uff0c\u30d5\u30a1\u30a4\u30eb\u3068\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u63a2\u7d22\u3067\u304d\u307e\u3059\uff0e glob_pt() glob_pt is a type of glob with a variable indicating the file type in the returning value. Options can take d , f , r and p . There options can be specified independently in no particular order. Options: - d : getting directory name - f : getting file name - r : recursive directory - p : using sstd::pathmatch() instead of sstd::strmatch() internally glob_pt \u306f\uff0c glob \u306e\u623b\u308a\u5024\u306b\u30d5\u30a1\u30a4\u30eb\u30bf\u30a4\u30d7\u3092\u793a\u3059\u5909\u6570\u304c\u8ffd\u52a0\u3055\u308c\u305f\u30d0\u30fc\u30b8\u30e7\u30f3\u3067\u3059\uff0e\u30aa\u30d7\u30b7\u30e7\u30f3\u306b\u306f d , f , r , p \u304c\u3042\u308a\uff0c\u305d\u308c\u305e\u308c\u72ec\u7acb\u306b\uff0c\u9806\u4e0d\u540c\u3067\u6307\u5b9a\u3067\u304d\u307e\u3059\uff0e","title":"Description"},{"location":"src/file/glob.html#usage01-getting-only-file-without-recursive-option","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"touch ./tmp/a.txt\" ); sstd :: system ( \"touch ./tmp/b.csv\" ); sstd :: system ( \"touch ./tmp/c.txt\" ); std :: vector < std :: string > vStr = sstd :: glob ( \"./tmp/*.txt\" ); sstd :: printn ( vStr ); std :: vector < struct sstd :: pathAndType > vPt = sstd :: glob_pt ( \"./tmp/*.txt\" ); sstd :: printn ( vPt ); sstd :: rm ( \"./tmp\" ); } example.txt vStr = [\"./tmp/a.txt\" \"./tmp/c.txt\"] vPt = [\"path: ./tmp/a.txt, type: file\" \"path: ./tmp/c.txt, type: file\"]","title":"Usage01: getting only file without recursive option"},{"location":"src/file/glob.html#usage02-getting-file-and-directory-with-recursive-option","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: mkdir ( \"./tmp/a\" ); sstd :: mkdir ( \"./tmp/b\" ); sstd :: mkdir ( \"./tmp/c\" ); sstd :: system ( \"touch ./tmp/a.txt\" ); sstd :: system ( \"touch ./tmp/b.csv\" ); sstd :: system ( \"touch ./tmp/c.txt\" ); std :: vector < std :: string > vStr = sstd :: glob ( \"./tmp/*\" , \"dfr\" ); sstd :: printn ( vStr ); std :: vector < struct sstd :: pathAndType > vPt = sstd :: glob_pt ( \"./tmp/*\" , \"dfr\" ); sstd :: printn ( vPt ); sstd :: rm ( \"./tmp\" ); } example.txt vStr = [\"./tmp/a\" \"./tmp/a.txt\" \"./tmp/b\" \"./tmp/b.csv\" \"./tmp/c\" \"./tmp/c.txt\"] vPt = [\"path: ./tmp/a, type: directory\" \"path: ./tmp/a.txt, type: file\" \"path: ./tmp/b, type: directory\" \"path: ./tmp/b.csv, type: file\" \"path: ./tmp/c, type: directory\" \"path: ./tmp/c.txt, type: file\"]","title":"Usage02: getting file and directory with recursive option"},{"location":"src/file/glob.html#implementation","text":"Source: sstd/src/file/glob.cpp Header: sstd/src/file/glob.hpp Test: test/file/glob.hpp","title":"Implementation"},{"location":"src/file/mkdir.html","text":"mkdir Abstract mkdir creates directories recursively. mkdir \u306f\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u518d\u5e30\u7684\u306b\u4f5c\u6210\u3057\u307e\u3059\uff0e Header file namespace sstd { void mkdir ( const char * pPath ); void mkdir ( const std :: string & path ); } Usage main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp/a/b/c/\" ); sstd :: system ( \"tree ./tmp\" ); sstd :: rm ( \"./tmp\" ); } Execution result ./tmp \u2514\u2500\u2500 a \u2514\u2500\u2500 b \u2514\u2500\u2500 c 3 directories, 0 files Implementation Source: sstd/src/mkdir.cpp Header: sstd/src/mkdir.hpp Test: test/mkdir.hpp (Not implemented yet)","title":"mkdir"},{"location":"src/file/mkdir.html#mkdir","text":"","title":"mkdir"},{"location":"src/file/mkdir.html#abstract","text":"mkdir creates directories recursively. mkdir \u306f\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092\u518d\u5e30\u7684\u306b\u4f5c\u6210\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/file/mkdir.html#header-file","text":"namespace sstd { void mkdir ( const char * pPath ); void mkdir ( const std :: string & path ); }","title":"Header file"},{"location":"src/file/mkdir.html#usage","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp/a/b/c/\" ); sstd :: system ( \"tree ./tmp\" ); sstd :: rm ( \"./tmp\" ); } Execution result ./tmp \u2514\u2500\u2500 a \u2514\u2500\u2500 b \u2514\u2500\u2500 c 3 directories, 0 files","title":"Usage"},{"location":"src/file/mkdir.html#implementation","text":"Source: sstd/src/mkdir.cpp Header: sstd/src/mkdir.hpp Test: test/mkdir.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/file/mv.html","text":"mv Abstract Function to move file and directory Header file namespace sstd { bool mv ( const char * pPath_src , const char * pPath_dst ); bool mv ( const std :: string & path_src , const char * pPath_dst ); bool mv ( const char * pPath_src , const std :: string & path_dst ); bool mv ( const std :: string & path_src , const std :: string & path_dst ); } Description Function name Description mv() A function to move file and directory from src-path to dst-path. \u30d5\u30a1\u30a4\u30eb\u3084\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092 src-path \u304b\u3089 dst-path \u3078\u79fb\u52d5\u3055\u305b\u308b\u95a2\u6570\uff0e Usage move file to file main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp/01\" ); sstd :: mkdir ( \"./tmp/02\" ); sstd :: system ( \"touch ./tmp/01/example.txt\" ); sstd :: mv ( \"./tmp/01/example.txt\" , \"./tmp/02/example.txt\" ); printf ( \"./tmp/01: \\n \" ); fflush ( stdout ); sstd :: system ( \"ls ./tmp/01\" ); printf ( \" \\n \" ); printf ( \"./tmp/02: \\n \" ); fflush ( stdout ); sstd :: system ( \"ls ./tmp/02\" ); sstd :: rm ( \"./tmp\" ); } Execution result ./tmp/01: ./tmp/02: example.txt move file to directory main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp/01\" ); sstd :: mkdir ( \"./tmp/02\" ); sstd :: system ( \"touch ./tmp/01/example.txt\" ); sstd :: mv ( \"./tmp/01/example.txt\" , \"./tmp/02\" ); printf ( \"./tmp/01: \\n \" ); fflush ( stdout ); sstd :: system ( \"ls ./tmp/01\" ); printf ( \" \\n \" ); printf ( \"./tmp/02: \\n \" ); fflush ( stdout ); sstd :: system ( \"ls ./tmp/02\" ); sstd :: rm ( \"./tmp\" ); } Execution result ./tmp/01: ./tmp/02: example.txt move directory to directory main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp/01\" ); sstd :: mkdir ( \"./tmp/02\" ); sstd :: system ( \"touch ./tmp/01/example.txt\" ); sstd :: mv ( \"./tmp/01\" , \"./tmp/02\" ); printf ( \"./tmp/01: \\n \" ); fflush ( stdout ); sstd :: system ( \"ls ./tmp/01\" ); printf ( \" \\n \" ); printf ( \"./tmp/02: \\n \" ); fflush ( stdout ); sstd :: system ( \"ls ./tmp/02\" ); sstd :: rm ( \"./tmp\" ); } Execution result ./tmp/01: ls: ./tmp/01: No such file or directory ./tmp/02: 01 Implementation Source: sstd/src/file/mv.cpp Header: sstd/src/file/mv.hpp Test: test/file/mv.hpp","title":"mv"},{"location":"src/file/mv.html#mv","text":"","title":"mv"},{"location":"src/file/mv.html#abstract","text":"Function to move file and directory","title":"Abstract"},{"location":"src/file/mv.html#header-file","text":"namespace sstd { bool mv ( const char * pPath_src , const char * pPath_dst ); bool mv ( const std :: string & path_src , const char * pPath_dst ); bool mv ( const char * pPath_src , const std :: string & path_dst ); bool mv ( const std :: string & path_src , const std :: string & path_dst ); }","title":"Header file"},{"location":"src/file/mv.html#description","text":"Function name Description mv() A function to move file and directory from src-path to dst-path. \u30d5\u30a1\u30a4\u30eb\u3084\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u3092 src-path \u304b\u3089 dst-path \u3078\u79fb\u52d5\u3055\u305b\u308b\u95a2\u6570\uff0e","title":"Description"},{"location":"src/file/mv.html#usage","text":"","title":"Usage"},{"location":"src/file/mv.html#move-file-to-file","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp/01\" ); sstd :: mkdir ( \"./tmp/02\" ); sstd :: system ( \"touch ./tmp/01/example.txt\" ); sstd :: mv ( \"./tmp/01/example.txt\" , \"./tmp/02/example.txt\" ); printf ( \"./tmp/01: \\n \" ); fflush ( stdout ); sstd :: system ( \"ls ./tmp/01\" ); printf ( \" \\n \" ); printf ( \"./tmp/02: \\n \" ); fflush ( stdout ); sstd :: system ( \"ls ./tmp/02\" ); sstd :: rm ( \"./tmp\" ); } Execution result ./tmp/01: ./tmp/02: example.txt","title":"move file to file"},{"location":"src/file/mv.html#move-file-to-directory","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp/01\" ); sstd :: mkdir ( \"./tmp/02\" ); sstd :: system ( \"touch ./tmp/01/example.txt\" ); sstd :: mv ( \"./tmp/01/example.txt\" , \"./tmp/02\" ); printf ( \"./tmp/01: \\n \" ); fflush ( stdout ); sstd :: system ( \"ls ./tmp/01\" ); printf ( \" \\n \" ); printf ( \"./tmp/02: \\n \" ); fflush ( stdout ); sstd :: system ( \"ls ./tmp/02\" ); sstd :: rm ( \"./tmp\" ); } Execution result ./tmp/01: ./tmp/02: example.txt","title":"move file to directory"},{"location":"src/file/mv.html#move-directory-to-directory","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp/01\" ); sstd :: mkdir ( \"./tmp/02\" ); sstd :: system ( \"touch ./tmp/01/example.txt\" ); sstd :: mv ( \"./tmp/01\" , \"./tmp/02\" ); printf ( \"./tmp/01: \\n \" ); fflush ( stdout ); sstd :: system ( \"ls ./tmp/01\" ); printf ( \" \\n \" ); printf ( \"./tmp/02: \\n \" ); fflush ( stdout ); sstd :: system ( \"ls ./tmp/02\" ); sstd :: rm ( \"./tmp\" ); } Execution result ./tmp/01: ls: ./tmp/01: No such file or directory ./tmp/02: 01","title":"move directory to directory"},{"location":"src/file/mv.html#implementation","text":"Source: sstd/src/file/mv.cpp Header: sstd/src/file/mv.hpp Test: test/file/mv.hpp","title":"Implementation"},{"location":"src/file/path.html","text":"path Abstract path.hpp contains functions for path editing. path.hpp \u306f\u30d1\u30b9\u7de8\u96c6\u7528\u306e\u95a2\u6570\u3092\u53ce\u9332\u3057\u307e\u3059\uff0e Header file namespace sstd { std :: string path2basePath ( const char * pPath ); std :: string path2basePath_woWC ( const char * pPath ); // _woWC: without wild card std :: string path2dirName ( const char * pPath ); uint path2dirName_begin_idx ( const char * pPath ); uint path2dirName_end_idx ( const char * pPath ); uint path2dirName_end_idx_woWC ( const char * pPath ); // _woWC: without wild card char * path2fileName ( const char * pPath ); std :: string path2fileName ( const std :: string & path ); std :: string path2fileName_woExt ( const char * pPath ); char * path2fileExt ( const char * pPath ); std :: string path2fileExt ( const std :: string & path ); std :: vector < std :: string > parsePath ( const char * pPath ); std :: vector < std :: string > parsePath_wBasePath ( const char * pPath ); // _wBasePath: with base path bool isFile ( const char * pPath ); bool isFile ( const std :: string & path ); bool isDir ( const char * pPath ); bool isDir ( const std :: string & path ); bool fileExist ( const char * pPath ); bool fileExist ( const std :: string & path ); bool dirExist ( const char * pPath ); bool dirExist ( const std :: string & path ); bool pathExist ( const char * pPath ); bool pathExist ( const std :: string & path ); } //----------------------------------------------------------------------------------------------------------------------------------------------- // Below functions are the not recommended to use. (Below functions will be delete on sstd ver 3.x.x). namespace sstd { std :: string getPath ( const char * pPath ); // new name: path2basePath() std :: string getPath_woWC ( const char * pPath ); // new name: path2basePath_woWC() std :: string getDirName ( const char * pPath ); // new name: path2dirName() uint getDirName_begin_idx ( const char * pPath ); // new name: path2dirName_begin_idx() uint getDirName_end_idx ( const char * pPath ); // new name: path2dirName_end_idx() uint getDirName_end_idx_woWC ( const char * pPath ); // new name: path2dirName_end_idx_woWC() char * getFileName ( const char * pPath ); // new name: path2fileName() std :: string getFileName_withoutExtension ( const char * pPath ); // new name: path2fileName_woExt() char * getExtension ( const char * pPath ); // new name: path2fileExt() std :: vector < std :: string > parsePath_withBase ( const char * pPath ); // new name: parsePath_wBasePath() } //----------------------------------------------------------------------------------------------------------------------------------------------- Description Function name Description path2basePath() getPath() will be delete A function to get a path when a string of 1st arg is consisted of a path and a file name. path2basePath_woWC() getPath_woWC() will be delete A function to get a path without wildcard ( * or ? ). (_woWC means without wildcard). path2dirName() getDirName() will be delete A function to get a nearest directory name from file name when a string of 1st arg which is consisted of a path and a file name. path2dirName_begin_idx() getDirName_begin_idx() will be delete A function to get a beginning index number of the nearest directory name from file name when a string of 1st arg is consisted of a path and a file name. path2dirName_end_idx() getDirName_end_idx() will be delete A function to get a ending index number of the nearest directory name from file name when a string of 1st arg is consisted of a path and a file name. In detail, the ending index number is defined next to the ending character. path2dirName_end_idx_woWC() getDirName_end_idx_owWC() will be delete A function to get a ending index number of the nearest directory name from file name without wildcard when a string of 1st arg which is consisted of a path and a file name. In detail, the ending index number is defined next to the ending character. path2fileName() getFileName() will be delete A function to get a file name when a string of 1st arg is consisted of a path and a file name. path2fileName_woExt() getFileName_withoutExtension() will be delete A function to get a file name without file extension when a string of 1st arg is consisted of a path and a file name. path2fileExt() getExtension() will be delete A function to get a file extension. When a string of 1st arg does not have a file extension, 0 length string is returned. parsePath() A function to parse a path by / or \\\\ . parsePath_wBasePath() parsePath_withBase() will be delete A function to parse a path by / or \\\\ and return with the base path from the 1st arg. isFile() Exactory same as the fileExist() isDir() Exactory same as the dirExist() fileExist() A function to judge whether a file is exist or not. dirExist() A function to judge whether a directory is exist or not. pathExist() A function to judge whether a path is exist or not. Usage path2basePath(), path2basePath_woWC() main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: path2basePath ( \"./abc/def/example.txt\" ) ); sstd :: printn ( sstd :: path2basePath ( \"./abc/def/\" ) ); sstd :: printn ( sstd :: path2basePath ( \"./abc/def\" ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: path2basePath_woWC ( \"./abc/def/example.txt\" ) ); sstd :: printn ( sstd :: path2basePath_woWC ( R \" ( ./abc/d??/*.txt ) \" ) ); } NOTE: This sample use raw string literals R\"()\" to avoid unknown escape sequence: '\\*' error. Execution result sstd::path2basePath(\"./abc/def/example.txt\") = \"./abc/def\" sstd::path2basePath(\"./abc/def/\") = \"./abc/def\" sstd::path2basePath(\"./abc/def\") = \"./abc\" sstd::path2basePath_woWC(\"./abc/def/example.txt\") = \"./abc/def\" sstd::path2basePath_woWC(R\"(./abc/d??/*.txt)\") = \"./abc\" path2dirName(), path2dirName_begin_idx(), path2dirName_end_idx(), path2dirName_end_idx_owWC() main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: path2dirName ( \"./abc/def\" ) ); sstd :: printn ( sstd :: path2dirName ( \"./abc/def/\" ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: path2dirName ( \"./abc/def/example.txt\" ) ); // NOTE: path2dirName() treats end name as a direcotry name. If you want to parse this type of path, write like bolow line. sstd :: printn ( sstd :: path2dirName ( sstd :: path2basePath ( \"./abc/def/example.txt\" )) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: path2dirName_begin_idx ( \"./abc/def/\" ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: path2dirName_end_idx ( \"./abc/def/\" ) ); sstd :: printn ( sstd :: path2dirName_end_idx_woWC ( \"./abc/def/\" ) ); sstd :: printn ( sstd :: path2dirName_end_idx_woWC ( R \" ( ./abc/d??/ ) \" ) ); } Execution result sstd::path2dirName(\"./abc/def\") = \"def\" sstd::path2dirName(\"./abc/def/\") = \"def\" sstd::path2dirName(\"./abc/def/example.txt\") = \"example.txt\" sstd::path2dirName(sstd::path2basePath(\"./abc/def/example.txt\")) = \"def\" sstd::path2dirName_begin_idx(\"./abc/def/\") = 6 sstd::path2dirName_end_idx(\"./abc/def/\") = 10 sstd::path2dirName_end_idx_woWC(\"./abc/def/\") = 10 sstd::path2dirName_end_idx_woWC(R\"(./abc/d??/)\") = 6 path2fileName(), path2fileName_woExt() main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: path2fileName ( \"./abc/def/example.txt\" ) ); sstd :: printn ( sstd :: path2fileName ( \"./abc/def/example\" ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: path2fileName_woExt ( \"./abc/def/example.txt\" ) ); sstd :: printn ( sstd :: path2fileName_woExt ( \"./abc/def/example\" ) ); sstd :: printn ( sstd :: path2fileName_woExt ( \"./abc/def/example.txt.zip\" ) ); } Execution result sstd::path2fileName(\"./abc/def/example.txt\") = \"example.txt\" sstd::path2fileName(\"./abc/def/example\") = \"example\" sstd::path2fileName_woExt(\"./abc/def/example.txt\") = \"example\" sstd::path2fileName_woExt(\"./abc/def/example\") = \"example\" sstd::path2fileName_woExt(\"./abc/def/example.txt.zip\") = \"example.txt\" path2fileExt() main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: path2fileExt ( \"./abc/def/example.txt\" ) ); sstd :: printn ( sstd :: path2fileExt ( \"./abc/def/example\" ) ); } Execution result sstd::path2fileExt(\"./abc/def/example.txt\") = \"txt\" sstd::path2fileExt(\"./abc/def/example\") = \"(null)\" parsePath(), parsePath_wBasePath() main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: parsePath ( \"./abc/def/example.txt\" ) ); sstd :: printn ( sstd :: parsePath_wBasePath ( \"./abc/def/example\" ) ); } Execution result sstd::parsePath(\"./abc/def/example.txt\") = [\".\" \"abc\" \"def\" \"example.txt\"] sstd::parsePath_wBasePath(\"./abc/def/example\") = [\".\" \"./abc\" \"./abc/def\" \"./abc/def/example\"] isFile(), isDir(), fileExist(), dirExist(), pathExist() main.cpp #include <sstd/sstd.hpp> int main (){ // sstd::isFile() is exactory same as the `sstd::fileExist()`. // sstd::isDir() is exactory same as the `sstd::dirExist()`. sstd :: printn ( sstd :: fileExist ( \"./tmp/abc/def/example.txt\" ) ); sstd :: printn ( sstd :: dirExist ( \"./tmp/abc/def\" ) ); sstd :: printn ( sstd :: pathExist ( \"./tmp/abc/def\" ) ); sstd :: printn ( sstd :: pathExist ( \"./tmp/abc/def/example.txt\" ) ); printf ( \" \\n \" ); sstd :: mkdir ( \"tmp\" ); sstd :: mkdir ( \"./tmp/abc/def\" ); sstd :: system ( \"touch ./tmp/abc/def/example.txt\" ); sstd :: printn ( sstd :: fileExist ( \"./tmp/abc/def/example.txt\" ) ); sstd :: printn ( sstd :: dirExist ( \"./tmp/abc/def\" ) ); sstd :: printn ( sstd :: pathExist ( \"./tmp/abc/def\" ) ); sstd :: printn ( sstd :: pathExist ( \"./tmp/abc/def/example.txt\" ) ); sstd :: rm ( \"tmp\" ); } Execution result sstd::fileExist(\"./tmp/abc/def/example.txt\") = false sstd::dirExist(\"./tmp/abc/def\") = false sstd::pathExist(\"./tmp/abc/def\") = false sstd::pathExist(\"./tmp/abc/def/example.txt\") = false sstd::fileExist(\"./tmp/abc/def/example.txt\") = true sstd::dirExist(\"./tmp/abc/def\") = true sstd::pathExist(\"./tmp/abc/def\") = true sstd::pathExist(\"./tmp/abc/def/example.txt\") = true Implementation Source: sstd/src/file/path.cpp Header: sstd/src/file/path.hpp Test: test/file/path.hpp","title":"path"},{"location":"src/file/path.html#path","text":"","title":"path"},{"location":"src/file/path.html#abstract","text":"path.hpp contains functions for path editing. path.hpp \u306f\u30d1\u30b9\u7de8\u96c6\u7528\u306e\u95a2\u6570\u3092\u53ce\u9332\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/file/path.html#header-file","text":"namespace sstd { std :: string path2basePath ( const char * pPath ); std :: string path2basePath_woWC ( const char * pPath ); // _woWC: without wild card std :: string path2dirName ( const char * pPath ); uint path2dirName_begin_idx ( const char * pPath ); uint path2dirName_end_idx ( const char * pPath ); uint path2dirName_end_idx_woWC ( const char * pPath ); // _woWC: without wild card char * path2fileName ( const char * pPath ); std :: string path2fileName ( const std :: string & path ); std :: string path2fileName_woExt ( const char * pPath ); char * path2fileExt ( const char * pPath ); std :: string path2fileExt ( const std :: string & path ); std :: vector < std :: string > parsePath ( const char * pPath ); std :: vector < std :: string > parsePath_wBasePath ( const char * pPath ); // _wBasePath: with base path bool isFile ( const char * pPath ); bool isFile ( const std :: string & path ); bool isDir ( const char * pPath ); bool isDir ( const std :: string & path ); bool fileExist ( const char * pPath ); bool fileExist ( const std :: string & path ); bool dirExist ( const char * pPath ); bool dirExist ( const std :: string & path ); bool pathExist ( const char * pPath ); bool pathExist ( const std :: string & path ); } //----------------------------------------------------------------------------------------------------------------------------------------------- // Below functions are the not recommended to use. (Below functions will be delete on sstd ver 3.x.x). namespace sstd { std :: string getPath ( const char * pPath ); // new name: path2basePath() std :: string getPath_woWC ( const char * pPath ); // new name: path2basePath_woWC() std :: string getDirName ( const char * pPath ); // new name: path2dirName() uint getDirName_begin_idx ( const char * pPath ); // new name: path2dirName_begin_idx() uint getDirName_end_idx ( const char * pPath ); // new name: path2dirName_end_idx() uint getDirName_end_idx_woWC ( const char * pPath ); // new name: path2dirName_end_idx_woWC() char * getFileName ( const char * pPath ); // new name: path2fileName() std :: string getFileName_withoutExtension ( const char * pPath ); // new name: path2fileName_woExt() char * getExtension ( const char * pPath ); // new name: path2fileExt() std :: vector < std :: string > parsePath_withBase ( const char * pPath ); // new name: parsePath_wBasePath() } //-----------------------------------------------------------------------------------------------------------------------------------------------","title":"Header file"},{"location":"src/file/path.html#description","text":"Function name Description path2basePath() getPath() will be delete A function to get a path when a string of 1st arg is consisted of a path and a file name. path2basePath_woWC() getPath_woWC() will be delete A function to get a path without wildcard ( * or ? ). (_woWC means without wildcard). path2dirName() getDirName() will be delete A function to get a nearest directory name from file name when a string of 1st arg which is consisted of a path and a file name. path2dirName_begin_idx() getDirName_begin_idx() will be delete A function to get a beginning index number of the nearest directory name from file name when a string of 1st arg is consisted of a path and a file name. path2dirName_end_idx() getDirName_end_idx() will be delete A function to get a ending index number of the nearest directory name from file name when a string of 1st arg is consisted of a path and a file name. In detail, the ending index number is defined next to the ending character. path2dirName_end_idx_woWC() getDirName_end_idx_owWC() will be delete A function to get a ending index number of the nearest directory name from file name without wildcard when a string of 1st arg which is consisted of a path and a file name. In detail, the ending index number is defined next to the ending character. path2fileName() getFileName() will be delete A function to get a file name when a string of 1st arg is consisted of a path and a file name. path2fileName_woExt() getFileName_withoutExtension() will be delete A function to get a file name without file extension when a string of 1st arg is consisted of a path and a file name. path2fileExt() getExtension() will be delete A function to get a file extension. When a string of 1st arg does not have a file extension, 0 length string is returned. parsePath() A function to parse a path by / or \\\\ . parsePath_wBasePath() parsePath_withBase() will be delete A function to parse a path by / or \\\\ and return with the base path from the 1st arg. isFile() Exactory same as the fileExist() isDir() Exactory same as the dirExist() fileExist() A function to judge whether a file is exist or not. dirExist() A function to judge whether a directory is exist or not. pathExist() A function to judge whether a path is exist or not.","title":"Description"},{"location":"src/file/path.html#usage","text":"","title":"Usage"},{"location":"src/file/path.html#path2basepath-path2basepath_wowc","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: path2basePath ( \"./abc/def/example.txt\" ) ); sstd :: printn ( sstd :: path2basePath ( \"./abc/def/\" ) ); sstd :: printn ( sstd :: path2basePath ( \"./abc/def\" ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: path2basePath_woWC ( \"./abc/def/example.txt\" ) ); sstd :: printn ( sstd :: path2basePath_woWC ( R \" ( ./abc/d??/*.txt ) \" ) ); } NOTE: This sample use raw string literals R\"()\" to avoid unknown escape sequence: '\\*' error. Execution result sstd::path2basePath(\"./abc/def/example.txt\") = \"./abc/def\" sstd::path2basePath(\"./abc/def/\") = \"./abc/def\" sstd::path2basePath(\"./abc/def\") = \"./abc\" sstd::path2basePath_woWC(\"./abc/def/example.txt\") = \"./abc/def\" sstd::path2basePath_woWC(R\"(./abc/d??/*.txt)\") = \"./abc\"","title":"path2basePath(), path2basePath_woWC()"},{"location":"src/file/path.html#path2dirname-path2dirname_begin_idx-path2dirname_end_idx-path2dirname_end_idx_owwc","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: path2dirName ( \"./abc/def\" ) ); sstd :: printn ( sstd :: path2dirName ( \"./abc/def/\" ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: path2dirName ( \"./abc/def/example.txt\" ) ); // NOTE: path2dirName() treats end name as a direcotry name. If you want to parse this type of path, write like bolow line. sstd :: printn ( sstd :: path2dirName ( sstd :: path2basePath ( \"./abc/def/example.txt\" )) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: path2dirName_begin_idx ( \"./abc/def/\" ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: path2dirName_end_idx ( \"./abc/def/\" ) ); sstd :: printn ( sstd :: path2dirName_end_idx_woWC ( \"./abc/def/\" ) ); sstd :: printn ( sstd :: path2dirName_end_idx_woWC ( R \" ( ./abc/d??/ ) \" ) ); } Execution result sstd::path2dirName(\"./abc/def\") = \"def\" sstd::path2dirName(\"./abc/def/\") = \"def\" sstd::path2dirName(\"./abc/def/example.txt\") = \"example.txt\" sstd::path2dirName(sstd::path2basePath(\"./abc/def/example.txt\")) = \"def\" sstd::path2dirName_begin_idx(\"./abc/def/\") = 6 sstd::path2dirName_end_idx(\"./abc/def/\") = 10 sstd::path2dirName_end_idx_woWC(\"./abc/def/\") = 10 sstd::path2dirName_end_idx_woWC(R\"(./abc/d??/)\") = 6","title":"path2dirName(), path2dirName_begin_idx(), path2dirName_end_idx(), path2dirName_end_idx_owWC()"},{"location":"src/file/path.html#path2filename-path2filename_woext","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: path2fileName ( \"./abc/def/example.txt\" ) ); sstd :: printn ( sstd :: path2fileName ( \"./abc/def/example\" ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: path2fileName_woExt ( \"./abc/def/example.txt\" ) ); sstd :: printn ( sstd :: path2fileName_woExt ( \"./abc/def/example\" ) ); sstd :: printn ( sstd :: path2fileName_woExt ( \"./abc/def/example.txt.zip\" ) ); } Execution result sstd::path2fileName(\"./abc/def/example.txt\") = \"example.txt\" sstd::path2fileName(\"./abc/def/example\") = \"example\" sstd::path2fileName_woExt(\"./abc/def/example.txt\") = \"example\" sstd::path2fileName_woExt(\"./abc/def/example\") = \"example\" sstd::path2fileName_woExt(\"./abc/def/example.txt.zip\") = \"example.txt\"","title":"path2fileName(), path2fileName_woExt()"},{"location":"src/file/path.html#path2fileext","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: path2fileExt ( \"./abc/def/example.txt\" ) ); sstd :: printn ( sstd :: path2fileExt ( \"./abc/def/example\" ) ); } Execution result sstd::path2fileExt(\"./abc/def/example.txt\") = \"txt\" sstd::path2fileExt(\"./abc/def/example\") = \"(null)\"","title":"path2fileExt()"},{"location":"src/file/path.html#parsepath-parsepath_wbasepath","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: parsePath ( \"./abc/def/example.txt\" ) ); sstd :: printn ( sstd :: parsePath_wBasePath ( \"./abc/def/example\" ) ); } Execution result sstd::parsePath(\"./abc/def/example.txt\") = [\".\" \"abc\" \"def\" \"example.txt\"] sstd::parsePath_wBasePath(\"./abc/def/example\") = [\".\" \"./abc\" \"./abc/def\" \"./abc/def/example\"]","title":"parsePath(), parsePath_wBasePath()"},{"location":"src/file/path.html#isfile-isdir-fileexist-direxist-pathexist","text":"main.cpp #include <sstd/sstd.hpp> int main (){ // sstd::isFile() is exactory same as the `sstd::fileExist()`. // sstd::isDir() is exactory same as the `sstd::dirExist()`. sstd :: printn ( sstd :: fileExist ( \"./tmp/abc/def/example.txt\" ) ); sstd :: printn ( sstd :: dirExist ( \"./tmp/abc/def\" ) ); sstd :: printn ( sstd :: pathExist ( \"./tmp/abc/def\" ) ); sstd :: printn ( sstd :: pathExist ( \"./tmp/abc/def/example.txt\" ) ); printf ( \" \\n \" ); sstd :: mkdir ( \"tmp\" ); sstd :: mkdir ( \"./tmp/abc/def\" ); sstd :: system ( \"touch ./tmp/abc/def/example.txt\" ); sstd :: printn ( sstd :: fileExist ( \"./tmp/abc/def/example.txt\" ) ); sstd :: printn ( sstd :: dirExist ( \"./tmp/abc/def\" ) ); sstd :: printn ( sstd :: pathExist ( \"./tmp/abc/def\" ) ); sstd :: printn ( sstd :: pathExist ( \"./tmp/abc/def/example.txt\" ) ); sstd :: rm ( \"tmp\" ); } Execution result sstd::fileExist(\"./tmp/abc/def/example.txt\") = false sstd::dirExist(\"./tmp/abc/def\") = false sstd::pathExist(\"./tmp/abc/def\") = false sstd::pathExist(\"./tmp/abc/def/example.txt\") = false sstd::fileExist(\"./tmp/abc/def/example.txt\") = true sstd::dirExist(\"./tmp/abc/def\") = true sstd::pathExist(\"./tmp/abc/def\") = true sstd::pathExist(\"./tmp/abc/def/example.txt\") = true","title":"isFile(), isDir(), fileExist(), dirExist(), pathExist()"},{"location":"src/file/path.html#implementation","text":"Source: sstd/src/file/path.cpp Header: sstd/src/file/path.hpp Test: test/file/path.hpp","title":"Implementation"},{"location":"src/file/read_write.html","text":"read / write Abstract Functions for reading and writing files. \u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u66f8\u304d\u306b\u5229\u7528\u3059\u308b\u95a2\u6570\uff0e Header file namespace sstd { bool read_bin ( std :: vector < uint8 >& ret , const char * path ); bool read_bin ( std :: vector < uint8 >& ret , const std :: string & path ); std :: vector < uint8 > read_bin ( const char * path ); std :: vector < uint8 > read_bin ( const std :: string & path ); bool write_bin ( const char * path , std :: vector < uint8 >& rhs ); bool write_bin ( const std :: string & path , std :: vector < uint8 >& rhs ); std :: string read ( const char * path ); std :: string read ( const std :: string & path ); bool read_woBOM ( std :: string & ret_str , const char * path ); // wo: without bool read_woBOM ( std :: string & ret_str , const std :: string & path ); // wo: without size_t write ( const char * path , const void * ptr , const size_t type_size , const size_t num ); // (1) size_t write ( const std :: string & path , const void * ptr , const size_t type_size , const size_t num ); // (2) size_t write ( const char * path , const std :: string & s ); // (3) size_t write ( const std :: string & path , const char * s ); // (4) size_t write ( const std :: string & path , const std :: string & s ); // (5) } //----------------------------------------------------------------------------------------------------------------------------------------------- // Below functions are the not recommended to use. (Below functions will be delete on sstd ver 3.x.x). namespace sstd { std :: string read_withoutBOM ( const char * path ); std :: string read_withoutBOM ( const std :: string & path ); } //----------------------------------------------------------------------------------------------------------------------------------------------- Description Function name Description read_bin() write_bin() read() read_woBOM() returns string without BOM. BOM \u3092\u53d6\u308a\u9664\u3044\u305f\u6587\u5b57\u5217\u3092 std::string \u3068\u3057\u3066\u8fd4\u5374\u3057\u307e\u3059\uff0e write() Usage main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); std :: string f_path = \"./tmp/test_read_write.txt\" ; std :: string s = \"abcdef \\n GHIJK\" ; size_t w_size = sstd :: write ( f_path , s ); sstd :: printn ( w_size ); std :: string s_read = sstd :: read ( f_path ); sstd :: printn ( s_read . size ()); sstd :: printn ( s_read ); sstd :: rm ( \"./tmp\" ); } Execution result w_size = 12 s_read.size() = 12 s_read = \"abcdef GHIJK\" Implementation Source: sstd/src/file/read_write.cpp Header: sstd/src/file/read_write.hpp Test: test/file/read_write.hpp (Not implemented yet)","title":"read / write"},{"location":"src/file/read_write.html#read-write","text":"","title":"read / write"},{"location":"src/file/read_write.html#abstract","text":"Functions for reading and writing files. \u30d5\u30a1\u30a4\u30eb\u306e\u8aad\u307f\u66f8\u304d\u306b\u5229\u7528\u3059\u308b\u95a2\u6570\uff0e","title":"Abstract"},{"location":"src/file/read_write.html#header-file","text":"namespace sstd { bool read_bin ( std :: vector < uint8 >& ret , const char * path ); bool read_bin ( std :: vector < uint8 >& ret , const std :: string & path ); std :: vector < uint8 > read_bin ( const char * path ); std :: vector < uint8 > read_bin ( const std :: string & path ); bool write_bin ( const char * path , std :: vector < uint8 >& rhs ); bool write_bin ( const std :: string & path , std :: vector < uint8 >& rhs ); std :: string read ( const char * path ); std :: string read ( const std :: string & path ); bool read_woBOM ( std :: string & ret_str , const char * path ); // wo: without bool read_woBOM ( std :: string & ret_str , const std :: string & path ); // wo: without size_t write ( const char * path , const void * ptr , const size_t type_size , const size_t num ); // (1) size_t write ( const std :: string & path , const void * ptr , const size_t type_size , const size_t num ); // (2) size_t write ( const char * path , const std :: string & s ); // (3) size_t write ( const std :: string & path , const char * s ); // (4) size_t write ( const std :: string & path , const std :: string & s ); // (5) } //----------------------------------------------------------------------------------------------------------------------------------------------- // Below functions are the not recommended to use. (Below functions will be delete on sstd ver 3.x.x). namespace sstd { std :: string read_withoutBOM ( const char * path ); std :: string read_withoutBOM ( const std :: string & path ); } //-----------------------------------------------------------------------------------------------------------------------------------------------","title":"Header file"},{"location":"src/file/read_write.html#description","text":"Function name Description read_bin() write_bin() read() read_woBOM() returns string without BOM. BOM \u3092\u53d6\u308a\u9664\u3044\u305f\u6587\u5b57\u5217\u3092 std::string \u3068\u3057\u3066\u8fd4\u5374\u3057\u307e\u3059\uff0e write()","title":"Description"},{"location":"src/file/read_write.html#usage","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); std :: string f_path = \"./tmp/test_read_write.txt\" ; std :: string s = \"abcdef \\n GHIJK\" ; size_t w_size = sstd :: write ( f_path , s ); sstd :: printn ( w_size ); std :: string s_read = sstd :: read ( f_path ); sstd :: printn ( s_read . size ()); sstd :: printn ( s_read ); sstd :: rm ( \"./tmp\" ); } Execution result w_size = 12 s_read.size() = 12 s_read = \"abcdef GHIJK\"","title":"Usage"},{"location":"src/file/read_write.html#implementation","text":"Source: sstd/src/file/read_write.cpp Header: sstd/src/file/read_write.hpp Test: test/file/read_write.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/file/rm.html","text":"rm Abstract rm.cpp / rm.hpp contains the processing related to deletion. rm.cpp / rm.hpp \u306b\u306f\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u524a\u9664\u306b\u95a2\u3059\u308b\u51e6\u7406\u3092\u53ce\u9332\u3057\u307e\u3059\uff0e Header file namespace sstd { struct pathAndType { std :: string path ; char type ; // 'f': file, 'd': directory }; bool unlink ( const char * pPath ); // delete file bool unlink ( const std :: string & path ); // delete file bool rmdir ( const char * pPath ); // delete empty directory bool rmdir ( const std :: string & path ); // delete empty directory bool rm ( const char * pPath ); // delete all under the pPath bool rm ( const std :: string & path ); // delete all under the path } Usage Removing directories recursively (\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306e\u518d\u5e30\u7684\u306a\u524a\u9664) main.cpp #include <sstd/sstd.hpp> int main (){ printf ( \"--- mkdir --- \\n \" ); fflush ( stdout ); sstd :: mkdir ( \"./tmp/a/b/c\" ); sstd :: system ( \"tree ./tmp\" ); printf ( \" \\n\\n \" ); printf ( \"--- rm --- \\n \" ); fflush ( stdout ); sstd :: rm ( \"./tmp\" ); sstd :: system ( \"tree ./tmp\" ); } Execution result --- mkdir --- ./tmp \u2514\u2500\u2500 a \u2514\u2500\u2500 b \u2514\u2500\u2500 c 3 directories, 0 files --- rm --- ./tmp [error opening dir] 0 directories, 0 files Implementation Source: sstd/src/rm.cpp Header: sstd/src/rm.hpp Test: test/rm.hpp (Not implemented yet)","title":"rm"},{"location":"src/file/rm.html#rm","text":"","title":"rm"},{"location":"src/file/rm.html#abstract","text":"rm.cpp / rm.hpp contains the processing related to deletion. rm.cpp / rm.hpp \u306b\u306f\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u524a\u9664\u306b\u95a2\u3059\u308b\u51e6\u7406\u3092\u53ce\u9332\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/file/rm.html#header-file","text":"namespace sstd { struct pathAndType { std :: string path ; char type ; // 'f': file, 'd': directory }; bool unlink ( const char * pPath ); // delete file bool unlink ( const std :: string & path ); // delete file bool rmdir ( const char * pPath ); // delete empty directory bool rmdir ( const std :: string & path ); // delete empty directory bool rm ( const char * pPath ); // delete all under the pPath bool rm ( const std :: string & path ); // delete all under the path }","title":"Header file"},{"location":"src/file/rm.html#usage","text":"","title":"Usage"},{"location":"src/file/rm.html#removing-directories-recursively","text":"main.cpp #include <sstd/sstd.hpp> int main (){ printf ( \"--- mkdir --- \\n \" ); fflush ( stdout ); sstd :: mkdir ( \"./tmp/a/b/c\" ); sstd :: system ( \"tree ./tmp\" ); printf ( \" \\n\\n \" ); printf ( \"--- rm --- \\n \" ); fflush ( stdout ); sstd :: rm ( \"./tmp\" ); sstd :: system ( \"tree ./tmp\" ); } Execution result --- mkdir --- ./tmp \u2514\u2500\u2500 a \u2514\u2500\u2500 b \u2514\u2500\u2500 c 3 directories, 0 files --- rm --- ./tmp [error opening dir] 0 directories, 0 files","title":"Removing directories recursively (\u30c7\u30a3\u30ec\u30af\u30c8\u30ea\u306e\u518d\u5e30\u7684\u306a\u524a\u9664)"},{"location":"src/file/rm.html#implementation","text":"Source: sstd/src/rm.cpp Header: sstd/src/rm.hpp Test: test/rm.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/file/tinyInterpreter.html","text":"tinyInterpreter Abstract getCommandList() read text file, defineing middle of /*~*/ and before // as a commnet. And up to ; is considered as one command list. The returning the value is formed as a list of command. getCommandList() \u306f txt \u30d5\u30a1\u30a4\u30eb\u3092\u8aad\u307f\u8fbc\u307f\u307e\u3059\uff0e\u3053\u306e\u969b\u306b\uff0c /*~*/ \u3067\u56f2\u307e\u308c\u305f\u533a\u9593\u3084\uff0c\u540c\u4e00\u884c\u4e2d\u3067 // \u3088\u308a\u5f8c\u308d\u306e\u6587\u5b57\u5217\u3092\u30b3\u30e1\u30f3\u30c8\u3068\u307f\u306a\u3057\u53d6\u308a\u9664\u304d\u307e\u3059\uff0e \u307e\u305f\uff0c ; \u307e\u3067\u3092\u4e00\u3064\u306e\u30b3\u30de\u30f3\u30c9\u30ea\u30b9\u30c8\u307f\u306a\u3057\u307e\u3059\uff0e\u623b\u308a\u5024\u306f\u30b3\u30de\u30f3\u30c9\u306e\u30ea\u30b9\u30c8\u306e\u5f62\u5f0f\u3068\u306a\u308a\u307e\u3059\uff0e Header file namespace sstd { std :: vector < std :: string > getCommandList ( const char * pReadFile ); std :: vector < std :: string > splitByComma ( const std :: string & str ); } Usage tinyInterpreter.txt // - In this file, middle of \"/*~*/\" and before \"//\" mean commnets. // And a \";\" means the end of command. // comment /* comment */ /* comment comment comment */ cmd01, cmd02, , cmd04; // comment cmd05, cmd06, cmd07; // comment cmd09, cmd10, cmd11, cmd12; main.cpp #include <sstd/sstd.hpp> int main (){ // reading \"tinyInterpreter.txt\" to vv_ret std :: vector < std :: string > v_line = sstd :: getCommandList ( R \" ( ./tinyInterpreter.txt ) \" ); sstd :: vvec < std :: string > vv_ret ( v_line . size ()); for ( uint i = 0 ; i < v_line . size (); ++ i ){ std :: vector < std :: string > v_cmd = sstd :: splitByComma ( v_line [ i ]); for ( uint n = 0 ; n < v_cmd . size (); ++ n ){ vv_ret [ i ] <<= v_cmd [ n ]; } } sstd :: printn ( vv_ret ); } Execution result vv_ret = [[\"cmd01\" \"cmd02\" \"\" \"cmd04\"] [\"cmd05\" \"cmd06\" \"cmd07\"] [\"cmd09\" \"cmd10\" \"cmd11\" \"cmd12\"]] Implementation Source: sstd/src/file/tinyInterpreter.cpp Header: sstd/src/file/tinyInterpreter.hpp Test: test/file/tinyInterpreter.hpp","title":"tinyInterpreter"},{"location":"src/file/tinyInterpreter.html#tinyinterpreter","text":"","title":"tinyInterpreter"},{"location":"src/file/tinyInterpreter.html#abstract","text":"getCommandList() read text file, defineing middle of /*~*/ and before // as a commnet. And up to ; is considered as one command list. The returning the value is formed as a list of command. getCommandList() \u306f txt \u30d5\u30a1\u30a4\u30eb\u3092\u8aad\u307f\u8fbc\u307f\u307e\u3059\uff0e\u3053\u306e\u969b\u306b\uff0c /*~*/ \u3067\u56f2\u307e\u308c\u305f\u533a\u9593\u3084\uff0c\u540c\u4e00\u884c\u4e2d\u3067 // \u3088\u308a\u5f8c\u308d\u306e\u6587\u5b57\u5217\u3092\u30b3\u30e1\u30f3\u30c8\u3068\u307f\u306a\u3057\u53d6\u308a\u9664\u304d\u307e\u3059\uff0e \u307e\u305f\uff0c ; \u307e\u3067\u3092\u4e00\u3064\u306e\u30b3\u30de\u30f3\u30c9\u30ea\u30b9\u30c8\u307f\u306a\u3057\u307e\u3059\uff0e\u623b\u308a\u5024\u306f\u30b3\u30de\u30f3\u30c9\u306e\u30ea\u30b9\u30c8\u306e\u5f62\u5f0f\u3068\u306a\u308a\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/file/tinyInterpreter.html#header-file","text":"namespace sstd { std :: vector < std :: string > getCommandList ( const char * pReadFile ); std :: vector < std :: string > splitByComma ( const std :: string & str ); }","title":"Header file"},{"location":"src/file/tinyInterpreter.html#usage","text":"tinyInterpreter.txt // - In this file, middle of \"/*~*/\" and before \"//\" mean commnets. // And a \";\" means the end of command. // comment /* comment */ /* comment comment comment */ cmd01, cmd02, , cmd04; // comment cmd05, cmd06, cmd07; // comment cmd09, cmd10, cmd11, cmd12; main.cpp #include <sstd/sstd.hpp> int main (){ // reading \"tinyInterpreter.txt\" to vv_ret std :: vector < std :: string > v_line = sstd :: getCommandList ( R \" ( ./tinyInterpreter.txt ) \" ); sstd :: vvec < std :: string > vv_ret ( v_line . size ()); for ( uint i = 0 ; i < v_line . size (); ++ i ){ std :: vector < std :: string > v_cmd = sstd :: splitByComma ( v_line [ i ]); for ( uint n = 0 ; n < v_cmd . size (); ++ n ){ vv_ret [ i ] <<= v_cmd [ n ]; } } sstd :: printn ( vv_ret ); } Execution result vv_ret = [[\"cmd01\" \"cmd02\" \"\" \"cmd04\"] [\"cmd05\" \"cmd06\" \"cmd07\"] [\"cmd09\" \"cmd10\" \"cmd11\" \"cmd12\"]]","title":"Usage"},{"location":"src/file/tinyInterpreter.html#implementation","text":"Source: sstd/src/file/tinyInterpreter.cpp Header: sstd/src/file/tinyInterpreter.hpp Test: test/file/tinyInterpreter.hpp","title":"Implementation"},{"location":"src/hashFunction/hashSum.html","text":"hashSum Abstract Functions compatible with the hashSum commands. \u30cf\u30c3\u30b7\u30e5\u5024\u3092\u8a08\u7b97\u3059\u308b\u30b3\u30de\u30f3\u30c9\u306e\u4e92\u63db\u95a2\u6570\u3067\u3059\uff0e Header file namespace sstd { std :: string vecUint8_to_hexString ( const std :: vector < uint8 >& hash ); std :: string md5sum ( const char * pPath ); std :: string sha1sum ( const char * pPath ); std :: string sha224sum ( const char * pPath ); std :: string sha256sum ( const char * pPath ); std :: string sha384sum ( const char * pPath ); std :: string sha512sum ( const char * pPath ); std :: string md5sum ( const std :: string & path ); std :: string sha1sum ( const std :: string & path ); std :: string sha224sum ( const std :: string & path ); std :: string sha256sum ( const std :: string & path ); std :: string sha384sum ( const std :: string & path ); std :: string sha512sum ( const std :: string & path ); } Description Function name Description vecUint8_to_hexString() converts the input binary to to a hexadecimal string. \u5165\u529b\u3055\u308c\u305f\u30d0\u30a4\u30ca\u30ea\u3092\uff0c16 \u9032\u6570\u8868\u8a18\u306e\u6587\u5b57\u5217\u306b\u5909\u63db\u3057\u307e\u3059\uff0e md5sum() returns the result of md5sum calculation as a string. And returns 0 length std::string object when the md5sum() function failed. md5sum \u306e\u8a08\u7b97\u7d50\u679c\u3092\u6587\u5b57\u5217\u3067\u8fd4\u3057\u307e\u3059\uff0e\u95a2\u6570\u304c\u5931\u6557\u3057\u305f\u5834\u5408\u306f\uff0c\u9577\u3055 0 \u306e std::string \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u8fd4\u5374\u3057\u307e\u3059\uff0e sha1sum() returns the result of sha1sum calculation as a string. And returns 0 length std::string object when the sha1sum() function failed. sha1sum \u306e\u8a08\u7b97\u7d50\u679c\u3092\u6587\u5b57\u5217\u3067\u8fd4\u3057\u307e\u3059\uff0e\u95a2\u6570\u304c\u5931\u6557\u3057\u305f\u5834\u5408\u306f\uff0c\u9577\u3055 0 \u306e std::string \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u8fd4\u5374\u3057\u307e\u3059\uff0e sha224sum() returns the result of sha224sum calculation as a string. And returns 0 length std::string object when the sha224sum() function failed. sha224sum \u306e\u8a08\u7b97\u7d50\u679c\u3092\u6587\u5b57\u5217\u3067\u8fd4\u3057\u307e\u3059\uff0e\u95a2\u6570\u304c\u5931\u6557\u3057\u305f\u5834\u5408\u306f\uff0c\u9577\u3055 0 \u306e std::string \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u8fd4\u5374\u3057\u307e\u3059\uff0e sha256sum() returns the result of sha256sum calculation as a string. And returns 0 length std::string object when the sha256sum() function failed. sha256sum \u306e\u8a08\u7b97\u7d50\u679c\u3092\u6587\u5b57\u5217\u3067\u8fd4\u3057\u307e\u3059\uff0e\u95a2\u6570\u304c\u5931\u6557\u3057\u305f\u5834\u5408\u306f\uff0c\u9577\u3055 0 \u306e std::string \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u8fd4\u5374\u3057\u307e\u3059\uff0e sha384sum() returns the result of sha384sum calculation as a string. And returns 0 length std::string object when the sha384sum() function failed. sha384sum \u306e\u8a08\u7b97\u7d50\u679c\u3092\u6587\u5b57\u5217\u3067\u8fd4\u3057\u307e\u3059\uff0e\u95a2\u6570\u304c\u5931\u6557\u3057\u305f\u5834\u5408\u306f\uff0c\u9577\u3055 0 \u306e std::string \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u8fd4\u5374\u3057\u307e\u3059\uff0e sha512sum() returns the result of sha512sum calculation as a string. And returns 0 length std::string object when the sha512sum() function failed. sha512sum \u306e\u8a08\u7b97\u7d50\u679c\u3092\u6587\u5b57\u5217\u3067\u8fd4\u3057\u307e\u3059\uff0e\u95a2\u6570\u304c\u5931\u6557\u3057\u305f\u5834\u5408\u306f\uff0c\u9577\u3055 0 \u306e std::string \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u8fd4\u5374\u3057\u307e\u3059\uff0e Usage main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"head -c 5m /dev/urandom > ./tmp/rand.bin\" ); // generate 5 MB random file sstd :: printn ( sstd :: sha256sum ( \"./tmp/rand.bin\" ) ); printf ( \" \\n \" ); fflush ( stdout ); sstd :: system ( \"sha256sum ./tmp/rand.bin\" ); sstd :: rm ( \"./tmp\" ); } Execution result sstd::sha256sum(\"./tmp/rand.bin\") = \"f5863a6d9a95fa165bc4b43115646511f89610ff5f3ca7026612aee7ca03d923\" f5863a6d9a95fa165bc4b43115646511f89610ff5f3ca7026612aee7ca03d923 ./tmp/rand.bin Implementation Source: sstd/src/hashFnc_of_MD5_SHA1_SHA2/hashSum.cpp Header: sstd/src/hashFnc_of_MD5_SHA1_SHA2/hashSum.hpp Test: test/hashFnc_of_MD5_SHA1_SHA2/hashSum.hpp (Not implemented yet)","title":"hashSum"},{"location":"src/hashFunction/hashSum.html#hashsum","text":"","title":"hashSum"},{"location":"src/hashFunction/hashSum.html#abstract","text":"Functions compatible with the hashSum commands. \u30cf\u30c3\u30b7\u30e5\u5024\u3092\u8a08\u7b97\u3059\u308b\u30b3\u30de\u30f3\u30c9\u306e\u4e92\u63db\u95a2\u6570\u3067\u3059\uff0e","title":"Abstract"},{"location":"src/hashFunction/hashSum.html#header-file","text":"namespace sstd { std :: string vecUint8_to_hexString ( const std :: vector < uint8 >& hash ); std :: string md5sum ( const char * pPath ); std :: string sha1sum ( const char * pPath ); std :: string sha224sum ( const char * pPath ); std :: string sha256sum ( const char * pPath ); std :: string sha384sum ( const char * pPath ); std :: string sha512sum ( const char * pPath ); std :: string md5sum ( const std :: string & path ); std :: string sha1sum ( const std :: string & path ); std :: string sha224sum ( const std :: string & path ); std :: string sha256sum ( const std :: string & path ); std :: string sha384sum ( const std :: string & path ); std :: string sha512sum ( const std :: string & path ); }","title":"Header file"},{"location":"src/hashFunction/hashSum.html#description","text":"Function name Description vecUint8_to_hexString() converts the input binary to to a hexadecimal string. \u5165\u529b\u3055\u308c\u305f\u30d0\u30a4\u30ca\u30ea\u3092\uff0c16 \u9032\u6570\u8868\u8a18\u306e\u6587\u5b57\u5217\u306b\u5909\u63db\u3057\u307e\u3059\uff0e md5sum() returns the result of md5sum calculation as a string. And returns 0 length std::string object when the md5sum() function failed. md5sum \u306e\u8a08\u7b97\u7d50\u679c\u3092\u6587\u5b57\u5217\u3067\u8fd4\u3057\u307e\u3059\uff0e\u95a2\u6570\u304c\u5931\u6557\u3057\u305f\u5834\u5408\u306f\uff0c\u9577\u3055 0 \u306e std::string \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u8fd4\u5374\u3057\u307e\u3059\uff0e sha1sum() returns the result of sha1sum calculation as a string. And returns 0 length std::string object when the sha1sum() function failed. sha1sum \u306e\u8a08\u7b97\u7d50\u679c\u3092\u6587\u5b57\u5217\u3067\u8fd4\u3057\u307e\u3059\uff0e\u95a2\u6570\u304c\u5931\u6557\u3057\u305f\u5834\u5408\u306f\uff0c\u9577\u3055 0 \u306e std::string \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u8fd4\u5374\u3057\u307e\u3059\uff0e sha224sum() returns the result of sha224sum calculation as a string. And returns 0 length std::string object when the sha224sum() function failed. sha224sum \u306e\u8a08\u7b97\u7d50\u679c\u3092\u6587\u5b57\u5217\u3067\u8fd4\u3057\u307e\u3059\uff0e\u95a2\u6570\u304c\u5931\u6557\u3057\u305f\u5834\u5408\u306f\uff0c\u9577\u3055 0 \u306e std::string \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u8fd4\u5374\u3057\u307e\u3059\uff0e sha256sum() returns the result of sha256sum calculation as a string. And returns 0 length std::string object when the sha256sum() function failed. sha256sum \u306e\u8a08\u7b97\u7d50\u679c\u3092\u6587\u5b57\u5217\u3067\u8fd4\u3057\u307e\u3059\uff0e\u95a2\u6570\u304c\u5931\u6557\u3057\u305f\u5834\u5408\u306f\uff0c\u9577\u3055 0 \u306e std::string \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u8fd4\u5374\u3057\u307e\u3059\uff0e sha384sum() returns the result of sha384sum calculation as a string. And returns 0 length std::string object when the sha384sum() function failed. sha384sum \u306e\u8a08\u7b97\u7d50\u679c\u3092\u6587\u5b57\u5217\u3067\u8fd4\u3057\u307e\u3059\uff0e\u95a2\u6570\u304c\u5931\u6557\u3057\u305f\u5834\u5408\u306f\uff0c\u9577\u3055 0 \u306e std::string \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u8fd4\u5374\u3057\u307e\u3059\uff0e sha512sum() returns the result of sha512sum calculation as a string. And returns 0 length std::string object when the sha512sum() function failed. sha512sum \u306e\u8a08\u7b97\u7d50\u679c\u3092\u6587\u5b57\u5217\u3067\u8fd4\u3057\u307e\u3059\uff0e\u95a2\u6570\u304c\u5931\u6557\u3057\u305f\u5834\u5408\u306f\uff0c\u9577\u3055 0 \u306e std::string \u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u8fd4\u5374\u3057\u307e\u3059\uff0e","title":"Description"},{"location":"src/hashFunction/hashSum.html#usage","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"head -c 5m /dev/urandom > ./tmp/rand.bin\" ); // generate 5 MB random file sstd :: printn ( sstd :: sha256sum ( \"./tmp/rand.bin\" ) ); printf ( \" \\n \" ); fflush ( stdout ); sstd :: system ( \"sha256sum ./tmp/rand.bin\" ); sstd :: rm ( \"./tmp\" ); } Execution result sstd::sha256sum(\"./tmp/rand.bin\") = \"f5863a6d9a95fa165bc4b43115646511f89610ff5f3ca7026612aee7ca03d923\" f5863a6d9a95fa165bc4b43115646511f89610ff5f3ca7026612aee7ca03d923 ./tmp/rand.bin","title":"Usage"},{"location":"src/hashFunction/hashSum.html#implementation","text":"Source: sstd/src/hashFnc_of_MD5_SHA1_SHA2/hashSum.cpp Header: sstd/src/hashFnc_of_MD5_SHA1_SHA2/hashSum.hpp Test: test/hashFnc_of_MD5_SHA1_SHA2/hashSum.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/hashFunction/md5.html","text":"MD5 Abstract md5() calculate MD5 cryptographic hash function. md5() \u306f\u6697\u53f7\u5b66\u7684\u30cf\u30c3\u30b7\u30e5\u95a2\u6570\u3067\u3042\u308b MD5 \u3092\u8a08\u7b97\u3057\u307e\u3059\uff0e Header file namespace sstd { std :: vector < uint8 > md5 ( const uchar * in , size_t in_len ); std :: vector < uint8 > md5 ( const std :: vector < uint8 >& in ); } Usage main.cpp #include <sstd/sstd.hpp> std :: string uint8_to_str ( const std :: vector < uint8 >& v ){ std :: string s ; for ( uint i = 0 ; i < v . size (); ++ i ){ s += sstd :: ssprintf ( \"%02x\" , ( int ) v [ i ]); } return s ; } int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"head -c 5m /dev/urandom > ./tmp/rand.txt\" ); // generate 5 MB random file sstd :: system ( \"md5sum ./tmp/rand.txt\" ); std :: vector < uint8 > vBin = sstd :: read_bin ( \"./tmp/rand.txt\" ); // read all as a binary std :: string md5_str = uint8_to_str ( sstd :: md5 ( vBin ) ); sstd :: printn ( md5_str ); sstd :: rm ( \"./tmp\" ); } Execution result 0d9c16dd58bbc8f7fd7b59c90ec786ca ./tmp/rand.txt md5_str = \"0d9c16dd58bbc8f7fd7b59c90ec786ca\" Implementation Source: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.cpp Header: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp Test: test/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp (Not implemented yet)","title":"MD5"},{"location":"src/hashFunction/md5.html#md5","text":"","title":"MD5"},{"location":"src/hashFunction/md5.html#abstract","text":"md5() calculate MD5 cryptographic hash function. md5() \u306f\u6697\u53f7\u5b66\u7684\u30cf\u30c3\u30b7\u30e5\u95a2\u6570\u3067\u3042\u308b MD5 \u3092\u8a08\u7b97\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/hashFunction/md5.html#header-file","text":"namespace sstd { std :: vector < uint8 > md5 ( const uchar * in , size_t in_len ); std :: vector < uint8 > md5 ( const std :: vector < uint8 >& in ); }","title":"Header file"},{"location":"src/hashFunction/md5.html#usage","text":"main.cpp #include <sstd/sstd.hpp> std :: string uint8_to_str ( const std :: vector < uint8 >& v ){ std :: string s ; for ( uint i = 0 ; i < v . size (); ++ i ){ s += sstd :: ssprintf ( \"%02x\" , ( int ) v [ i ]); } return s ; } int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"head -c 5m /dev/urandom > ./tmp/rand.txt\" ); // generate 5 MB random file sstd :: system ( \"md5sum ./tmp/rand.txt\" ); std :: vector < uint8 > vBin = sstd :: read_bin ( \"./tmp/rand.txt\" ); // read all as a binary std :: string md5_str = uint8_to_str ( sstd :: md5 ( vBin ) ); sstd :: printn ( md5_str ); sstd :: rm ( \"./tmp\" ); } Execution result 0d9c16dd58bbc8f7fd7b59c90ec786ca ./tmp/rand.txt md5_str = \"0d9c16dd58bbc8f7fd7b59c90ec786ca\"","title":"Usage"},{"location":"src/hashFunction/md5.html#implementation","text":"Source: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.cpp Header: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp Test: test/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/hashFunction/sha1.html","text":"SHA-1 Abstract sha1() calculate SHA-1 cryptographic hash function. sha1() \u306f\u6697\u53f7\u5b66\u7684\u30cf\u30c3\u30b7\u30e5\u95a2\u6570\u3067\u3042\u308b SHA-1 \u3092\u8a08\u7b97\u3057\u307e\u3059\uff0e Header file namespace sstd { std :: vector < uint8 > sha1 ( const uchar * in , size_t in_len ); std :: vector < uint8 > sha1 ( const std :: vector < uint8 >& in ); } Usage main.cpp #include <sstd/sstd.hpp> std :: string uint8_to_str ( const std :: vector < uint8 >& v ){ std :: string s ; for ( uint i = 0 ; i < v . size (); ++ i ){ s += sstd :: ssprintf ( \"%02x\" , ( int ) v [ i ]); } return s ; } int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"head -c 5m /dev/urandom > ./tmp/rand.txt\" ); // generate 5 MB random file sstd :: system ( \"sha1sum ./tmp/rand.txt\" ); std :: vector < uint8 > vBin = sstd :: read_bin ( \"./tmp/rand.txt\" ); // read all as a binary std :: string md5_str = uint8_to_str ( sstd :: sha1 ( vBin ) ); sstd :: printn ( md5_str ); sstd :: rm ( \"./tmp\" ); } Execution result 2926e0fbf0b24dbf8684beb9ece83917338ab263 ./tmp/rand.txt md5_str = \"2926e0fbf0b24dbf8684beb9ece83917338ab263\" Implementation Source: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.cpp Header: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp Test: test/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp (Not implemented yet)","title":"SHA-1"},{"location":"src/hashFunction/sha1.html#sha-1","text":"","title":"SHA-1"},{"location":"src/hashFunction/sha1.html#abstract","text":"sha1() calculate SHA-1 cryptographic hash function. sha1() \u306f\u6697\u53f7\u5b66\u7684\u30cf\u30c3\u30b7\u30e5\u95a2\u6570\u3067\u3042\u308b SHA-1 \u3092\u8a08\u7b97\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/hashFunction/sha1.html#header-file","text":"namespace sstd { std :: vector < uint8 > sha1 ( const uchar * in , size_t in_len ); std :: vector < uint8 > sha1 ( const std :: vector < uint8 >& in ); }","title":"Header file"},{"location":"src/hashFunction/sha1.html#usage","text":"main.cpp #include <sstd/sstd.hpp> std :: string uint8_to_str ( const std :: vector < uint8 >& v ){ std :: string s ; for ( uint i = 0 ; i < v . size (); ++ i ){ s += sstd :: ssprintf ( \"%02x\" , ( int ) v [ i ]); } return s ; } int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"head -c 5m /dev/urandom > ./tmp/rand.txt\" ); // generate 5 MB random file sstd :: system ( \"sha1sum ./tmp/rand.txt\" ); std :: vector < uint8 > vBin = sstd :: read_bin ( \"./tmp/rand.txt\" ); // read all as a binary std :: string md5_str = uint8_to_str ( sstd :: sha1 ( vBin ) ); sstd :: printn ( md5_str ); sstd :: rm ( \"./tmp\" ); } Execution result 2926e0fbf0b24dbf8684beb9ece83917338ab263 ./tmp/rand.txt md5_str = \"2926e0fbf0b24dbf8684beb9ece83917338ab263\"","title":"Usage"},{"location":"src/hashFunction/sha1.html#implementation","text":"Source: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.cpp Header: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp Test: test/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/hashFunction/sha2.html","text":"SHA-2 (224, 256, 384, 512 bits) Abstract sha224() , sha256() , sha384() and sha512() calculate SHA-2 cryptographic hash function. sha224() , sha256() , sha384() \u304a\u3088\u3073 sha512() \u306f\u6697\u53f7\u5b66\u7684\u30cf\u30c3\u30b7\u30e5\u95a2\u6570\u3067\u3042\u308b SHA-2 \u3092\u8a08\u7b97\u3057\u307e\u3059\uff0e Header file namespace sstd { std :: vector < uint8 > sha224 ( const uchar * in , size_t in_len ); std :: vector < uint8 > sha256 ( const uchar * in , size_t in_len ); std :: vector < uint8 > sha384 ( const uchar * in , size_t in_len ); std :: vector < uint8 > sha512 ( const uchar * in , size_t in_len ); std :: vector < uint8 > sha224 ( const std :: vector < uint8 >& in ); std :: vector < uint8 > sha256 ( const std :: vector < uint8 >& in ); std :: vector < uint8 > sha384 ( const std :: vector < uint8 >& in ); std :: vector < uint8 > sha512 ( const std :: vector < uint8 >& in ); } Usage main.cpp #include <sstd/sstd.hpp> std :: string uint8_to_str ( const std :: vector < uint8 >& v ){ std :: string s ; for ( uint i = 0 ; i < v . size (); ++ i ){ s += sstd :: ssprintf ( \"%02x\" , ( int ) v [ i ]); } return s ; } int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"head -c 5m /dev/urandom > ./tmp/rand.txt\" ); // generate 5 MB random file sstd :: system ( \"sha224sum ./tmp/rand.txt\" ); std :: vector < uint8 > vBin = sstd :: read_bin ( \"./tmp/rand.txt\" ); // read all as a binary std :: string sha224_str = uint8_to_str ( sstd :: sha224 ( vBin ) ); sstd :: printn ( sha224_str ); sstd :: rm ( \"./tmp\" ); } Execution result sh: sha224sum: not found sha224_str = \"e893b4a3360a9115211b8cd8483a19c6406a5891ef5b27ce58d4b59a\" Implementation Source: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.cpp Header: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp Test: test/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp (Not implemented yet)","title":"SHA-2<br/>(224, 256, 384, 512 bits)"},{"location":"src/hashFunction/sha2.html#sha-2224-256-384-512-bits","text":"","title":"SHA-2(224, 256, 384, 512 bits)"},{"location":"src/hashFunction/sha2.html#abstract","text":"sha224() , sha256() , sha384() and sha512() calculate SHA-2 cryptographic hash function. sha224() , sha256() , sha384() \u304a\u3088\u3073 sha512() \u306f\u6697\u53f7\u5b66\u7684\u30cf\u30c3\u30b7\u30e5\u95a2\u6570\u3067\u3042\u308b SHA-2 \u3092\u8a08\u7b97\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/hashFunction/sha2.html#header-file","text":"namespace sstd { std :: vector < uint8 > sha224 ( const uchar * in , size_t in_len ); std :: vector < uint8 > sha256 ( const uchar * in , size_t in_len ); std :: vector < uint8 > sha384 ( const uchar * in , size_t in_len ); std :: vector < uint8 > sha512 ( const uchar * in , size_t in_len ); std :: vector < uint8 > sha224 ( const std :: vector < uint8 >& in ); std :: vector < uint8 > sha256 ( const std :: vector < uint8 >& in ); std :: vector < uint8 > sha384 ( const std :: vector < uint8 >& in ); std :: vector < uint8 > sha512 ( const std :: vector < uint8 >& in ); }","title":"Header file"},{"location":"src/hashFunction/sha2.html#usage","text":"main.cpp #include <sstd/sstd.hpp> std :: string uint8_to_str ( const std :: vector < uint8 >& v ){ std :: string s ; for ( uint i = 0 ; i < v . size (); ++ i ){ s += sstd :: ssprintf ( \"%02x\" , ( int ) v [ i ]); } return s ; } int main (){ sstd :: mkdir ( \"./tmp\" ); sstd :: system ( \"head -c 5m /dev/urandom > ./tmp/rand.txt\" ); // generate 5 MB random file sstd :: system ( \"sha224sum ./tmp/rand.txt\" ); std :: vector < uint8 > vBin = sstd :: read_bin ( \"./tmp/rand.txt\" ); // read all as a binary std :: string sha224_str = uint8_to_str ( sstd :: sha224 ( vBin ) ); sstd :: printn ( sha224_str ); sstd :: rm ( \"./tmp\" ); } Execution result sh: sha224sum: not found sha224_str = \"e893b4a3360a9115211b8cd8483a19c6406a5891ef5b27ce58d4b59a\"","title":"Usage"},{"location":"src/hashFunction/sha2.html#implementation","text":"Source: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.cpp Header: sstd/src/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp Test: test/hashFnc_of_MD5_SHA1_SHA2/sstd_md5_sha1_sha2_wrapper.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/matrix/bmat.html","text":"bmat (binary-matrix) Abstract bmat is a binary matrix calculation container. bmat \u306f\u30d0\u30a4\u30ca\u30ea\u884c\u5217\u8a08\u7b97\u30b3\u30f3\u30c6\u30ca\u3067\u3059\uff0e Header file namespace sstd { class bmat ; void copy ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); void move ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); void eye ( class sstd :: bmat & bMat ); void ones ( class sstd :: bmat & bMat ); void zeros ( class sstd :: bmat & bMat ); class sstd :: bmat eye ( const uint & row , const uint & col ); // \u3053\u306e\u3042\u305f\u308a\uff0c\u623b\u308a\u5024\u3067\u95a2\u6570\u306f\u30aa\u30fc\u30d0\u30fc\u30ed\u30fc\u30c9\u3067\u304d\u306a\u3044\u306e\u3067\uff0c\u4ed6\u306e\u578b\u306b\u3064\u3044\u3066\u3082\u5b9f\u88c5\u3059\u308b\u3068\uff0c\u885d\u7a81\u3059\u308b\u5371\u967a\u304c\u3042\u308b\uff0e(\u66f8\u304d\u76f4\u3057\uff0e class sstd :: bmat ones ( const uint & row , const uint & col ); class sstd :: bmat zeros ( const uint & row , const uint & col ); class sstd :: bmat eye ( const uint & size ); class sstd :: bmat ones ( const uint & size ); class sstd :: bmat zeros ( const uint & size ); class sstd :: bmat LxShiftMat ( uint size , uint xShift ); // square matrix [size x size] class sstd :: bmat RxShiftMat ( uint size , uint xShift ); // square matrix [size x size] class sstd :: bmat Tr ( class sstd :: bmat & rhs ); // lhs = Transpose(rhs) void Tr_myself ( class sstd :: bmat & rhs ); // Transpose(rhs) class sstd :: bmat add ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs + rhs (XOR) class sstd :: bmat mul ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs * rhs class sstd :: bmat pow ( class sstd :: bmat base , uint64 exponent ); // base^{exponent} void add_myself ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs += rhs (XOR) void mul_myself ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs *= rhs void pow_myself ( class sstd :: bmat & base , uint64 exponent ); // lhs ^= exponent class sstd :: bmat and_ ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs & rhs (AND) class sstd :: bmat or_ ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs | rhs (OR) class sstd :: bmat not_ ( class sstd :: bmat & rhs ); // ~rhs (NOT) class sstd :: bmat xor_ ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs + rhs (XOR) void and_myself ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs & rhs (AND) void or_myself ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs | rhs (OR) bool eq ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs == rhs bool ne ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs != rhs class sstd :: bmat REShift ( class sstd :: bmat & rhs , uint ShiftNum ); // RightExpansionShift // \u884c\u5217\u62e1\u5927\u53f3\u30b7\u30d5\u30c8 class sstd :: bmat DEShift ( class sstd :: bmat & rhs , uint ShiftNum ); // DownExpansionShift // \u884c\u5217\u62e1\u5927\u4e0b\u30b7\u30d5\u30c8 class sstd :: bmat horzcat2 ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs << rhs class sstd :: bmat vertcat2 ( class sstd :: bmat & us , class sstd :: bmat & ds ); // us && ds // upside, downside. }; class sstd :: bmat { private : uint rowNum ; // \u884c\u6570 uint colNum ; // \u5217\u6570 sstd :: mat_c < uint64 > binMat8x8 ; // 8x8 \u306e BinMartix \u884c\u5217\u306e\u96c6\u5408 public : bmat (); bmat ( const uint & row , const uint & col ); bmat ( class bmat & rhs ); bmat ( class bmat && rhs ); ~ bmat (){} // inline sstd::mat_c<uint64> bMat8x8(){ return binMat8x8; } // Do not do this to avoid object copy inline const sstd :: mat_c < uint64 >& bMat8x8_R () const { return binMat8x8 ; } inline const uint rows () const ; inline const uint cols () const ; // RW: read and write inline sstd :: mat_c < uint64 >& bMat8x8_RW (); inline uint & rows_RW (); inline uint & cols_RW (); class bmat & operator = ( const class bmat & rhs ); // called by \"lhs = sstd::add(A, B);\". class bmat operator + ( const class bmat & rhs ); // called by \"lhs + rhs;\". // XOR class bmat operator * ( const class bmat & rhs ); // called by \"lhs * rhs;\". // mul class bmat operator ^ ( const uint64 & rhs ); // called by \"lhs ^ rhs;\". // pow (not XOR) class bmat operator & ( const class bmat & rhs ); // called by \"lhs & rhs;\". // AND class bmat operator | ( const class bmat & rhs ); // called by \"lhs | rhs;\". // OR class bmat operator ~ () // called by \"~rhs;\". // NOT class bmat & operator += ( const class bmat & rhs ); // called by \"lhs += rhs;\". class bmat & operator *= ( const class bmat & rhs ); // called by \"lhs *= rhs;\". class bmat & operator ^= ( const uint64 & rhs ); // called by \"lhs ^= rhs;\". class bmat & operator &= ( const class bmat & rhs ); // called by \"lhs &= rhs;\". class bmat & operator |= ( const class bmat & rhs ); // called by \"lhs |= rhs;\". bool operator == ( const class bmat & rhs ); // called by \"sstd::bmat bMatA, bMatB; if(bMatA == bMatB){printf(\"same\\n\");}else{printf(\"different\\n\");}\". bool operator != ( const class bmat & rhs ); // called by \"sstd::bmat bMatA, bMatB; if(bMatA == bMatB){printf(\"same\\n\");}else{printf(\"different\\n\");}\". class bmat operator << ( const class bmat & rhs ); // called by \"sstd::bmat bMatA, bMatB, bMatC; bMatC = bMatA << bMatB;\". // Horizontal connection of matrix. class bmat operator && ( const class bmat & ds ); // called by \"sstd::bmat bMatA, bMatB, bMatC; bMatC = bMatA && bMatB;\". // Vertical connection of matrix. class SwapByOneIndex operator []( const uint & p ); // col-major order // called by \"sstd::bmat bMat; bool buf = bMat[0]; bool bMat[0] = buf;\". class SwapByOneIndex operator []( const int & p ); // col-major order // called by \"sstd::bmat bMat; bool buf = bMat[0]; bool bMat[0] = buf;\". class SwapByTwoIndex operator ()( const uint & p , const uint & q ); // called by \"sstd::bmat bMat; bool buf = bMat(0, 0); bool bMat(0, 0) = buf;\". class SwapByTwoIndex operator ()( const int & p , const uint & q ); // called by \"sstd::bmat bMat; bool buf = bMat(0, 0); bool bMat(0, 0) = buf;\". class SwapByTwoIndex operator ()( const uint & p , const int & q ); // called by \"sstd::bmat bMat; bool buf = bMat(0, 0); bool bMat(0, 0) = buf;\". class SwapByTwoIndex operator ()( const int & p , const int & q ); // called by \"sstd::bmat bMat; bool buf = bMat(0, 0); bool bMat(0, 0) = buf;\". }; Usage Execution result #include <sstd/sstd.hpp> bool isFullPeriod_LRL ( std :: vector < uint64 >& divs , uint N , uint a , uint b , uint c ){ sstd :: bmat I = sstd :: eye ( N , N ); sstd :: bmat La = sstd :: LxShiftMat ( N , a ); sstd :: bmat Rb = sstd :: RxShiftMat ( N , b ); sstd :: bmat Lc = sstd :: LxShiftMat ( N , c ); sstd :: bmat T = ( I + La ) * ( I + Rb ) * ( I + Lc ); // sstd::printn(T); for ( uint i = 0 ; i < divs . size () -1 ; i ++ ){ sstd :: bmat Tp = T ^ ( divs [ i ]); // XORSHIFT if ( Tp == I ){ return false ; } } sstd :: bmat Tp = T ^ ( divs [ divs . size () -1 ]); // XORSHIFT if ( Tp == I ){ return true ; } else { return false ; } } void T_LRL ( std :: vector < uint64 >& divs , uint N ){ uint num = 0 ; printf ( \" a, b, c \\n \" ); for ( uint a = 0 ; a < N ; a ++ ){ for ( uint b = 0 ; b < N ; b ++ ){ for ( uint c = 0 ; c < N ; c ++ ){ if ( a < c && isFullPeriod_LRL ( divs , N , a , b , c )){ printf ( \"|%2u, %2u, %2u\" , a , b , c ); num ++ ; if ( num % 9 == 0 ){ printf ( \"| \\n \" ); } } } } } } int main (){ printf ( \"\u25a0 measureTime_start--------------- \\n\\n \" ); time_m timem ; sstd :: measureTime_start ( timem ); // calculate divisors of 2^32-1. // std::vector<uint64> divs32 = sstd::divisor(4294967296-1); // Below line returns the same result of this line, but took a little time to run every time and takes a little heavy memory (about 2 GByte). // std::vector<uint64> divs32 = {1, 3, 5, 15, 17, 51, 85, 255, 257, 771, 1285, 3855, 4369, 13107, 21845, 65535, 65537, 196611, 327685, 983055, 1114129, 3342387, 5570645, 16711935, 16843009, 50529027, 84215045, 252645135, 286331153, 858993459, 1431655765, 4294967295}; std :: vector < uint64 > divs32 = { 1ull * 5ull * 17ull * 257ull * 65537ull , 3ull * 1ull * 17ull * 257ull * 65537ull , 3ull * 5ull * 1ull * 257ull * 65537ull , 3ull * 5ull * 17ull * 1ull * 65537ull , 3ull * 5ull * 17ull * 257ull * 1ull , 3ull * 5ull * 17ull * 257ull * 65537ull }; printf ( \"\u25a1 calculate LRL 32bits \\n \" ); T_LRL ( divs32 , 32 ); printf ( \" \\n \" ); printf ( \" \\n \u25a0 measureTime_stop---------------- \\n \" ); sstd :: measureTime_stop_print ( timem ); return 0 ; } Execution result \u25a0 measureTime_start--------------- \u25a1 calculate LRL 32bits a, b, c | 1, 3, 10| 1, 5, 16| 1, 5, 19| 1, 9, 29| 1, 11, 6| 1, 11, 16| 1, 19, 3| 1, 21, 20| 1, 27, 27| | 2, 5, 15| 2, 5, 21| 2, 7, 7| 2, 7, 9| 2, 7, 25| 2, 9, 15| 2, 15, 17| 2, 15, 25| 2, 21, 9| | 3, 1, 14| 3, 3, 26| 3, 3, 28| 3, 3, 29| 3, 5, 20| 3, 5, 22| 3, 5, 25| 3, 7, 29| 3, 13, 7| | 3, 23, 25| 3, 25, 24| 3, 27, 11| 4, 3, 17| 4, 3, 27| 4, 5, 15| 5, 3, 21| 5, 7, 22| 5, 9, 7| | 5, 9, 28| 5, 9, 31| 5, 13, 6| 5, 15, 17| 5, 17, 13| 5, 21, 12| 5, 27, 8| 5, 27, 21| 5, 27, 25| | 5, 27, 28| 6, 1, 11| 6, 3, 17| 6, 17, 9| 6, 21, 7| 6, 21, 13| 7, 1, 9| 7, 1, 18| 7, 1, 25| | 7, 13, 25| 7, 17, 21| 7, 25, 12| 7, 25, 20| 8, 7, 23| 8, 9, 23| 9, 5, 14| 9, 5, 25| 9, 11, 19| | 9, 21, 16|10, 9, 21|10, 9, 25|11, 7, 12|11, 7, 16|11, 17, 13|11, 21, 13|12, 9, 23|13, 3, 17| |13, 3, 27|13, 5, 19|13, 17, 15|14, 1, 15|14, 13, 15|15, 1, 29|17, 15, 20|17, 15, 23|17, 15, 26| \u25a0 measureTime_stop---------------- -------------------------------- Execution time: 2. 952 sec -------------------------------- Implementation Source: sstd/src/matrixContainer_binary/bmat.cpp Header: sstd/src/matrixContainer_binary/bmat.hpp Test: test/bmat.hpp (Not implemented yet)","title":"bmat (binary-matrix)"},{"location":"src/matrix/bmat.html#bmat-binary-matrix","text":"","title":"bmat (binary-matrix)"},{"location":"src/matrix/bmat.html#abstract","text":"bmat is a binary matrix calculation container. bmat \u306f\u30d0\u30a4\u30ca\u30ea\u884c\u5217\u8a08\u7b97\u30b3\u30f3\u30c6\u30ca\u3067\u3059\uff0e","title":"Abstract"},{"location":"src/matrix/bmat.html#header-file","text":"namespace sstd { class bmat ; void copy ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); void move ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); void eye ( class sstd :: bmat & bMat ); void ones ( class sstd :: bmat & bMat ); void zeros ( class sstd :: bmat & bMat ); class sstd :: bmat eye ( const uint & row , const uint & col ); // \u3053\u306e\u3042\u305f\u308a\uff0c\u623b\u308a\u5024\u3067\u95a2\u6570\u306f\u30aa\u30fc\u30d0\u30fc\u30ed\u30fc\u30c9\u3067\u304d\u306a\u3044\u306e\u3067\uff0c\u4ed6\u306e\u578b\u306b\u3064\u3044\u3066\u3082\u5b9f\u88c5\u3059\u308b\u3068\uff0c\u885d\u7a81\u3059\u308b\u5371\u967a\u304c\u3042\u308b\uff0e(\u66f8\u304d\u76f4\u3057\uff0e class sstd :: bmat ones ( const uint & row , const uint & col ); class sstd :: bmat zeros ( const uint & row , const uint & col ); class sstd :: bmat eye ( const uint & size ); class sstd :: bmat ones ( const uint & size ); class sstd :: bmat zeros ( const uint & size ); class sstd :: bmat LxShiftMat ( uint size , uint xShift ); // square matrix [size x size] class sstd :: bmat RxShiftMat ( uint size , uint xShift ); // square matrix [size x size] class sstd :: bmat Tr ( class sstd :: bmat & rhs ); // lhs = Transpose(rhs) void Tr_myself ( class sstd :: bmat & rhs ); // Transpose(rhs) class sstd :: bmat add ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs + rhs (XOR) class sstd :: bmat mul ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs * rhs class sstd :: bmat pow ( class sstd :: bmat base , uint64 exponent ); // base^{exponent} void add_myself ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs += rhs (XOR) void mul_myself ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs *= rhs void pow_myself ( class sstd :: bmat & base , uint64 exponent ); // lhs ^= exponent class sstd :: bmat and_ ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs & rhs (AND) class sstd :: bmat or_ ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs | rhs (OR) class sstd :: bmat not_ ( class sstd :: bmat & rhs ); // ~rhs (NOT) class sstd :: bmat xor_ ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs + rhs (XOR) void and_myself ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs & rhs (AND) void or_myself ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs | rhs (OR) bool eq ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs == rhs bool ne ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs != rhs class sstd :: bmat REShift ( class sstd :: bmat & rhs , uint ShiftNum ); // RightExpansionShift // \u884c\u5217\u62e1\u5927\u53f3\u30b7\u30d5\u30c8 class sstd :: bmat DEShift ( class sstd :: bmat & rhs , uint ShiftNum ); // DownExpansionShift // \u884c\u5217\u62e1\u5927\u4e0b\u30b7\u30d5\u30c8 class sstd :: bmat horzcat2 ( class sstd :: bmat & lhs , class sstd :: bmat & rhs ); // lhs << rhs class sstd :: bmat vertcat2 ( class sstd :: bmat & us , class sstd :: bmat & ds ); // us && ds // upside, downside. }; class sstd :: bmat { private : uint rowNum ; // \u884c\u6570 uint colNum ; // \u5217\u6570 sstd :: mat_c < uint64 > binMat8x8 ; // 8x8 \u306e BinMartix \u884c\u5217\u306e\u96c6\u5408 public : bmat (); bmat ( const uint & row , const uint & col ); bmat ( class bmat & rhs ); bmat ( class bmat && rhs ); ~ bmat (){} // inline sstd::mat_c<uint64> bMat8x8(){ return binMat8x8; } // Do not do this to avoid object copy inline const sstd :: mat_c < uint64 >& bMat8x8_R () const { return binMat8x8 ; } inline const uint rows () const ; inline const uint cols () const ; // RW: read and write inline sstd :: mat_c < uint64 >& bMat8x8_RW (); inline uint & rows_RW (); inline uint & cols_RW (); class bmat & operator = ( const class bmat & rhs ); // called by \"lhs = sstd::add(A, B);\". class bmat operator + ( const class bmat & rhs ); // called by \"lhs + rhs;\". // XOR class bmat operator * ( const class bmat & rhs ); // called by \"lhs * rhs;\". // mul class bmat operator ^ ( const uint64 & rhs ); // called by \"lhs ^ rhs;\". // pow (not XOR) class bmat operator & ( const class bmat & rhs ); // called by \"lhs & rhs;\". // AND class bmat operator | ( const class bmat & rhs ); // called by \"lhs | rhs;\". // OR class bmat operator ~ () // called by \"~rhs;\". // NOT class bmat & operator += ( const class bmat & rhs ); // called by \"lhs += rhs;\". class bmat & operator *= ( const class bmat & rhs ); // called by \"lhs *= rhs;\". class bmat & operator ^= ( const uint64 & rhs ); // called by \"lhs ^= rhs;\". class bmat & operator &= ( const class bmat & rhs ); // called by \"lhs &= rhs;\". class bmat & operator |= ( const class bmat & rhs ); // called by \"lhs |= rhs;\". bool operator == ( const class bmat & rhs ); // called by \"sstd::bmat bMatA, bMatB; if(bMatA == bMatB){printf(\"same\\n\");}else{printf(\"different\\n\");}\". bool operator != ( const class bmat & rhs ); // called by \"sstd::bmat bMatA, bMatB; if(bMatA == bMatB){printf(\"same\\n\");}else{printf(\"different\\n\");}\". class bmat operator << ( const class bmat & rhs ); // called by \"sstd::bmat bMatA, bMatB, bMatC; bMatC = bMatA << bMatB;\". // Horizontal connection of matrix. class bmat operator && ( const class bmat & ds ); // called by \"sstd::bmat bMatA, bMatB, bMatC; bMatC = bMatA && bMatB;\". // Vertical connection of matrix. class SwapByOneIndex operator []( const uint & p ); // col-major order // called by \"sstd::bmat bMat; bool buf = bMat[0]; bool bMat[0] = buf;\". class SwapByOneIndex operator []( const int & p ); // col-major order // called by \"sstd::bmat bMat; bool buf = bMat[0]; bool bMat[0] = buf;\". class SwapByTwoIndex operator ()( const uint & p , const uint & q ); // called by \"sstd::bmat bMat; bool buf = bMat(0, 0); bool bMat(0, 0) = buf;\". class SwapByTwoIndex operator ()( const int & p , const uint & q ); // called by \"sstd::bmat bMat; bool buf = bMat(0, 0); bool bMat(0, 0) = buf;\". class SwapByTwoIndex operator ()( const uint & p , const int & q ); // called by \"sstd::bmat bMat; bool buf = bMat(0, 0); bool bMat(0, 0) = buf;\". class SwapByTwoIndex operator ()( const int & p , const int & q ); // called by \"sstd::bmat bMat; bool buf = bMat(0, 0); bool bMat(0, 0) = buf;\". };","title":"Header file"},{"location":"src/matrix/bmat.html#usage","text":"Execution result #include <sstd/sstd.hpp> bool isFullPeriod_LRL ( std :: vector < uint64 >& divs , uint N , uint a , uint b , uint c ){ sstd :: bmat I = sstd :: eye ( N , N ); sstd :: bmat La = sstd :: LxShiftMat ( N , a ); sstd :: bmat Rb = sstd :: RxShiftMat ( N , b ); sstd :: bmat Lc = sstd :: LxShiftMat ( N , c ); sstd :: bmat T = ( I + La ) * ( I + Rb ) * ( I + Lc ); // sstd::printn(T); for ( uint i = 0 ; i < divs . size () -1 ; i ++ ){ sstd :: bmat Tp = T ^ ( divs [ i ]); // XORSHIFT if ( Tp == I ){ return false ; } } sstd :: bmat Tp = T ^ ( divs [ divs . size () -1 ]); // XORSHIFT if ( Tp == I ){ return true ; } else { return false ; } } void T_LRL ( std :: vector < uint64 >& divs , uint N ){ uint num = 0 ; printf ( \" a, b, c \\n \" ); for ( uint a = 0 ; a < N ; a ++ ){ for ( uint b = 0 ; b < N ; b ++ ){ for ( uint c = 0 ; c < N ; c ++ ){ if ( a < c && isFullPeriod_LRL ( divs , N , a , b , c )){ printf ( \"|%2u, %2u, %2u\" , a , b , c ); num ++ ; if ( num % 9 == 0 ){ printf ( \"| \\n \" ); } } } } } } int main (){ printf ( \"\u25a0 measureTime_start--------------- \\n\\n \" ); time_m timem ; sstd :: measureTime_start ( timem ); // calculate divisors of 2^32-1. // std::vector<uint64> divs32 = sstd::divisor(4294967296-1); // Below line returns the same result of this line, but took a little time to run every time and takes a little heavy memory (about 2 GByte). // std::vector<uint64> divs32 = {1, 3, 5, 15, 17, 51, 85, 255, 257, 771, 1285, 3855, 4369, 13107, 21845, 65535, 65537, 196611, 327685, 983055, 1114129, 3342387, 5570645, 16711935, 16843009, 50529027, 84215045, 252645135, 286331153, 858993459, 1431655765, 4294967295}; std :: vector < uint64 > divs32 = { 1ull * 5ull * 17ull * 257ull * 65537ull , 3ull * 1ull * 17ull * 257ull * 65537ull , 3ull * 5ull * 1ull * 257ull * 65537ull , 3ull * 5ull * 17ull * 1ull * 65537ull , 3ull * 5ull * 17ull * 257ull * 1ull , 3ull * 5ull * 17ull * 257ull * 65537ull }; printf ( \"\u25a1 calculate LRL 32bits \\n \" ); T_LRL ( divs32 , 32 ); printf ( \" \\n \" ); printf ( \" \\n \u25a0 measureTime_stop---------------- \\n \" ); sstd :: measureTime_stop_print ( timem ); return 0 ; } Execution result \u25a0 measureTime_start--------------- \u25a1 calculate LRL 32bits a, b, c | 1, 3, 10| 1, 5, 16| 1, 5, 19| 1, 9, 29| 1, 11, 6| 1, 11, 16| 1, 19, 3| 1, 21, 20| 1, 27, 27| | 2, 5, 15| 2, 5, 21| 2, 7, 7| 2, 7, 9| 2, 7, 25| 2, 9, 15| 2, 15, 17| 2, 15, 25| 2, 21, 9| | 3, 1, 14| 3, 3, 26| 3, 3, 28| 3, 3, 29| 3, 5, 20| 3, 5, 22| 3, 5, 25| 3, 7, 29| 3, 13, 7| | 3, 23, 25| 3, 25, 24| 3, 27, 11| 4, 3, 17| 4, 3, 27| 4, 5, 15| 5, 3, 21| 5, 7, 22| 5, 9, 7| | 5, 9, 28| 5, 9, 31| 5, 13, 6| 5, 15, 17| 5, 17, 13| 5, 21, 12| 5, 27, 8| 5, 27, 21| 5, 27, 25| | 5, 27, 28| 6, 1, 11| 6, 3, 17| 6, 17, 9| 6, 21, 7| 6, 21, 13| 7, 1, 9| 7, 1, 18| 7, 1, 25| | 7, 13, 25| 7, 17, 21| 7, 25, 12| 7, 25, 20| 8, 7, 23| 8, 9, 23| 9, 5, 14| 9, 5, 25| 9, 11, 19| | 9, 21, 16|10, 9, 21|10, 9, 25|11, 7, 12|11, 7, 16|11, 17, 13|11, 21, 13|12, 9, 23|13, 3, 17| |13, 3, 27|13, 5, 19|13, 17, 15|14, 1, 15|14, 13, 15|15, 1, 29|17, 15, 20|17, 15, 23|17, 15, 26| \u25a0 measureTime_stop---------------- -------------------------------- Execution time: 2. 952 sec --------------------------------","title":"Usage"},{"location":"src/matrix/bmat.html#implementation","text":"Source: sstd/src/matrixContainer_binary/bmat.cpp Header: sstd/src/matrixContainer_binary/bmat.hpp Test: test/bmat.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/matrix/mat_colMajor.html","text":"mat_c (Col-major) Abstract mat_c is a column-major matrix container. mat_c \u306f\u5217\u512a\u5148\u306e\u884c\u5217\u30b3\u30f3\u30c6\u30ca\u3067\u3059. Header file namespace sstd { template < typename T > class mat_c ; template < typename T > void copy ( sstd :: mat_c < T >& lhs , const sstd :: mat_c < T >& rhs ); template < typename T > void move ( sstd :: mat_c < T >& lhs , sstd :: mat_c < T >& rhs ); template < typename T > void swap ( sstd :: mat_c < T >& lhs , sstd :: mat_c < T >& rhs ); template < typename T > void eye ( sstd :: mat_c < T >& rhs ); template < typename T > void ones ( sstd :: mat_c < T >& rhs ); template < typename T > void zeros ( sstd :: mat_c < T >& Mat ); template < typename T > sstd :: mat_c < T > Tr ( const sstd :: mat_c < T >& rhs ); // lhs = Transpose(rhs) template < typename T > void Tr_myself ( sstd :: mat_c < T >& rhs ); // Transpose(rhs) } template < typename T > class sstd :: mat_c { private : T * _pMatT ; uint _rows ; // row size uint _cols ; // column size uint _size ; // number of element public : inline mat_c (); inline mat_c ( const std :: initializer_list < std :: initializer_list < T >>& rhs ); // called by \"sstd::mat_c<T> mat = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\". inline mat_c ( const class mat_c & rhs ); // called by \"sstd::mat_c<T> buf1(N, N); sstd::mat_c<T> buf2(buf1);\" inline mat_c ( class mat_c && rhs ); // called by \"return std::move(rhs);\" or \"std::swap(buf1, buf2)\". inline mat_c ( const uint & rowSize , const uint & colSize ); inline ~ mat_c (); // Read only: R inline const uint rows () const ; inline const uint cols () const ; inline const uint size () const ; // Read and Write: RW inline T *& pMatT_RW (); inline uint & rows_RW (); inline uint & cols_RW (); inline uint & size_RW (); class mat_c & operator = ( const class mat_c & rhs ); // called by \"lhs = sstd::mat_c<T>(3, 3);\". inline T & operator []( const uint i ); inline T & operator []( const int i ); inline const T & operator []( const uint i ) const ; inline const T & operator []( const int i ) const ; inline T & operator ()( const uint p , const uint q ); inline T & operator ()( const int p , const uint q ); inline T & operator ()( const uint p , const int q ); inline T & operator ()( const int p , const int q ); inline const T & operator ()( const uint p , const uint q ) const ; inline const T & operator ()( const int p , const uint q ) const ; inline const T & operator ()( const uint p , const int q ) const ; inline const T & operator ()( const int p , const int q ) const ; // for element operations (elements multiplication) inline sstd :: mat_c_elements < T > operator ()(); inline sstd :: mat_c_elements < T > vec (); }; Usage Init main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m = {{ 1 , 2 }, { 3 , 4 }}; sstd :: mat_c < double > m_eye ( 2 , 2 ); sstd :: eye ( m_eye ); sstd :: mat_c < double > m_ones ( 2 , 2 ); sstd :: ones ( m_ones ); sstd :: mat_c < double > m_zeros ( 2 , 2 ); sstd :: zeros ( m_zeros ); sstd :: printn ( m ); printf ( \" \\n \" ); sstd :: printn ( m_eye ); printf ( \" \\n \" ); sstd :: printn ( m_ones ); printf ( \" \\n \" ); sstd :: printn ( m_zeros ); } Execution result m = 1.000000 2.000000 3.000000 4.000000 m_eye = 1.000000 0.000000 0.000000 1.000000 m_ones = 1.000000 1.000000 1.000000 1.000000 m_zeros = 0.000000 0.000000 0.000000 0.000000 Access to elements As a matrix main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m ( 2 , 2 ); uint i = 0 ; for ( uint c = 0 ; c < m . cols (); ++ c ){ for ( uint r = 0 ; r < m . rows (); ++ r ){ m ( r , c ) = i ; ++ i ; } } sstd :: printn ( m ); } Execution result m = 0.000000 2.000000 1.000000 3.000000 As a vector main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m ( 2 , 2 ); for ( uint i = 0 ; i < m . size (); ++ i ){ m [ i ] = i ; } sstd :: printn ( m ); } Execution result m = 0.000000 2.000000 1.000000 3.000000 Tr (Transpose) main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m1 = {{ 1 , 2 }, { 3 , 4 }}; sstd :: printn ( m1 ); sstd :: printn ( sstd :: Tr ( m1 ) ); printf ( \" \\n \" ); sstd :: mat_c < double > m2 = {{ 1 , 2 }, { 3 , 4 }}; sstd :: printn ( m2 ); sstd :: Tr_myself ( m2 ); sstd :: printn ( m2 ); } Execution result m1 = 1.000000 2.000000 3.000000 4.000000 sstd::Tr( m1 ) = 1.000000 3.000000 2.000000 4.000000 m2 = 1.000000 2.000000 3.000000 4.000000 m2 = 1.000000 3.000000 2.000000 4.000000 Operator matrix \u00d7 scalar main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m ( 2 , 2 ); for ( uint i = 0 ; i < m . size (); ++ i ){ m [ i ] = i ; } sstd :: printn ( m ); printf ( \" \\n \" ); sstd :: printn ( m * 2 ); } Execution result m = 0.000000 2.000000 1.000000 3.000000 m * 2 = 0.000000 4.000000 2.000000 6.000000 matrix \u00d7 matrix main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m1 ( 2 , 2 ); for ( uint i = 0 ; i < m1 . size (); ++ i ){ m1 [ i ] = i ; } sstd :: mat_c < double > m2 ( 2 , 2 ); for ( uint i = 0 ; i < m2 . size (); ++ i ){ m2 [ i ] = i + 1 ; } sstd :: printn ( m1 ); printf ( \" \\n \" ); sstd :: printn ( m2 ); printf ( \" \\n \" ); sstd :: printn ( m1 * m2 ); } Execution result m1 = 0.000000 2.000000 1.000000 3.000000 m2 = 1.000000 3.000000 2.000000 4.000000 m1 * m2 = 4.000000 8.000000 7.000000 15.000000 matrix (as a vector) \u00d7 matrix (as a vector) main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m1 ( 2 , 2 ); for ( uint i = 0 ; i < m1 . size (); ++ i ){ m1 [ i ] = i ; } sstd :: mat_c < double > m2 ( 2 , 2 ); for ( uint i = 0 ; i < m2 . size (); ++ i ){ m2 [ i ] = i + 1 ; } sstd :: printn ( m1 ); printf ( \" \\n \" ); sstd :: printn ( m2 ); printf ( \" \\n \" ); sstd :: printn ( m1 () * m2 () ); } Execution result m1 = 0.000000 2.000000 1.000000 3.000000 m2 = 1.000000 3.000000 2.000000 4.000000 m1() * m2() = 0.000000 6.000000 2.000000 12.000000 Implementation Source: sstd/src/matrixContainer_rowMajor/mat_c.cpp Header: sstd/src/matrixContainer_rowMajor/mat_c.hpp Test: test/mat_c.hpp (Not implemented yet)","title":"mat_c (Col-major)"},{"location":"src/matrix/mat_colMajor.html#mat_c-col-major","text":"","title":"mat_c (Col-major)"},{"location":"src/matrix/mat_colMajor.html#abstract","text":"mat_c is a column-major matrix container. mat_c \u306f\u5217\u512a\u5148\u306e\u884c\u5217\u30b3\u30f3\u30c6\u30ca\u3067\u3059.","title":"Abstract"},{"location":"src/matrix/mat_colMajor.html#header-file","text":"namespace sstd { template < typename T > class mat_c ; template < typename T > void copy ( sstd :: mat_c < T >& lhs , const sstd :: mat_c < T >& rhs ); template < typename T > void move ( sstd :: mat_c < T >& lhs , sstd :: mat_c < T >& rhs ); template < typename T > void swap ( sstd :: mat_c < T >& lhs , sstd :: mat_c < T >& rhs ); template < typename T > void eye ( sstd :: mat_c < T >& rhs ); template < typename T > void ones ( sstd :: mat_c < T >& rhs ); template < typename T > void zeros ( sstd :: mat_c < T >& Mat ); template < typename T > sstd :: mat_c < T > Tr ( const sstd :: mat_c < T >& rhs ); // lhs = Transpose(rhs) template < typename T > void Tr_myself ( sstd :: mat_c < T >& rhs ); // Transpose(rhs) } template < typename T > class sstd :: mat_c { private : T * _pMatT ; uint _rows ; // row size uint _cols ; // column size uint _size ; // number of element public : inline mat_c (); inline mat_c ( const std :: initializer_list < std :: initializer_list < T >>& rhs ); // called by \"sstd::mat_c<T> mat = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\". inline mat_c ( const class mat_c & rhs ); // called by \"sstd::mat_c<T> buf1(N, N); sstd::mat_c<T> buf2(buf1);\" inline mat_c ( class mat_c && rhs ); // called by \"return std::move(rhs);\" or \"std::swap(buf1, buf2)\". inline mat_c ( const uint & rowSize , const uint & colSize ); inline ~ mat_c (); // Read only: R inline const uint rows () const ; inline const uint cols () const ; inline const uint size () const ; // Read and Write: RW inline T *& pMatT_RW (); inline uint & rows_RW (); inline uint & cols_RW (); inline uint & size_RW (); class mat_c & operator = ( const class mat_c & rhs ); // called by \"lhs = sstd::mat_c<T>(3, 3);\". inline T & operator []( const uint i ); inline T & operator []( const int i ); inline const T & operator []( const uint i ) const ; inline const T & operator []( const int i ) const ; inline T & operator ()( const uint p , const uint q ); inline T & operator ()( const int p , const uint q ); inline T & operator ()( const uint p , const int q ); inline T & operator ()( const int p , const int q ); inline const T & operator ()( const uint p , const uint q ) const ; inline const T & operator ()( const int p , const uint q ) const ; inline const T & operator ()( const uint p , const int q ) const ; inline const T & operator ()( const int p , const int q ) const ; // for element operations (elements multiplication) inline sstd :: mat_c_elements < T > operator ()(); inline sstd :: mat_c_elements < T > vec (); };","title":"Header file"},{"location":"src/matrix/mat_colMajor.html#usage","text":"","title":"Usage"},{"location":"src/matrix/mat_colMajor.html#init","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m = {{ 1 , 2 }, { 3 , 4 }}; sstd :: mat_c < double > m_eye ( 2 , 2 ); sstd :: eye ( m_eye ); sstd :: mat_c < double > m_ones ( 2 , 2 ); sstd :: ones ( m_ones ); sstd :: mat_c < double > m_zeros ( 2 , 2 ); sstd :: zeros ( m_zeros ); sstd :: printn ( m ); printf ( \" \\n \" ); sstd :: printn ( m_eye ); printf ( \" \\n \" ); sstd :: printn ( m_ones ); printf ( \" \\n \" ); sstd :: printn ( m_zeros ); } Execution result m = 1.000000 2.000000 3.000000 4.000000 m_eye = 1.000000 0.000000 0.000000 1.000000 m_ones = 1.000000 1.000000 1.000000 1.000000 m_zeros = 0.000000 0.000000 0.000000 0.000000","title":"Init"},{"location":"src/matrix/mat_colMajor.html#access-to-elements","text":"","title":"Access to elements"},{"location":"src/matrix/mat_colMajor.html#as-a-matrix","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m ( 2 , 2 ); uint i = 0 ; for ( uint c = 0 ; c < m . cols (); ++ c ){ for ( uint r = 0 ; r < m . rows (); ++ r ){ m ( r , c ) = i ; ++ i ; } } sstd :: printn ( m ); } Execution result m = 0.000000 2.000000 1.000000 3.000000","title":"As a matrix"},{"location":"src/matrix/mat_colMajor.html#as-a-vector","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m ( 2 , 2 ); for ( uint i = 0 ; i < m . size (); ++ i ){ m [ i ] = i ; } sstd :: printn ( m ); } Execution result m = 0.000000 2.000000 1.000000 3.000000","title":"As a vector"},{"location":"src/matrix/mat_colMajor.html#tr-transpose","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m1 = {{ 1 , 2 }, { 3 , 4 }}; sstd :: printn ( m1 ); sstd :: printn ( sstd :: Tr ( m1 ) ); printf ( \" \\n \" ); sstd :: mat_c < double > m2 = {{ 1 , 2 }, { 3 , 4 }}; sstd :: printn ( m2 ); sstd :: Tr_myself ( m2 ); sstd :: printn ( m2 ); } Execution result m1 = 1.000000 2.000000 3.000000 4.000000 sstd::Tr( m1 ) = 1.000000 3.000000 2.000000 4.000000 m2 = 1.000000 2.000000 3.000000 4.000000 m2 = 1.000000 3.000000 2.000000 4.000000","title":"Tr (Transpose)"},{"location":"src/matrix/mat_colMajor.html#operator","text":"","title":"Operator"},{"location":"src/matrix/mat_colMajor.html#matrix-scalar","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m ( 2 , 2 ); for ( uint i = 0 ; i < m . size (); ++ i ){ m [ i ] = i ; } sstd :: printn ( m ); printf ( \" \\n \" ); sstd :: printn ( m * 2 ); } Execution result m = 0.000000 2.000000 1.000000 3.000000 m * 2 = 0.000000 4.000000 2.000000 6.000000","title":"matrix \u00d7 scalar"},{"location":"src/matrix/mat_colMajor.html#matrix-matrix","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m1 ( 2 , 2 ); for ( uint i = 0 ; i < m1 . size (); ++ i ){ m1 [ i ] = i ; } sstd :: mat_c < double > m2 ( 2 , 2 ); for ( uint i = 0 ; i < m2 . size (); ++ i ){ m2 [ i ] = i + 1 ; } sstd :: printn ( m1 ); printf ( \" \\n \" ); sstd :: printn ( m2 ); printf ( \" \\n \" ); sstd :: printn ( m1 * m2 ); } Execution result m1 = 0.000000 2.000000 1.000000 3.000000 m2 = 1.000000 3.000000 2.000000 4.000000 m1 * m2 = 4.000000 8.000000 7.000000 15.000000","title":"matrix \u00d7 matrix"},{"location":"src/matrix/mat_colMajor.html#matrix-as-a-vector-matrix-as-a-vector","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_c < double > m1 ( 2 , 2 ); for ( uint i = 0 ; i < m1 . size (); ++ i ){ m1 [ i ] = i ; } sstd :: mat_c < double > m2 ( 2 , 2 ); for ( uint i = 0 ; i < m2 . size (); ++ i ){ m2 [ i ] = i + 1 ; } sstd :: printn ( m1 ); printf ( \" \\n \" ); sstd :: printn ( m2 ); printf ( \" \\n \" ); sstd :: printn ( m1 () * m2 () ); } Execution result m1 = 0.000000 2.000000 1.000000 3.000000 m2 = 1.000000 3.000000 2.000000 4.000000 m1() * m2() = 0.000000 6.000000 2.000000 12.000000","title":"matrix (as a vector) \u00d7 matrix (as a vector)"},{"location":"src/matrix/mat_colMajor.html#implementation","text":"Source: sstd/src/matrixContainer_rowMajor/mat_c.cpp Header: sstd/src/matrixContainer_rowMajor/mat_c.hpp Test: test/mat_c.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/matrix/mat_rowMajor.html","text":"mat_r (Row-major) Abstract mat_r is a row-major matrix container. mat_r \u306f\u884c\u512a\u5148\u306e\u884c\u5217\u30b3\u30f3\u30c6\u30ca\u3067\u3059. Header file namespace sstd { template < typename T > class mat_r ; template < typename T > void copy ( sstd :: mat_r < T >& lhs , const sstd :: mat_r < T >& rhs ); template < typename T > void move ( sstd :: mat_r < T >& lhs , sstd :: mat_r < T >& rhs ); template < typename T > void swap ( sstd :: mat_r < T >& lhs , sstd :: mat_r < T >& rhs ); template < typename T > void eye ( sstd :: mat_r < T >& rhs ); template < typename T > void ones ( sstd :: mat_r < T >& rhs ); template < typename T > void zeros ( sstd :: mat_r < T >& Mat ); template < typename T > sstd :: mat_r < T > Tr ( const sstd :: mat_r < T >& rhs ); // lhs = Transpose(rhs) template < typename T > void Tr_myself ( sstd :: mat_r < T >& rhs ); // Transpose(rhs) } template < typename T > class sstd :: mat_r { private : T * _pMatT ; uint _rows ; // row size uint _cols ; // column size uint _size ; // number of element public : inline mat_r (); inline mat_r ( const std :: initializer_list < std :: initializer_list < T >>& rhs ); // called by \"sstd::mat_r<T> mat = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\". inline mat_r ( const class mat_r & rhs ); // called by \"sstd::mat_r<T> buf1(N, N); sstd::mat_r<T> buf2(buf1);\" inline mat_r ( class mat_r && rhs ); // called by \"return std::move(rhs);\" or \"std::swap(buf1, buf2)\". inline mat_r ( const uint & rowSize , const uint & colSize ); inline ~ mat_r (); // Read only: R inline const uint rows () const ; inline const uint cols () const ; inline const uint size () const ; // Read and Write: RW inline T *& pMatT_RW (); inline uint & rows_RW (); inline uint & cols_RW (); inline uint & size_RW (); class mat_r & operator = ( const class mat_r & rhs ); // called by \"lhs = sstd::mat_r<T>(3, 3);\". inline T & operator []( const uint i ); inline T & operator []( const int i ); inline const T & operator []( const uint i ) const ; inline const T & operator []( const int i ) const ; inline T & operator ()( const uint p , const uint q ); inline T & operator ()( const int p , const uint q ); inline T & operator ()( const uint p , const int q ); inline T & operator ()( const int p , const int q ); inline const T & operator ()( const uint p , const uint q ) const ; inline const T & operator ()( const int p , const uint q ) const ; inline const T & operator ()( const uint p , const int q ) const ; inline const T & operator ()( const int p , const int q ) const ; // for element operations (elements multiplication) inline sstd :: mat_r_elements < T > operator ()(); inline sstd :: mat_r_elements < T > vec (); }; Usage Init main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m = {{ 1 , 2 }, { 3 , 4 }}; sstd :: mat_r < double > m_eye ( 2 , 2 ); sstd :: eye ( m_eye ); sstd :: mat_r < double > m_ones ( 2 , 2 ); sstd :: ones ( m_ones ); sstd :: mat_r < double > m_zeros ( 2 , 2 ); sstd :: zeros ( m_zeros ); sstd :: printn ( m ); printf ( \" \\n \" ); sstd :: printn ( m_eye ); printf ( \" \\n \" ); sstd :: printn ( m_ones ); printf ( \" \\n \" ); sstd :: printn ( m_zeros ); } Execution result m = 1.000000 2.000000 3.000000 4.000000 m_eye = 1.000000 0.000000 0.000000 1.000000 m_ones = 1.000000 1.000000 1.000000 1.000000 m_zeros = 0.000000 0.000000 0.000000 0.000000 Access to elements As a matrix main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m ( 2 , 2 ); uint i = 0 ; for ( uint r = 0 ; r < m . rows (); ++ r ){ for ( uint c = 0 ; c < m . cols (); ++ c ){ m ( r , c ) = i ; ++ i ; } } sstd :: printn ( m ); } Execution result m = 0.000000 1.000000 2.000000 3.000000 As a vector main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m ( 2 , 2 ); for ( uint i = 0 ; i < m . size (); ++ i ){ m [ i ] = i ; } sstd :: printn ( m ); } Execution result m = 0.000000 1.000000 2.000000 3.000000 Tr (Transpose) main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m1 = {{ 1 , 2 }, { 3 , 4 }}; sstd :: printn ( m1 ); sstd :: printn ( sstd :: Tr ( m1 ) ); printf ( \" \\n \" ); sstd :: mat_r < double > m2 = {{ 1 , 2 }, { 3 , 4 }}; sstd :: printn ( m2 ); sstd :: Tr_myself ( m2 ); sstd :: printn ( m2 ); } Execution result m1 = 1.000000 2.000000 3.000000 4.000000 sstd::Tr( m1 ) = 1.000000 3.000000 2.000000 4.000000 m2 = 1.000000 2.000000 3.000000 4.000000 m2 = 1.000000 3.000000 2.000000 4.000000 Operator matrix \u00d7 scalar main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m ( 2 , 2 ); for ( uint i = 0 ; i < m . size (); ++ i ){ m [ i ] = i ; } sstd :: printn ( m ); printf ( \" \\n \" ); sstd :: printn ( m * 2 ); } Execution result m = 0.000000 1.000000 2.000000 3.000000 m * 2 = 0.000000 2.000000 4.000000 6.000000 matrix \u00d7 matrix main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m1 ( 2 , 2 ); for ( uint i = 0 ; i < m1 . size (); ++ i ){ m1 [ i ] = i ; } sstd :: mat_r < double > m2 ( 2 , 2 ); for ( uint i = 0 ; i < m2 . size (); ++ i ){ m2 [ i ] = i + 1 ; } sstd :: printn ( m1 ); printf ( \" \\n \" ); sstd :: printn ( m2 ); printf ( \" \\n \" ); sstd :: printn ( m1 * m2 ); } Execution result m1 = 0.000000 1.000000 2.000000 3.000000 m2 = 1.000000 2.000000 3.000000 4.000000 m1 * m2 = 3.000000 4.000000 11.000000 16.000000 matrix (as a vector) \u00d7 matrix (as a vector) main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m1 ( 2 , 2 ); for ( uint i = 0 ; i < m1 . size (); ++ i ){ m1 [ i ] = i ; } sstd :: mat_r < double > m2 ( 2 , 2 ); for ( uint i = 0 ; i < m2 . size (); ++ i ){ m2 [ i ] = i + 1 ; } sstd :: printn ( m1 ); printf ( \" \\n \" ); sstd :: printn ( m2 ); printf ( \" \\n \" ); sstd :: printn ( m1 () * m2 () ); } Execution result m1 = 0.000000 1.000000 2.000000 3.000000 m2 = 1.000000 2.000000 3.000000 4.000000 m1() * m2() = 0.000000 2.000000 6.000000 12.000000 Implementation Source: sstd/src/matrixContainer_rowMajor/mat_r.cpp Header: sstd/src/matrixContainer_rowMajor/mat_r.hpp Test: test/mat_r.hpp (Not implemented yet)","title":"mat_r (Row-major)"},{"location":"src/matrix/mat_rowMajor.html#mat_r-row-major","text":"","title":"mat_r (Row-major)"},{"location":"src/matrix/mat_rowMajor.html#abstract","text":"mat_r is a row-major matrix container. mat_r \u306f\u884c\u512a\u5148\u306e\u884c\u5217\u30b3\u30f3\u30c6\u30ca\u3067\u3059.","title":"Abstract"},{"location":"src/matrix/mat_rowMajor.html#header-file","text":"namespace sstd { template < typename T > class mat_r ; template < typename T > void copy ( sstd :: mat_r < T >& lhs , const sstd :: mat_r < T >& rhs ); template < typename T > void move ( sstd :: mat_r < T >& lhs , sstd :: mat_r < T >& rhs ); template < typename T > void swap ( sstd :: mat_r < T >& lhs , sstd :: mat_r < T >& rhs ); template < typename T > void eye ( sstd :: mat_r < T >& rhs ); template < typename T > void ones ( sstd :: mat_r < T >& rhs ); template < typename T > void zeros ( sstd :: mat_r < T >& Mat ); template < typename T > sstd :: mat_r < T > Tr ( const sstd :: mat_r < T >& rhs ); // lhs = Transpose(rhs) template < typename T > void Tr_myself ( sstd :: mat_r < T >& rhs ); // Transpose(rhs) } template < typename T > class sstd :: mat_r { private : T * _pMatT ; uint _rows ; // row size uint _cols ; // column size uint _size ; // number of element public : inline mat_r (); inline mat_r ( const std :: initializer_list < std :: initializer_list < T >>& rhs ); // called by \"sstd::mat_r<T> mat = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\". inline mat_r ( const class mat_r & rhs ); // called by \"sstd::mat_r<T> buf1(N, N); sstd::mat_r<T> buf2(buf1);\" inline mat_r ( class mat_r && rhs ); // called by \"return std::move(rhs);\" or \"std::swap(buf1, buf2)\". inline mat_r ( const uint & rowSize , const uint & colSize ); inline ~ mat_r (); // Read only: R inline const uint rows () const ; inline const uint cols () const ; inline const uint size () const ; // Read and Write: RW inline T *& pMatT_RW (); inline uint & rows_RW (); inline uint & cols_RW (); inline uint & size_RW (); class mat_r & operator = ( const class mat_r & rhs ); // called by \"lhs = sstd::mat_r<T>(3, 3);\". inline T & operator []( const uint i ); inline T & operator []( const int i ); inline const T & operator []( const uint i ) const ; inline const T & operator []( const int i ) const ; inline T & operator ()( const uint p , const uint q ); inline T & operator ()( const int p , const uint q ); inline T & operator ()( const uint p , const int q ); inline T & operator ()( const int p , const int q ); inline const T & operator ()( const uint p , const uint q ) const ; inline const T & operator ()( const int p , const uint q ) const ; inline const T & operator ()( const uint p , const int q ) const ; inline const T & operator ()( const int p , const int q ) const ; // for element operations (elements multiplication) inline sstd :: mat_r_elements < T > operator ()(); inline sstd :: mat_r_elements < T > vec (); };","title":"Header file"},{"location":"src/matrix/mat_rowMajor.html#usage","text":"","title":"Usage"},{"location":"src/matrix/mat_rowMajor.html#init","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m = {{ 1 , 2 }, { 3 , 4 }}; sstd :: mat_r < double > m_eye ( 2 , 2 ); sstd :: eye ( m_eye ); sstd :: mat_r < double > m_ones ( 2 , 2 ); sstd :: ones ( m_ones ); sstd :: mat_r < double > m_zeros ( 2 , 2 ); sstd :: zeros ( m_zeros ); sstd :: printn ( m ); printf ( \" \\n \" ); sstd :: printn ( m_eye ); printf ( \" \\n \" ); sstd :: printn ( m_ones ); printf ( \" \\n \" ); sstd :: printn ( m_zeros ); } Execution result m = 1.000000 2.000000 3.000000 4.000000 m_eye = 1.000000 0.000000 0.000000 1.000000 m_ones = 1.000000 1.000000 1.000000 1.000000 m_zeros = 0.000000 0.000000 0.000000 0.000000","title":"Init"},{"location":"src/matrix/mat_rowMajor.html#access-to-elements","text":"","title":"Access to elements"},{"location":"src/matrix/mat_rowMajor.html#as-a-matrix","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m ( 2 , 2 ); uint i = 0 ; for ( uint r = 0 ; r < m . rows (); ++ r ){ for ( uint c = 0 ; c < m . cols (); ++ c ){ m ( r , c ) = i ; ++ i ; } } sstd :: printn ( m ); } Execution result m = 0.000000 1.000000 2.000000 3.000000","title":"As a matrix"},{"location":"src/matrix/mat_rowMajor.html#as-a-vector","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m ( 2 , 2 ); for ( uint i = 0 ; i < m . size (); ++ i ){ m [ i ] = i ; } sstd :: printn ( m ); } Execution result m = 0.000000 1.000000 2.000000 3.000000","title":"As a vector"},{"location":"src/matrix/mat_rowMajor.html#tr-transpose","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m1 = {{ 1 , 2 }, { 3 , 4 }}; sstd :: printn ( m1 ); sstd :: printn ( sstd :: Tr ( m1 ) ); printf ( \" \\n \" ); sstd :: mat_r < double > m2 = {{ 1 , 2 }, { 3 , 4 }}; sstd :: printn ( m2 ); sstd :: Tr_myself ( m2 ); sstd :: printn ( m2 ); } Execution result m1 = 1.000000 2.000000 3.000000 4.000000 sstd::Tr( m1 ) = 1.000000 3.000000 2.000000 4.000000 m2 = 1.000000 2.000000 3.000000 4.000000 m2 = 1.000000 3.000000 2.000000 4.000000","title":"Tr (Transpose)"},{"location":"src/matrix/mat_rowMajor.html#operator","text":"","title":"Operator"},{"location":"src/matrix/mat_rowMajor.html#matrix-scalar","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m ( 2 , 2 ); for ( uint i = 0 ; i < m . size (); ++ i ){ m [ i ] = i ; } sstd :: printn ( m ); printf ( \" \\n \" ); sstd :: printn ( m * 2 ); } Execution result m = 0.000000 1.000000 2.000000 3.000000 m * 2 = 0.000000 2.000000 4.000000 6.000000","title":"matrix \u00d7 scalar"},{"location":"src/matrix/mat_rowMajor.html#matrix-matrix","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m1 ( 2 , 2 ); for ( uint i = 0 ; i < m1 . size (); ++ i ){ m1 [ i ] = i ; } sstd :: mat_r < double > m2 ( 2 , 2 ); for ( uint i = 0 ; i < m2 . size (); ++ i ){ m2 [ i ] = i + 1 ; } sstd :: printn ( m1 ); printf ( \" \\n \" ); sstd :: printn ( m2 ); printf ( \" \\n \" ); sstd :: printn ( m1 * m2 ); } Execution result m1 = 0.000000 1.000000 2.000000 3.000000 m2 = 1.000000 2.000000 3.000000 4.000000 m1 * m2 = 3.000000 4.000000 11.000000 16.000000","title":"matrix \u00d7 matrix"},{"location":"src/matrix/mat_rowMajor.html#matrix-as-a-vector-matrix-as-a-vector","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m1 ( 2 , 2 ); for ( uint i = 0 ; i < m1 . size (); ++ i ){ m1 [ i ] = i ; } sstd :: mat_r < double > m2 ( 2 , 2 ); for ( uint i = 0 ; i < m2 . size (); ++ i ){ m2 [ i ] = i + 1 ; } sstd :: printn ( m1 ); printf ( \" \\n \" ); sstd :: printn ( m2 ); printf ( \" \\n \" ); sstd :: printn ( m1 () * m2 () ); } Execution result m1 = 0.000000 1.000000 2.000000 3.000000 m2 = 1.000000 2.000000 3.000000 4.000000 m1() * m2() = 0.000000 2.000000 6.000000 12.000000","title":"matrix (as a vector) \u00d7 matrix (as a vector)"},{"location":"src/matrix/mat_rowMajor.html#implementation","text":"Source: sstd/src/matrixContainer_rowMajor/mat_r.cpp Header: sstd/src/matrixContainer_rowMajor/mat_r.hpp Test: test/mat_r.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/print/pdbg.html","text":"pdbg Abstract pdbg prints debug information. pdbg \u306f\u30c7\u30d0\u30c3\u30b0\u60c5\u5831\u3092\u51fa\u529b\u3057\u307e\u3059\uff0e Header file namespace sstd { inline void pdbg (...){} inline void pdbg_if (...){} inline void pdbg_if_exit (...){} inline void pdbg_if_stop_exit (...){} inline void dbg (...){} inline void ndbg (...){} } Description Function name Description pdbg() A function to print debug messages with file name, function name and line number. \u30c7\u30d0\u30c3\u30b0\u30e1\u30c3\u30bb\u30fc\u30b8\u51fa\u529b\u7528\u306e\u95a2\u6570\uff0e\u547c\u3073\u51fa\u3057\u305f\u30d5\u30a1\u30a4\u30eb\u306e\u540d\u524d\uff0c\u95a2\u6570\u540d\uff0c\u884c\u6570\u3068\u30a8\u30e9\u30fc\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u51fa\u529b\u3059\u308b\uff0e pdbg_if() pdbg_if_exit() pdbg_if_stop_exit() dbg() ndbg() Usage pdbg main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: pdbg ( \"ERROR: printing error message. \\n \" ); printf ( \" \\n \" ); std :: string fileName = \"NotExistingFile.txt\" ; sstd :: file fp ; if ( ! fp . fopen ( fileName , \"rb\" )){ sstd :: pdbg ( \"ERROR: fopen is failed. \\\" %s \\\" is not exist! \\n \" , fileName . c_str ()); return -1 ; } return 0 ; } Execution result \u001b[1m\u001b[31m.././tmp/.._._docs_src_docs_src_print_pdbg.md_44.cpp/.._._docs_src_docs_src_print_pdbg.md_44.cpp:4 main(): \u001b[0mERROR: printing error message. \u001b[1m\u001b[31m.././tmp/.._._docs_src_docs_src_print_pdbg.md_44.cpp/.._._docs_src_docs_src_print_pdbg.md_44.cpp:9 main(): \u001b[0mERROR: fopen is failed. \"NotExistingFile.txt\" is not exist! NOTE1: The above output path is complex because the compile path for this file is complex. \u4e0a\u8a18\u3067\u8907\u96d1\u306a\u30d1\u30b9\u304c\u51fa\u529b\u3055\u308c\u308b\u306e\u306f\uff0c\u3053\u306e\u30d5\u30a1\u30a4\u30eb\u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u3059\u308b\u30d1\u30b9\u304c\u8907\u96d1\u306a\u305f\u3081\u3067\u3059\uff0e NOTE2: [31m treat as red on the terminal. [31m \u306f\u7aef\u672b\u4e0a\u3067\u8d64\u8272\u3068\u3057\u3066\u6271\u308f\u308c\u307e\u3059\uff0e pdbg_if main.cpp #include <sstd/sstd.hpp> int main (){ printf ( \"True: \" ); sstd :: pdbg_if ( true , \"ERROR: printing error message. \\n \" ); printf ( \"False: \" ); sstd :: pdbg_if ( false , \"ERROR: printing error message. \\n \" ); printf ( \" \\n \" ); return 0 ; } Execution result True: \u001b[1m\u001b[31m.././tmp/.._._docs_src_docs_src_print_pdbg.md_69.cpp/.._._docs_src_docs_src_print_pdbg.md_69.cpp:4 main(): \u001b[0mERROR: printing error message. False: NOTE1: The above output path is complex because the compile path for this file is complex. \u4e0a\u8a18\u3067\u8907\u96d1\u306a\u30d1\u30b9\u304c\u51fa\u529b\u3055\u308c\u308b\u306e\u306f\uff0c\u3053\u306e\u30d5\u30a1\u30a4\u30eb\u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u3059\u308b\u30d1\u30b9\u304c\u8907\u96d1\u306a\u305f\u3081\u3067\u3059\uff0e NOTE2: [31m treat as red on the terminal. [31m \u306f\u7aef\u672b\u4e0a\u3067\u8d64\u8272\u3068\u3057\u3066\u6271\u308f\u308c\u307e\u3059\uff0e Implementation Source: header only Header: sstd/src/print/pdbg.hpp Test: test/print/pdbg.hpp","title":"pdbg"},{"location":"src/print/pdbg.html#pdbg","text":"","title":"pdbg"},{"location":"src/print/pdbg.html#abstract","text":"pdbg prints debug information. pdbg \u306f\u30c7\u30d0\u30c3\u30b0\u60c5\u5831\u3092\u51fa\u529b\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/print/pdbg.html#header-file","text":"namespace sstd { inline void pdbg (...){} inline void pdbg_if (...){} inline void pdbg_if_exit (...){} inline void pdbg_if_stop_exit (...){} inline void dbg (...){} inline void ndbg (...){} }","title":"Header file"},{"location":"src/print/pdbg.html#description","text":"Function name Description pdbg() A function to print debug messages with file name, function name and line number. \u30c7\u30d0\u30c3\u30b0\u30e1\u30c3\u30bb\u30fc\u30b8\u51fa\u529b\u7528\u306e\u95a2\u6570\uff0e\u547c\u3073\u51fa\u3057\u305f\u30d5\u30a1\u30a4\u30eb\u306e\u540d\u524d\uff0c\u95a2\u6570\u540d\uff0c\u884c\u6570\u3068\u30a8\u30e9\u30fc\u30e1\u30c3\u30bb\u30fc\u30b8\u3092\u51fa\u529b\u3059\u308b\uff0e pdbg_if() pdbg_if_exit() pdbg_if_stop_exit() dbg() ndbg()","title":"Description"},{"location":"src/print/pdbg.html#usage","text":"","title":"Usage"},{"location":"src/print/pdbg.html#pdbg_1","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: pdbg ( \"ERROR: printing error message. \\n \" ); printf ( \" \\n \" ); std :: string fileName = \"NotExistingFile.txt\" ; sstd :: file fp ; if ( ! fp . fopen ( fileName , \"rb\" )){ sstd :: pdbg ( \"ERROR: fopen is failed. \\\" %s \\\" is not exist! \\n \" , fileName . c_str ()); return -1 ; } return 0 ; } Execution result \u001b[1m\u001b[31m.././tmp/.._._docs_src_docs_src_print_pdbg.md_44.cpp/.._._docs_src_docs_src_print_pdbg.md_44.cpp:4 main(): \u001b[0mERROR: printing error message. \u001b[1m\u001b[31m.././tmp/.._._docs_src_docs_src_print_pdbg.md_44.cpp/.._._docs_src_docs_src_print_pdbg.md_44.cpp:9 main(): \u001b[0mERROR: fopen is failed. \"NotExistingFile.txt\" is not exist! NOTE1: The above output path is complex because the compile path for this file is complex. \u4e0a\u8a18\u3067\u8907\u96d1\u306a\u30d1\u30b9\u304c\u51fa\u529b\u3055\u308c\u308b\u306e\u306f\uff0c\u3053\u306e\u30d5\u30a1\u30a4\u30eb\u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u3059\u308b\u30d1\u30b9\u304c\u8907\u96d1\u306a\u305f\u3081\u3067\u3059\uff0e NOTE2: [31m treat as red on the terminal. [31m \u306f\u7aef\u672b\u4e0a\u3067\u8d64\u8272\u3068\u3057\u3066\u6271\u308f\u308c\u307e\u3059\uff0e","title":"pdbg"},{"location":"src/print/pdbg.html#pdbg_if","text":"main.cpp #include <sstd/sstd.hpp> int main (){ printf ( \"True: \" ); sstd :: pdbg_if ( true , \"ERROR: printing error message. \\n \" ); printf ( \"False: \" ); sstd :: pdbg_if ( false , \"ERROR: printing error message. \\n \" ); printf ( \" \\n \" ); return 0 ; } Execution result True: \u001b[1m\u001b[31m.././tmp/.._._docs_src_docs_src_print_pdbg.md_69.cpp/.._._docs_src_docs_src_print_pdbg.md_69.cpp:4 main(): \u001b[0mERROR: printing error message. False: NOTE1: The above output path is complex because the compile path for this file is complex. \u4e0a\u8a18\u3067\u8907\u96d1\u306a\u30d1\u30b9\u304c\u51fa\u529b\u3055\u308c\u308b\u306e\u306f\uff0c\u3053\u306e\u30d5\u30a1\u30a4\u30eb\u3092\u30b3\u30f3\u30d1\u30a4\u30eb\u3059\u308b\u30d1\u30b9\u304c\u8907\u96d1\u306a\u305f\u3081\u3067\u3059\uff0e NOTE2: [31m treat as red on the terminal. [31m \u306f\u7aef\u672b\u4e0a\u3067\u8d64\u8272\u3068\u3057\u3066\u6271\u308f\u308c\u307e\u3059\uff0e","title":"pdbg_if"},{"location":"src/print/pdbg.html#implementation","text":"Source: header only Header: sstd/src/print/pdbg.hpp Test: test/print/pdbg.hpp","title":"Implementation"},{"location":"src/print/print.html","text":"print / printn Abstract print() , printn() , printn_all() and printn_fflv() print values of variable. printn() , printn_all() and printn_fflv() are macro functions and able to apply variables can print by for_printn() . print() , printn() , printn_all() and printn_fflv() \u306f\u5909\u6570\u306e\u5024\u3092\u8868\u793a\u3059\u308b\uff0e printn() , printn_all() and printn_fflv() \u306f\u30de\u30af\u30ed\u95a2\u6570\u3067\uff0c for_printn() \u3067\u8868\u793a\u3067\u304d\u308b\u5909\u6570\u306b\u9069\u7528\u3067\u304d\u308b\uff0e name of macro function descriptions print() print values of variable. \u5909\u6570\u306e\u5024\u3092\u51fa\u529b\u3057\u307e\u3059\uff0e printn() print values of variable with variable name. \u5909\u6570\u306e\u5024\u3092\uff0c\u5909\u6570\u540d\u3092\u4ed8\u4e0e\u3057\u3066\u51fa\u529b\u3057\u307e\u3059\uff0e printn_all() print values of variable with variable name, function name and function line number. \u5909\u6570\u306e\u5024\u3092\uff0c\u5909\u6570\u540d\u3068\u95a2\u6570\u540d\uff0c\u95a2\u6570\u306e\u884c\u756a\u53f7\u3092\u4ed8\u4e0e\u3057\u3066\u51fa\u529b\u3057\u307e\u3059\uff0e printn_fflv() print values of variable with variable name, function name, function line number, path to the function and implemented file name. \u5909\u6570\u306e\u5024\u3092\uff0c\u5909\u6570\u540d\u3068\u95a2\u6570\u540d\uff0c\u95a2\u6570\u306e\u884c\u756a\u53f7\uff0c\u5b9f\u88c5\u306e\u30d5\u30a1\u30a4\u30eb\u306e\u30d5\u30a1\u30a4\u30eb\u540d\u3068\u30d1\u30b9\uff0c\u3092\u4ed8\u4e0e\u3057\u3066\u51fa\u529b\u3057\u307e\u3059\uff0e Header file namespace sstd { void print ( const bool rhs ); void print ( const char rhs ); void print ( const int8 rhs ); void print ( const int16 rhs ); void print ( const int32 rhs ); void print ( const int64 rhs ); void print ( const uint8 rhs ); void print ( const uint16 rhs ); void print ( const uint32 rhs ); void print ( const uint64 rhs ); void print ( const float rhs ); void print ( const double rhs ); void print ( const char * rhs ); void print ( const std :: string & rhs ); template < typename T > void print ( const std :: vector < T >& rhs ); template < typename T_lhs , typename T_rhs > void print ( const std :: unordered_map < T_lhs , T_rhs >& rhs ); void for_printn ( bool rhs ); void for_printn ( char rhs ); void for_printn ( int8 rhs ); void for_printn ( int16 rhs ); void for_printn ( int32 rhs ); void for_printn ( int64 rhs ); void for_printn ( uint8 rhs ); void for_printn ( uint16 rhs ); void for_printn ( uint32 rhs ); void for_printn ( uint64 rhs ); void for_printn ( float rhs ); void for_printn ( double rhs ); void for_printn ( const char * rhs ); void for_printn ( const std :: string & rhs ); template < typename T > void for_printn ( const std :: vector < T >& rhs ); template < typename T_lhs , typename T_rhs > void for_printn ( const std :: unordered_map < T_lhs , T_rhs >& rhs ); //--- // for #define inline void printn_dummy (){} inline void printn (...){} inline void printn_all (...){} } #define printn(var) printn_dummy();{printf(\"%s\", #var);sstd::for_printn(var);} #define printn_all(var) printn_dummy();{printf(\"%s(%d): %s\", __func__, __LINE__, #var);sstd::for_printn(var);} #define printn_fflv(var) printn_dummy();{printf(\"%s: %s(%d): %s\", __FILE__, __func__, __LINE__, #var);sstd::for_printn(var);} Usage print(), printn(), printn_all(), printn_fflv() main.cpp #include <sstd/sstd.hpp> int main (){ int i = 0 ; sstd :: print ( i ); sstd :: printn ( i ); sstd :: printn_all ( i ); sstd :: printn_fflv ( i ); } Execution result 0 i = 0 main(7): i = 0 .././tmp/.._._docs_src_docs_src_print_print.md_84.cpp/.._._docs_src_docs_src_print_print.md_84.cpp: main(8): i = 0 print bool type main.cpp #include <sstd/sstd.hpp> int main (){ bool TF_t = true ; sstd :: printn ( TF_t ); bool TF_f = false ; sstd :: printn ( TF_f ); } Execution result TF_t = true TF_f = false print std::vector<T> type main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > vS = { \"a\" , \"b\" , \"c\" }; sstd :: printn ( vS ); std :: vector < std :: vector < std :: string >> vvS = {{ \"a\" , \"b\" , \"c\" }, { \"d\" , \"e\" , \"f\" }}; sstd :: printn ( vvS ); printf ( \" \\n \" ); // any depth vector<T>. T is bool, char, (u)int8-16-32-64, float, double, char* and std::string. std :: vector < std :: vector < std :: vector < std :: vector < int >>>> v4_int = {{{{ 1 , 2 }, { 3 , 4 }}, {{ 5 , 6 }, { 7 , 8 }}}, {{{ 9 , 10 }, { 11 , 12 }}, {{ 13 , 14 }, { 15 , 16 }}}}; sstd :: printn ( v4_int ); } Execution result vS = [\"a\" \"b\" \"c\"] vvS = [[\"a\" \"b\" \"c\"] [\"d\" \"e\" \"f\"]] v4_int = [[[[1 2] [3 4]] [[5 6] [7 8]]] [[[9 10] [11 12]] [[13 14] [15 16]]]] print std::unordered_map<T_lhs, T_rhs> type main.cpp #include <sstd/sstd.hpp> int main (){ std :: unordered_map < std :: string , std :: vector < uint >> table ; table [ \"abc\" ] = { 123 , 456 }; table [ \"def\" ] = { 456 , 789 }; sstd :: printn ( table ); } Execution result table = [ [key: \"def\", value: [456 789]], [key: \"abc\", value: [123 456]] ] print sstd::mat_r<T> type main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m = {{ 1 , 2 , 3 }, { 4 , 5 , 6 }, { 7 , 8 , 9 }}; sstd :: printn ( m ); } Execution result m = 1.000000 2.000000 3.000000 4.000000 5.000000 6.000000 7.000000 8.000000 9.000000 Implementation Source: sstd/src/print/print.cpp Header: sstd/src/print/print.hpp Test: test/print/print_printn_printn_all.hpp","title":"print / printn"},{"location":"src/print/print.html#print-printn","text":"","title":"print / printn"},{"location":"src/print/print.html#abstract","text":"print() , printn() , printn_all() and printn_fflv() print values of variable. printn() , printn_all() and printn_fflv() are macro functions and able to apply variables can print by for_printn() . print() , printn() , printn_all() and printn_fflv() \u306f\u5909\u6570\u306e\u5024\u3092\u8868\u793a\u3059\u308b\uff0e printn() , printn_all() and printn_fflv() \u306f\u30de\u30af\u30ed\u95a2\u6570\u3067\uff0c for_printn() \u3067\u8868\u793a\u3067\u304d\u308b\u5909\u6570\u306b\u9069\u7528\u3067\u304d\u308b\uff0e name of macro function descriptions print() print values of variable. \u5909\u6570\u306e\u5024\u3092\u51fa\u529b\u3057\u307e\u3059\uff0e printn() print values of variable with variable name. \u5909\u6570\u306e\u5024\u3092\uff0c\u5909\u6570\u540d\u3092\u4ed8\u4e0e\u3057\u3066\u51fa\u529b\u3057\u307e\u3059\uff0e printn_all() print values of variable with variable name, function name and function line number. \u5909\u6570\u306e\u5024\u3092\uff0c\u5909\u6570\u540d\u3068\u95a2\u6570\u540d\uff0c\u95a2\u6570\u306e\u884c\u756a\u53f7\u3092\u4ed8\u4e0e\u3057\u3066\u51fa\u529b\u3057\u307e\u3059\uff0e printn_fflv() print values of variable with variable name, function name, function line number, path to the function and implemented file name. \u5909\u6570\u306e\u5024\u3092\uff0c\u5909\u6570\u540d\u3068\u95a2\u6570\u540d\uff0c\u95a2\u6570\u306e\u884c\u756a\u53f7\uff0c\u5b9f\u88c5\u306e\u30d5\u30a1\u30a4\u30eb\u306e\u30d5\u30a1\u30a4\u30eb\u540d\u3068\u30d1\u30b9\uff0c\u3092\u4ed8\u4e0e\u3057\u3066\u51fa\u529b\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/print/print.html#header-file","text":"namespace sstd { void print ( const bool rhs ); void print ( const char rhs ); void print ( const int8 rhs ); void print ( const int16 rhs ); void print ( const int32 rhs ); void print ( const int64 rhs ); void print ( const uint8 rhs ); void print ( const uint16 rhs ); void print ( const uint32 rhs ); void print ( const uint64 rhs ); void print ( const float rhs ); void print ( const double rhs ); void print ( const char * rhs ); void print ( const std :: string & rhs ); template < typename T > void print ( const std :: vector < T >& rhs ); template < typename T_lhs , typename T_rhs > void print ( const std :: unordered_map < T_lhs , T_rhs >& rhs ); void for_printn ( bool rhs ); void for_printn ( char rhs ); void for_printn ( int8 rhs ); void for_printn ( int16 rhs ); void for_printn ( int32 rhs ); void for_printn ( int64 rhs ); void for_printn ( uint8 rhs ); void for_printn ( uint16 rhs ); void for_printn ( uint32 rhs ); void for_printn ( uint64 rhs ); void for_printn ( float rhs ); void for_printn ( double rhs ); void for_printn ( const char * rhs ); void for_printn ( const std :: string & rhs ); template < typename T > void for_printn ( const std :: vector < T >& rhs ); template < typename T_lhs , typename T_rhs > void for_printn ( const std :: unordered_map < T_lhs , T_rhs >& rhs ); //--- // for #define inline void printn_dummy (){} inline void printn (...){} inline void printn_all (...){} } #define printn(var) printn_dummy();{printf(\"%s\", #var);sstd::for_printn(var);} #define printn_all(var) printn_dummy();{printf(\"%s(%d): %s\", __func__, __LINE__, #var);sstd::for_printn(var);} #define printn_fflv(var) printn_dummy();{printf(\"%s: %s(%d): %s\", __FILE__, __func__, __LINE__, #var);sstd::for_printn(var);}","title":"Header file"},{"location":"src/print/print.html#usage","text":"","title":"Usage"},{"location":"src/print/print.html#print-printn-printn_all-printn_fflv","text":"main.cpp #include <sstd/sstd.hpp> int main (){ int i = 0 ; sstd :: print ( i ); sstd :: printn ( i ); sstd :: printn_all ( i ); sstd :: printn_fflv ( i ); } Execution result 0 i = 0 main(7): i = 0 .././tmp/.._._docs_src_docs_src_print_print.md_84.cpp/.._._docs_src_docs_src_print_print.md_84.cpp: main(8): i = 0","title":"print(), printn(), printn_all(), printn_fflv()"},{"location":"src/print/print.html#print-bool-type","text":"main.cpp #include <sstd/sstd.hpp> int main (){ bool TF_t = true ; sstd :: printn ( TF_t ); bool TF_f = false ; sstd :: printn ( TF_f ); } Execution result TF_t = true TF_f = false","title":"print bool type"},{"location":"src/print/print.html#print-stdvectort-type","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > vS = { \"a\" , \"b\" , \"c\" }; sstd :: printn ( vS ); std :: vector < std :: vector < std :: string >> vvS = {{ \"a\" , \"b\" , \"c\" }, { \"d\" , \"e\" , \"f\" }}; sstd :: printn ( vvS ); printf ( \" \\n \" ); // any depth vector<T>. T is bool, char, (u)int8-16-32-64, float, double, char* and std::string. std :: vector < std :: vector < std :: vector < std :: vector < int >>>> v4_int = {{{{ 1 , 2 }, { 3 , 4 }}, {{ 5 , 6 }, { 7 , 8 }}}, {{{ 9 , 10 }, { 11 , 12 }}, {{ 13 , 14 }, { 15 , 16 }}}}; sstd :: printn ( v4_int ); } Execution result vS = [\"a\" \"b\" \"c\"] vvS = [[\"a\" \"b\" \"c\"] [\"d\" \"e\" \"f\"]] v4_int = [[[[1 2] [3 4]] [[5 6] [7 8]]] [[[9 10] [11 12]] [[13 14] [15 16]]]]","title":"print std::vector&lt;T&gt; type"},{"location":"src/print/print.html#print-stdunordered_mapt_lhs-t_rhs-type","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: unordered_map < std :: string , std :: vector < uint >> table ; table [ \"abc\" ] = { 123 , 456 }; table [ \"def\" ] = { 456 , 789 }; sstd :: printn ( table ); } Execution result table = [ [key: \"def\", value: [456 789]], [key: \"abc\", value: [123 456]] ]","title":"print std::unordered_map&lt;T_lhs, T_rhs&gt; type"},{"location":"src/print/print.html#print-sstdmat_rt-type","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: mat_r < double > m = {{ 1 , 2 , 3 }, { 4 , 5 , 6 }, { 7 , 8 , 9 }}; sstd :: printn ( m ); } Execution result m = 1.000000 2.000000 3.000000 4.000000 5.000000 6.000000 7.000000 8.000000 9.000000","title":"print sstd::mat_r&lt;T&gt; type"},{"location":"src/print/print.html#implementation","text":"Source: sstd/src/print/print.cpp Header: sstd/src/print/print.hpp Test: test/print/print_printn_printn_all.hpp","title":"Implementation"},{"location":"src/string/ssprintf.html","text":"ssprintf Abstract ssprintf() is the std::string version of sprintf() . ssprintf() \u306f\uff0c sprintf() \u306e std::string \u7248\u3067\u3059\uff0e Header file namespace sstd { std :: string ssprintf ( const char * format , ...); } Usage main.cpp #include <sstd/sstd.hpp> int main (){ std :: string s = sstd :: ssprintf ( \"%s %d%d%d %03d\" , \"ABC\" , 0 , 1 , 2 , 3 ); sstd :: printn ( s ); } Execution result s = \"ABC 012 003\" Implementation Source: sstd/src/ssprintf.cpp Header: sstd/src/ssprintf.hpp Test: test/ssprintf.hpp (Not implemented yet)","title":"ssprintf"},{"location":"src/string/ssprintf.html#ssprintf","text":"","title":"ssprintf"},{"location":"src/string/ssprintf.html#abstract","text":"ssprintf() is the std::string version of sprintf() . ssprintf() \u306f\uff0c sprintf() \u306e std::string \u7248\u3067\u3059\uff0e","title":"Abstract"},{"location":"src/string/ssprintf.html#header-file","text":"namespace sstd { std :: string ssprintf ( const char * format , ...); }","title":"Header file"},{"location":"src/string/ssprintf.html#usage","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: string s = sstd :: ssprintf ( \"%s %d%d%d %03d\" , \"ABC\" , 0 , 1 , 2 , 3 ); sstd :: printn ( s ); } Execution result s = \"ABC 012 003\"","title":"Usage"},{"location":"src/string/ssprintf.html#implementation","text":"Source: sstd/src/ssprintf.cpp Header: sstd/src/ssprintf.hpp Test: test/ssprintf.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/string/strEdit.html","text":"strEdit Abstract strEdit.hpp / strEdit.cpp \u306f\uff0c\u6587\u5b57\u5217\u3092\u7de8\u96c6\u3059\u308b\u305f\u3081\u306e\u95a2\u6570\u3092\u53ce\u9332\u3057\u3066\u3044\u308b\uff0e Header file namespace sstd { std :: vector < std :: string > splitByLine ( const char * str ); std :: vector < std :: string > splitByLine ( const std :: string & str ); std :: vector < std :: string > split ( const char * str , const char X ); std :: vector < std :: string > split ( const std :: string & str , const char X ); // remove space or tab. std :: string lstrip ( const char * str ); // removing head spaces std :: string lstrip ( const std :: string & str ); // removing head spaces void lstrip_ow ( std :: string & str ); // removing head spaces. ow: overwrite std :: string rstrip ( const char * str ); // removing tail spaces std :: string rstrip ( const std :: string & str ); // removing tail spaces void rstrip_ow ( std :: string & str ); // removing tail spaces. ow: overwrite std :: string strip ( const char * str ); // removing head and tail tab and spaces std :: string strip ( const std :: string & str ); // removing head and tail tab and spaces void strip_ow ( std :: string & str ); // removing head and tail tab and spaces. ow: overwrite std :: vector < std :: string > strip ( const std :: vector < std :: string >& vec ); // -> strip(str) // removing head and tail spaces std :: string lstrip ( const char * str , const char c ); std :: string lstrip ( const std :: string & str , const char c ); void lstrip_ow ( std :: string & str , const char c ); std :: string rstrip ( const char * str , const char c ); std :: string rstrip ( const std :: string & str , const char c ); void rstrip_ow ( std :: string & str , const char c ); std :: string strip ( const char * str , const char c ); std :: string strip ( const std :: string & str , const char c ); void strip_ow ( std :: string & str , const char c ); std :: string stripAll ( const char * str , const char * stripList ); std :: string stripAll ( const std :: string & str , const char * stripList ); std :: string stripAll ( const char * str , const std :: string & stripList ); std :: string stripAll ( const std :: string & str , const std :: string & stripList ); void stripAll_ow ( std :: string & str , const char * stripList ); void stripAll_ow ( std :: string & str , const std :: string & stripList ); } Description split string / \u6587\u5b57\u5217\u306e\u5206\u5272 Function name Description splitByLine() split the string with a line feed code. \u6587\u5b57\u5217\u3092\u6539\u884c\u30b3\u30fc\u30c9\u3054\u3068\u306b\u5206\u5272\u3057\u307e\u3059\uff0e split() split the string by a character of arg 2. \u7b2c 2 \u5f15\u6570\u306e\u6587\u5b57\u3067\u6587\u5b57\u5217\u3092\u5206\u5272\u3057\u307e\u3059\uff0e Remove spaces and tabs / \u7a7a\u767d (\u534a\u89d2\u30b9\u30da\u30fc\u30b9) \u3068\u30bf\u30d6\u6587\u5b57\u306e\u9664\u53bb Function name Description lstrip() remove head spaces and tabs. \u6587\u5b57\u5217\u306e\u5148\u982d\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e lstrip_ow() remove head spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u5148\u982d\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e rstrip() remove tail spaces and tabs. \u6587\u5b57\u5217\u306e\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e rstrip_ow() remove tail spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e strip() remove head and tail spaces and tabs. \u6587\u5b57\u5217\u306e\u5148\u982d\u3068\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e strip_ow() remove head and tail spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u5148\u982d\u3068\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e stripAll() remove all types of characters in arg 2. \u7b2c 2 \u5f15\u6570\u306b\u3042\u308b\u5168\u3066\u306e\u7a2e\u985e\u306e\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e stripAll_ow() remove all types of characters in arg 2. _ow means overwrite. \u7b2c 2 \u5f15\u6570\u306b\u3042\u308b\u5168\u3066\u306e\u7a2e\u985e\u306e\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e Usage splitByLine() main.cpp #include <sstd/sstd.hpp> int main (){ std :: string s1 = \"abc \\n def \\n \" ; std :: vector < std :: string > vS1 = sstd :: splitByLine ( s1 ); sstd :: printn ( vS1 ); std :: string s2 = \"abc \\r\\n def \\r\\n \" ; std :: vector < std :: string > vS2 = sstd :: splitByLine ( s2 ); sstd :: printn ( vS2 ); std :: string s3 = \" \\n abc \\n def \\n\\n \" ; std :: vector < std :: string > vS3 = sstd :: splitByLine ( s3 ); sstd :: printn ( vS3 ); } Execution result vS1 = [\"abc\" \"def\"] vS2 = [\"abc\" \"def\"] vS3 = [\"\" \"abc\" \"def\" \"\"] split() main.cpp #include <sstd/sstd.hpp> int main (){ std :: string s1 = \"abc|def|\" ; std :: vector < std :: string > vS1 = sstd :: split ( s1 , '|' ); sstd :: printn ( vS1 ); std :: string s2 = \"|abc|def||\" ; std :: vector < std :: string > vS2 = sstd :: split ( s2 , '|' ); sstd :: printn ( vS2 ); } Execution result vS1 = [\"abc\" \"def\"] vS2 = [\"\" \"abc\" \"def\" \"\"] lstrip() main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: lstrip ( \" a b c \" )); sstd :: printn ( sstd :: lstrip ( \"---a-b-c---\" , '-' )); std :: string s1 = \" a b c \" ; sstd :: lstrip_ow ( s1 ); sstd :: printn ( s1 ); std :: string s2 = \"---a-b-c---\" ; sstd :: lstrip_ow ( s2 , '-' ); sstd :: printn ( s2 ); } Execution result sstd::lstrip(\" a b c \") = \"a b c \" sstd::lstrip(\"---a-b-c---\", '-') = \"a-b-c---\" s1 = \"a b c \" s2 = \"a-b-c---\" rstrip() main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: rstrip ( \" a b c \" )); sstd :: printn ( sstd :: rstrip ( \"---a-b-c---\" , '-' )); std :: string s1 = \" a b c \" ; sstd :: rstrip_ow ( s1 ); sstd :: printn ( s1 ); std :: string s2 = \"---a-b-c---\" ; sstd :: rstrip_ow ( s2 , '-' ); sstd :: printn ( s2 ); } Execution result sstd::rstrip(\" a b c \") = \" a b c\" sstd::rstrip(\"---a-b-c---\", '-') = \"---a-b-c\" s1 = \" a b c\" s2 = \"---a-b-c\" strip() main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: strip ( \" a b c \" )); sstd :: printn ( sstd :: strip ( \"---a-b-c---\" , '-' )); std :: string s1 = \" a b c \" ; sstd :: strip_ow ( s1 ); sstd :: printn ( s1 ); std :: string s2 = \"---a-b-c---\" ; sstd :: strip_ow ( s2 , '-' ); sstd :: printn ( s2 ); } Execution result sstd::strip(\" a b c \") = \"a b c\" sstd::strip(\"---a-b-c---\", '-') = \"a-b-c\" s1 = \"a b c\" s2 = \"a-b-c\" stripAll() main.cpp #include <sstd/sstd.hpp> int main (){ std :: string s = \" a x b x c \" ; sstd :: stripAll_ow ( s , \" x\" ); sstd :: printn ( s ); } Execution result s = \"abc\" Implementation Source: sstd/src/vector/strEdit.cpp Header: sstd/src/vector/strEdit.hpp Test: test/strEdit.hpp","title":"strEdit"},{"location":"src/string/strEdit.html#stredit","text":"","title":"strEdit"},{"location":"src/string/strEdit.html#abstract","text":"strEdit.hpp / strEdit.cpp \u306f\uff0c\u6587\u5b57\u5217\u3092\u7de8\u96c6\u3059\u308b\u305f\u3081\u306e\u95a2\u6570\u3092\u53ce\u9332\u3057\u3066\u3044\u308b\uff0e","title":"Abstract"},{"location":"src/string/strEdit.html#header-file","text":"namespace sstd { std :: vector < std :: string > splitByLine ( const char * str ); std :: vector < std :: string > splitByLine ( const std :: string & str ); std :: vector < std :: string > split ( const char * str , const char X ); std :: vector < std :: string > split ( const std :: string & str , const char X ); // remove space or tab. std :: string lstrip ( const char * str ); // removing head spaces std :: string lstrip ( const std :: string & str ); // removing head spaces void lstrip_ow ( std :: string & str ); // removing head spaces. ow: overwrite std :: string rstrip ( const char * str ); // removing tail spaces std :: string rstrip ( const std :: string & str ); // removing tail spaces void rstrip_ow ( std :: string & str ); // removing tail spaces. ow: overwrite std :: string strip ( const char * str ); // removing head and tail tab and spaces std :: string strip ( const std :: string & str ); // removing head and tail tab and spaces void strip_ow ( std :: string & str ); // removing head and tail tab and spaces. ow: overwrite std :: vector < std :: string > strip ( const std :: vector < std :: string >& vec ); // -> strip(str) // removing head and tail spaces std :: string lstrip ( const char * str , const char c ); std :: string lstrip ( const std :: string & str , const char c ); void lstrip_ow ( std :: string & str , const char c ); std :: string rstrip ( const char * str , const char c ); std :: string rstrip ( const std :: string & str , const char c ); void rstrip_ow ( std :: string & str , const char c ); std :: string strip ( const char * str , const char c ); std :: string strip ( const std :: string & str , const char c ); void strip_ow ( std :: string & str , const char c ); std :: string stripAll ( const char * str , const char * stripList ); std :: string stripAll ( const std :: string & str , const char * stripList ); std :: string stripAll ( const char * str , const std :: string & stripList ); std :: string stripAll ( const std :: string & str , const std :: string & stripList ); void stripAll_ow ( std :: string & str , const char * stripList ); void stripAll_ow ( std :: string & str , const std :: string & stripList ); }","title":"Header file"},{"location":"src/string/strEdit.html#description","text":"","title":"Description"},{"location":"src/string/strEdit.html#split-string","text":"Function name Description splitByLine() split the string with a line feed code. \u6587\u5b57\u5217\u3092\u6539\u884c\u30b3\u30fc\u30c9\u3054\u3068\u306b\u5206\u5272\u3057\u307e\u3059\uff0e split() split the string by a character of arg 2. \u7b2c 2 \u5f15\u6570\u306e\u6587\u5b57\u3067\u6587\u5b57\u5217\u3092\u5206\u5272\u3057\u307e\u3059\uff0e","title":"split string / \u6587\u5b57\u5217\u306e\u5206\u5272"},{"location":"src/string/strEdit.html#remove-spaces-and-tabs","text":"Function name Description lstrip() remove head spaces and tabs. \u6587\u5b57\u5217\u306e\u5148\u982d\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e lstrip_ow() remove head spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u5148\u982d\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e rstrip() remove tail spaces and tabs. \u6587\u5b57\u5217\u306e\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e rstrip_ow() remove tail spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e strip() remove head and tail spaces and tabs. \u6587\u5b57\u5217\u306e\u5148\u982d\u3068\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e strip_ow() remove head and tail spaces and tabs. _ow means overwrite. \u6587\u5b57\u5217\u306e\u5148\u982d\u3068\u672b\u5c3e\u306b\u3042\u308b\u534a\u89d2\u30b9\u30da\u30fc\u30b9\u3068\u30bf\u30d6\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e stripAll() remove all types of characters in arg 2. \u7b2c 2 \u5f15\u6570\u306b\u3042\u308b\u5168\u3066\u306e\u7a2e\u985e\u306e\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e stripAll_ow() remove all types of characters in arg 2. _ow means overwrite. \u7b2c 2 \u5f15\u6570\u306b\u3042\u308b\u5168\u3066\u306e\u7a2e\u985e\u306e\u6587\u5b57\u3092\u9664\u53bb\u3057\u307e\u3059\uff0e _ow \u306f overwrite \u306e\u610f\u5473\u3067\uff0c\u5f15\u6570\u306b\u7d50\u679c\u3092\u4e0a\u66f8\u304d\u3057\u307e\u3059\uff0e","title":"Remove spaces and tabs / \u7a7a\u767d (\u534a\u89d2\u30b9\u30da\u30fc\u30b9) \u3068\u30bf\u30d6\u6587\u5b57\u306e\u9664\u53bb"},{"location":"src/string/strEdit.html#usage","text":"","title":"Usage"},{"location":"src/string/strEdit.html#splitbyline","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: string s1 = \"abc \\n def \\n \" ; std :: vector < std :: string > vS1 = sstd :: splitByLine ( s1 ); sstd :: printn ( vS1 ); std :: string s2 = \"abc \\r\\n def \\r\\n \" ; std :: vector < std :: string > vS2 = sstd :: splitByLine ( s2 ); sstd :: printn ( vS2 ); std :: string s3 = \" \\n abc \\n def \\n\\n \" ; std :: vector < std :: string > vS3 = sstd :: splitByLine ( s3 ); sstd :: printn ( vS3 ); } Execution result vS1 = [\"abc\" \"def\"] vS2 = [\"abc\" \"def\"] vS3 = [\"\" \"abc\" \"def\" \"\"]","title":"splitByLine()"},{"location":"src/string/strEdit.html#split","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: string s1 = \"abc|def|\" ; std :: vector < std :: string > vS1 = sstd :: split ( s1 , '|' ); sstd :: printn ( vS1 ); std :: string s2 = \"|abc|def||\" ; std :: vector < std :: string > vS2 = sstd :: split ( s2 , '|' ); sstd :: printn ( vS2 ); } Execution result vS1 = [\"abc\" \"def\"] vS2 = [\"\" \"abc\" \"def\" \"\"]","title":"split()"},{"location":"src/string/strEdit.html#lstrip","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: lstrip ( \" a b c \" )); sstd :: printn ( sstd :: lstrip ( \"---a-b-c---\" , '-' )); std :: string s1 = \" a b c \" ; sstd :: lstrip_ow ( s1 ); sstd :: printn ( s1 ); std :: string s2 = \"---a-b-c---\" ; sstd :: lstrip_ow ( s2 , '-' ); sstd :: printn ( s2 ); } Execution result sstd::lstrip(\" a b c \") = \"a b c \" sstd::lstrip(\"---a-b-c---\", '-') = \"a-b-c---\" s1 = \"a b c \" s2 = \"a-b-c---\"","title":"lstrip()"},{"location":"src/string/strEdit.html#rstrip","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: rstrip ( \" a b c \" )); sstd :: printn ( sstd :: rstrip ( \"---a-b-c---\" , '-' )); std :: string s1 = \" a b c \" ; sstd :: rstrip_ow ( s1 ); sstd :: printn ( s1 ); std :: string s2 = \"---a-b-c---\" ; sstd :: rstrip_ow ( s2 , '-' ); sstd :: printn ( s2 ); } Execution result sstd::rstrip(\" a b c \") = \" a b c\" sstd::rstrip(\"---a-b-c---\", '-') = \"---a-b-c\" s1 = \" a b c\" s2 = \"---a-b-c\"","title":"rstrip()"},{"location":"src/string/strEdit.html#strip","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: strip ( \" a b c \" )); sstd :: printn ( sstd :: strip ( \"---a-b-c---\" , '-' )); std :: string s1 = \" a b c \" ; sstd :: strip_ow ( s1 ); sstd :: printn ( s1 ); std :: string s2 = \"---a-b-c---\" ; sstd :: strip_ow ( s2 , '-' ); sstd :: printn ( s2 ); } Execution result sstd::strip(\" a b c \") = \"a b c\" sstd::strip(\"---a-b-c---\", '-') = \"a-b-c\" s1 = \"a b c\" s2 = \"a-b-c\"","title":"strip()"},{"location":"src/string/strEdit.html#stripall","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: string s = \" a x b x c \" ; sstd :: stripAll_ow ( s , \" x\" ); sstd :: printn ( s ); } Execution result s = \"abc\"","title":"stripAll()"},{"location":"src/string/strEdit.html#implementation","text":"Source: sstd/src/vector/strEdit.cpp Header: sstd/src/vector/strEdit.hpp Test: test/strEdit.hpp","title":"Implementation"},{"location":"src/string/strmatch.html","text":"strmatch Abstract strmatch.hpp contains string comparison functions. strmatch.hpp \u306f\u6587\u5b57\u5217\u6bd4\u8f03\u95a2\u6570\u3092\u53ce\u9332\u3057\u3066\u3044\u307e\u3059\uff0e Header file namespace sstd { bool strcmp ( const char * str1 , const char * str2 ); bool strcmp ( const char * str1 , const std :: string & str2 ); bool strcmp ( const std :: string & str1 , const char * str2 ); bool strcmp ( const std :: string & str1 , const std :: string & str2 ); bool strmatch ( const char * str , const char * wildcard ); bool strmatch ( const char * str , const std :: string & wildcard ); bool strmatch ( const std :: string & str , const char * wildcard ); bool strmatch ( const std :: string & str , const std :: string & wildcard ); bool strmatch_getWC ( const char * str , const char * wildcard , std :: string & retWC ); bool strmatch_getWC ( const char * str , const std :: string & wildcard , std :: string & retWC ); bool strmatch_getWC ( const std :: string & str , const char * wildcard , std :: string & retWC ); bool strmatch_getWC ( const std :: string & str , const std :: string & wildcard , std :: string & retWC ); bool pathmatch ( const char * str , const char * wildcard ); bool pathmatch ( const char * str , const std :: string & wildcard ); bool pathmatch ( const std :: string & str , const char * wildcard ); bool pathmatch ( const std :: string & str , const std :: string & wildcard ); bool isNum ( const char rhs ); bool isNum ( const char * rhs ); bool isNum ( const std :: string & rhs ); bool isAlphabet ( const char rhs ); bool isAlphabet ( const char * rhs ); bool isAlphabet ( const std :: string & rhs ); bool isAlphabet_upper ( const char rhs ); bool isAlphabet_upper ( const char * rhs ); bool isAlphabet_upper ( const std :: string & rhs ); bool isAlphabet_lower ( const char rhs ); bool isAlphabet_lower ( const char * rhs ); bool isAlphabet_lower ( const std :: string & rhs ); bool charIn ( const char lhs , const char * rhs ); // Is lhs in rhs ? bool charIn ( const char lhs , const std :: string & rhs ); // Is lhs in rhs ? bool charIn ( const char * lhs , const char * rhs ); // Is lhs in rhs ? bool charIn ( const char * lhs , const std :: string & rhs ); // Is lhs in rhs ? bool charIn ( const std :: string & lhs , const char * rhs ); // Is lhs in rhs ? bool charIn ( const std :: string & lhs , const std :: string & rhs ); // Is lhs in rhs ? bool charIn_all ( const char * lhs , const char * rhs ); // Is all lhs char(s) in rhs ? bool charIn_all ( const char * lhs , const std :: string & rhs ); // Is all lhs char(s) in rhs ? bool charIn_all ( const std :: string & lhs , const char * rhs ); // Is all lhs char(s) in rhs ? bool charIn_all ( const std :: string & lhs , const std :: string & rhs ); // Is all lhs char(s) in rhs ? bool strIn ( const char * lhs , const char * rhs ); // is lhs in rhs ? (is rhs include lhs ?) bool strIn ( const char * lhs , const std :: string & rhs ); bool strIn ( const std :: string & lhs , const char * rhs ); bool strIn ( const std :: string & lhs , const std :: string & rhs ); } Description Function name Description strcmp() A function that compares whether two input strings exactly the same or not. When two arguments of strings are exactly the same, true is returned. Otherwise false is returned. 2 \u3064\u306e\u5165\u529b\u5f15\u6570\u304c\u5b8c\u5168\u306b\u4e00\u81f4\u3059\u308b\u304b\u3069\u3046\u304b\u5224\u5b9a\u3059\u308b\u95a2\u6570\uff0e2 \u3064\u306e\u5165\u529b\u5f15\u6570\u304c\u5b8c\u5168\u306b\u4e00\u81f4\u3059\u308b\u5834\u5408\u306f\uff0ctrue \u3092\uff0c\u305d\u308c\u4ee5\u5916\u306f false \u3092\u8fd4\u3057\u307e\u3059\uff0e strmatch() A function that judges whether a string and a string using wildcard are considered equivalent or not. When a string of 1st argument and a string of the 2nd argument can use wildcard considered equivalent, true is returned. Otherwise false is returned. Characters of * or ? can use as wildcards. \u6587\u5b57\u5217\u3068\u30ef\u30a4\u30eb\u30c9\u30ab\u30fc\u30c9\u4ed8\u304d\u6587\u5b57\u5217\u304c\u7b49\u4fa1\u3068\u898b\u306a\u305b\u308b\u304b\u5224\u5b9a\u3059\u308b\u95a2\u6570\uff0e\u7b2c\u4e00\u5f15\u6570\u306e\u6587\u5b57\u5217\u3068\uff0c\u30ef\u30a4\u30eb\u30c9\u30ab\u30fc\u30c9\u3092\u4f7f\u3048\u308b\u7b2c\u4e8c\u5f15\u6570\u306e\u6587\u5b57\u5217\u304c\u7b49\u4fa1\u3068\u898b\u306a\u305b\u308b\u5834\u5408\u306f\uff0ctrue \u3092\uff0c\u305d\u308c\u4ee5\u5916\u306f false \u3092\u8fd4\u3057\u307e\u3059\uff0e\u307e\u305f\uff0cwildcard \u306b\u306f\uff0c * \u3068 ? \u3092\u4f7f\u3046\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e strmatch_getWC() A function to get a substring indicated by a wildcard. The 3rd argument will return the substring of the 1st argument that matches for the wildcard ( * or ? ) of the 2nd argument. The other handlings work the same as strmatch() . \u30ef\u30a4\u30eb\u30c9\u30ab\u30fc\u30c9\u304c\u793a\u3059\u90e8\u5206\u6587\u5b57\u5217\u3092\u53d6\u5f97\u3059\u308b\u95a2\u6570\uff0e\u7b2c\u4e09\u5f15\u6570\u306f\uff0c\u7b2c\u4e00\u5f15\u6570\u306e\u6587\u5b57\u5217\u306e\u5185\uff0c\u7b2c\u4e8c\u5f15\u6570\u306e wildcard ( * \u307e\u305f\u306f ? ) \u3068\u4e00\u81f4\u3059\u308b\u90e8\u5206\u3092\u8fd4\u5374\u3057\u307e\u3059\uff0e\u305d\u308c\u4ee5\u5916\u306f\uff0c strmatch() \u3068\u540c\u69d8\u306b\u52d5\u4f5c\u3057\u307e\u3059\uff0e pathmatch() A function that judges whether a path string and a path string using wildcard are considered equivalent or not. The splitter string ( / or \\\\ ) cannot be excluded with wildcards. The other handlings work the same as strmatch() . \u30d1\u30b9\u306e\u6bd4\u8f03\u7528\u95a2\u6570\uff0e\u30b9\u30d7\u30ea\u30c3\u30bf\u3068\u306a\u308b\u6587\u5b57\u5217 ( / \u307e\u305f\u306f \\\\ ) \u304c wildcard \u306b\u3088\u308b\u9664\u5916\u3092\u53d7\u4ed8\u307e\u305b\u3093\uff0e\u305d\u308c\u4ee5\u5916\u306f\uff0c strmatch() \u3068\u540c\u69d8\u306b\u52d5\u4f5c\u3057\u307e\u3059\uff0e isNum() A function that judges whether a whole string is configured by numerical string or not. When all the character or string of the 1st argument is in the range of 0 to 9 as a ASCII Code, true is returned. Otherwise false is returned. \u5168\u3066\u306e\u6587\u5b57\u5217\u304c\u6570\u5024\u3067\u69cb\u6210\u3055\u308c\u3066\u3044\u308b\u304b\u5224\u5b9a\u3059\u308b\u95a2\u6570\uff0e\u7b2c\u4e00\u5f15\u6570\u306b\u6e21\u3055\u308c\u308b\u5168\u3066\u306e\u6587\u5b57\u307e\u305f\u306f\u6587\u5b57\u5217\u304c ASCII Code \u3067\u306e 0 ~ 9 \u306e\u7bc4\u56f2\u306b\u3042\u308b\u5834\u5408\u306f\uff0ctrue \u3092\uff0c\u305d\u308c\u4ee5\u5916\u306f false \u3092\u8fd4\u3057\u307e\u3059\uff0e isAlphabet() A function that judges whether a whole string is configured by alphabet or not. When a character or whole string of the 1st argument are in the range of A to Z or a to z as a ASCII Code, true is returned. Otherwise false is returned. \u5168\u3066\u306e\u6587\u5b57\u5217\u304c\u30a2\u30eb\u30d5\u30a1\u30d9\u30c3\u30c8\u3067\u69cb\u6210\u3055\u308c\u3066\u3044\u308b\u304b\u5224\u5b9a\u3059\u308b\u95a2\u6570\uff0e\u7b2c\u4e00\u5f15\u6570\u306b\u6e21\u3055\u308c\u305f\u5168\u3066\u306e\u6587\u5b57\u307e\u305f\u306f\u6587\u5b57\u5217\u304c ASCII Code \u3067\u306e A ~ Z \u307e\u305f\u306f a ~ z \u306e\u7bc4\u56f2\u306b\u3042\u308b\u5834\u5408\u306f\uff0ctrue \u3092\uff0c\u305d\u308c\u4ee5\u5916\u306f false \u3092\u8fd4\u3057\u307e\u3059\uff0e isAlphabet_upper() A function that judges whether a whole string is configured by uppercase or not. When all the character or string of the 1st argument is in the range of A to Z as a ASCII Code, true is returned. Otherwise false is returned. \u5168\u3066\u306e\u6587\u5b57\u5217\u304c\u5927\u6587\u5b57\u306e\u30a2\u30eb\u30d5\u30a1\u30d9\u30c3\u30c8\u3067\u69cb\u6210\u3055\u308c\u3066\u3044\u308b\u304b\u5224\u5b9a\u3059\u308b\u95a2\u6570\uff0e\u7b2c\u4e00\u5f15\u6570\u306b\u6e21\u3055\u308c\u305f\u5168\u3066\u306e\u6587\u5b57\u307e\u305f\u306f\u6587\u5b57\u5217\u304c ASCII Code \u3067\u306e A ~ Z \u306e\u7bc4\u56f2\u306b\u3042\u308b\u5834\u5408\u306f\uff0ctrue \u3092\uff0c\u305d\u308c\u4ee5\u5916\u306f false \u3092\u8fd4\u3057\u307e\u3059\uff0e isAlphabet_lower() A function that judges whether a whole string is configured by lowercase or not. When all the character or string of the 1st argument is in the range of a to z as a ASCII Code, true is returned. Otherwise false is returned. \u5168\u3066\u306e\u6587\u5b57\u5217\u304c\u5c0f\u6587\u5b57\u306e\u30a2\u30eb\u30d5\u30a1\u30d9\u30c3\u30c8\u3067\u69cb\u6210\u3055\u308c\u3066\u3044\u308b\u304b\u5224\u5b9a\u3059\u308b\u95a2\u6570\uff0e\u7b2c\u4e00\u5f15\u6570\u306b\u6e21\u3055\u308c\u305f\u5168\u3066\u306e\u6587\u5b57\u307e\u305f\u306f\u6587\u5b57\u5217\u304c ASCII Code \u3067\u306e a ~ z \u306e\u7bc4\u56f2\u306b\u3042\u308b\u5834\u5408\u306f\uff0ctrue \u3092\uff0c\u305d\u308c\u4ee5\u5916\u306f false \u3092\u8fd4\u3057\u307e\u3059\uff0e charIn() A function that judges whether a particular character is included in a string or not. When the character of the 1st argument is included in the string of the 2nd argument, true is returned. Otherwise false is returned. \u7279\u5b9a\u306e\u6587\u5b57\u3092\u5185\u5305\u3059\u308b\u304b\u5224\u5b9a\u3059\u308b\u95a2\u6570\uff0e\u7b2c\u4e00\u5f15\u6570\u306e\u6587\u5b57\u304c\uff0c\u7b2c\u4e8c\u5f15\u6570\u306e\u6587\u5b57\u5217\u306b\u542b\u307e\u308c\u308b\u5834\u5408\u306f\uff0ctrue \u3092\uff0c\u305d\u308c\u4ee5\u5916\u306f false \u3092\u8fd4\u3057\u307e\u3059\uff0e charIn_all() A function that judges whether all of particular character is included in a string or not. When the character of the 1st argument is included in the string of the 2nd argument, true is returned. Otherwise false is returned. \u7279\u5b9a\u306e\u6587\u5b57\u3092\u5168\u3066\u5185\u5305\u3059\u308b\u304b\u5224\u5b9a\u3059\u308b\u95a2\u6570\uff0e\u7b2c\u4e00\u5f15\u6570\u306e\u6587\u5b57\u304c\uff0c\u7b2c\u4e8c\u5f15\u6570\u306e\u6587\u5b57\u5217\u306b\u542b\u307e\u308c\u308b\u5834\u5408\u306f\uff0ctrue \u3092\uff0c\u305d\u308c\u4ee5\u5916\u306f false \u3092\u8fd4\u3057\u307e\u3059\uff0e strIn() A function that judges whether a particular string is included in a string or not. When the string of the 1st argument is included in the string of the 2nd argument, true is returned. Otherwise false is returned. \u7279\u5b9a\u306e\u6587\u5b57\u5217\u3092\u5185\u5305\u3059\u308b\u304b\u5224\u5b9a\u3059\u308b\u95a2\u6570\uff0e\u7b2c\u4e00\u5f15\u6570\u306e\u6587\u5b57\u5217\u304c\uff0c\u7b2c\u4e8c\u5f15\u6570\u306e\u6587\u5b57\u5217\u306b\u542b\u307e\u308c\u308b\u5834\u5408\u306f\uff0ctrue \u3092\uff0c\u305d\u308c\u4ee5\u5916\u306f false \u3092\u8fd4\u3057\u307e\u3059\uff0e Usage strcmp() main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: strcmp ( \"abc def\" , \"abc def\" ) ); sstd :: printn ( sstd :: strcmp ( \"abc def\" , \"abc ef\" ) ); } Execution result sstd::strcmp(\"abc def\", \"abc def\") = true sstd::strcmp(\"abc def\", \"abc ef\") = false strmatch(), strmatch_getWC() main.cpp #include <sstd/sstd.hpp> int main (){ std :: string s = \"TOKYOTO...\" ; sstd :: printn ( sstd :: strmatch ( s , \"??KYOTO*\" ) ); std :: string ret ; sstd :: printn ( sstd :: strmatch_getWC ( s , \"TO*...\" , ret ) ); sstd :: printn ( ret ); } Execution result sstd::strmatch(s, \"??KYOTO*\") = true sstd::strmatch_getWC(s, \"TO*...\", ret) = true ret = \"KYOTO\" pathmatch() main.cpp #include <sstd/sstd.hpp> int main (){ std :: string s = \"/a/b/c/example.txt\" ; sstd :: printn ( sstd :: pathmatch ( s , \"/*/*/*/*.txt\" ) ); sstd :: printn ( sstd :: pathmatch ( s , \"/*/*/*.txt\" ) ); } Execution result sstd::pathmatch(s, \"/*/*/*/*.txt\") = true sstd::pathmatch(s, \"/*/*/*.txt\") = false isNum() main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: isNum ( '0' ) ); sstd :: printn ( sstd :: isNum ( 'A' ) ); sstd :: printn ( sstd :: isNum ( 'a' ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isNum ( \"0123456789\" ) ); sstd :: printn ( sstd :: isNum ( \"012345678a\" ) ); sstd :: printn ( sstd :: isNum ( \"abcdeABCDE\" ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isNum ( std :: string ( \"0123456789\" )) ); sstd :: printn ( sstd :: isNum ( std :: string ( \"012345678a\" )) ); sstd :: printn ( sstd :: isNum ( std :: string ( \"abcdeABCDE\" )) ); printf ( \" \\n \" ); } Execution result sstd::isNum('0') = true sstd::isNum('A') = false sstd::isNum('a') = false sstd::isNum(\"0123456789\") = true sstd::isNum(\"012345678a\") = false sstd::isNum(\"abcdeABCDE\") = false sstd::isNum(std::string(\"0123456789\")) = true sstd::isNum(std::string(\"012345678a\")) = false sstd::isNum(std::string(\"abcdeABCDE\")) = false isAlphabet() main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: isAlphabet ( '0' ) ); sstd :: printn ( sstd :: isAlphabet ( 'A' ) ); sstd :: printn ( sstd :: isAlphabet ( 'a' ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isAlphabet ( \"0123456789\" ) ); sstd :: printn ( sstd :: isAlphabet ( \"ABCDEFTGI9\" ) ); sstd :: printn ( sstd :: isAlphabet ( \"abcdeABCDE\" ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isAlphabet ( std :: string ( \"0123456789\" )) ); sstd :: printn ( sstd :: isAlphabet ( std :: string ( \"ABCDEFTGI9\" )) ); sstd :: printn ( sstd :: isAlphabet ( std :: string ( \"abcdeABCDE\" )) ); printf ( \" \\n \" ); } Execution result sstd::isAlphabet('0') = false sstd::isAlphabet('A') = true sstd::isAlphabet('a') = true sstd::isAlphabet(\"0123456789\") = false sstd::isAlphabet(\"ABCDEFTGI9\") = false sstd::isAlphabet(\"abcdeABCDE\") = true sstd::isAlphabet(std::string(\"0123456789\")) = false sstd::isAlphabet(std::string(\"ABCDEFTGI9\")) = false sstd::isAlphabet(std::string(\"abcdeABCDE\")) = true isAlphabet_upper() main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: isAlphabet_upper ( '0' ) ); sstd :: printn ( sstd :: isAlphabet_upper ( 'A' ) ); sstd :: printn ( sstd :: isAlphabet_upper ( 'a' ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isAlphabet_upper ( \"0123456789\" ) ); sstd :: printn ( sstd :: isAlphabet_upper ( \"ABCDEFGHIJ\" ) ); sstd :: printn ( sstd :: isAlphabet_upper ( \"abcdeABCDE\" ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isAlphabet_upper ( std :: string ( \"0123456789\" )) ); sstd :: printn ( sstd :: isAlphabet_upper ( std :: string ( \"ABCDEFGHIJ\" )) ); sstd :: printn ( sstd :: isAlphabet_upper ( std :: string ( \"abcdeABCDE\" )) ); printf ( \" \\n \" ); } Execution result sstd::isAlphabet_upper('0') = false sstd::isAlphabet_upper('A') = true sstd::isAlphabet_upper('a') = false sstd::isAlphabet_upper(\"0123456789\") = false sstd::isAlphabet_upper(\"ABCDEFGHIJ\") = true sstd::isAlphabet_upper(\"abcdeABCDE\") = false sstd::isAlphabet_upper(std::string(\"0123456789\")) = false sstd::isAlphabet_upper(std::string(\"ABCDEFGHIJ\")) = true sstd::isAlphabet_upper(std::string(\"abcdeABCDE\")) = false isAlphabet_lower() main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: isAlphabet_lower ( '0' ) ); sstd :: printn ( sstd :: isAlphabet_lower ( 'A' ) ); sstd :: printn ( sstd :: isAlphabet_lower ( 'a' ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isAlphabet_lower ( \"0123456789\" ) ); sstd :: printn ( sstd :: isAlphabet_lower ( \"abcdeABCDE\" ) ); sstd :: printn ( sstd :: isAlphabet_lower ( \"abcdefghij\" ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isAlphabet_lower ( std :: string ( \"0123456789\" )) ); sstd :: printn ( sstd :: isAlphabet_lower ( std :: string ( \"abcdeABCDE\" )) ); sstd :: printn ( sstd :: isAlphabet_lower ( std :: string ( \"abcdefghij\" )) ); printf ( \" \\n \" ); } Execution result sstd::isAlphabet_lower('0') = false sstd::isAlphabet_lower('A') = false sstd::isAlphabet_lower('a') = true sstd::isAlphabet_lower(\"0123456789\") = false sstd::isAlphabet_lower(\"abcdeABCDE\") = false sstd::isAlphabet_lower(\"abcdefghij\") = true sstd::isAlphabet_lower(std::string(\"0123456789\")) = false sstd::isAlphabet_lower(std::string(\"abcdeABCDE\")) = false sstd::isAlphabet_lower(std::string(\"abcdefghij\")) = true charIn() main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: charIn ( 'c' , \"abcdef\" ) ); // 'c' exists in \"abcdef\". sstd :: printn ( sstd :: charIn ( \"abc\" , \"abcdef\" ) ); // 'a', 'b' or 'c' exist in \"abcdef\". sstd :: printn ( sstd :: charIn_all ( \"abx\" , \"abcdef\" ) ); // 'x' dose not exist in \"abcdef\". sstd :: printn ( sstd :: charIn_all ( \"cba\" , \"abcdef\" ) ); // 'a', 'b' and 'c' exist in \"abcdef\". } Execution result sstd::charIn('c', \"abcdef\") = true sstd::charIn(\"abc\", \"abcdef\") = true sstd::charIn_all(\"abx\", \"abcdef\") = false sstd::charIn_all(\"cba\", \"abcdef\") = true strIn() main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: strIn ( \"def\" , \"abcdefgh\" ) ); sstd :: printn ( sstd :: strIn ( \"defx\" , \"abcdefgh\" ) ); } Execution result sstd::strIn(\"def\", \"abcdefgh\") = true sstd::strIn(\"defx\", \"abcdefgh\") = false Implementation Source: sstd/src/string/strmatch.cpp Header: sstd/src/string/strmatch.hpp Test: test/string/strmatch.hpp","title":"strmatch"},{"location":"src/string/strmatch.html#strmatch","text":"","title":"strmatch"},{"location":"src/string/strmatch.html#abstract","text":"strmatch.hpp contains string comparison functions. strmatch.hpp \u306f\u6587\u5b57\u5217\u6bd4\u8f03\u95a2\u6570\u3092\u53ce\u9332\u3057\u3066\u3044\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/string/strmatch.html#header-file","text":"namespace sstd { bool strcmp ( const char * str1 , const char * str2 ); bool strcmp ( const char * str1 , const std :: string & str2 ); bool strcmp ( const std :: string & str1 , const char * str2 ); bool strcmp ( const std :: string & str1 , const std :: string & str2 ); bool strmatch ( const char * str , const char * wildcard ); bool strmatch ( const char * str , const std :: string & wildcard ); bool strmatch ( const std :: string & str , const char * wildcard ); bool strmatch ( const std :: string & str , const std :: string & wildcard ); bool strmatch_getWC ( const char * str , const char * wildcard , std :: string & retWC ); bool strmatch_getWC ( const char * str , const std :: string & wildcard , std :: string & retWC ); bool strmatch_getWC ( const std :: string & str , const char * wildcard , std :: string & retWC ); bool strmatch_getWC ( const std :: string & str , const std :: string & wildcard , std :: string & retWC ); bool pathmatch ( const char * str , const char * wildcard ); bool pathmatch ( const char * str , const std :: string & wildcard ); bool pathmatch ( const std :: string & str , const char * wildcard ); bool pathmatch ( const std :: string & str , const std :: string & wildcard ); bool isNum ( const char rhs ); bool isNum ( const char * rhs ); bool isNum ( const std :: string & rhs ); bool isAlphabet ( const char rhs ); bool isAlphabet ( const char * rhs ); bool isAlphabet ( const std :: string & rhs ); bool isAlphabet_upper ( const char rhs ); bool isAlphabet_upper ( const char * rhs ); bool isAlphabet_upper ( const std :: string & rhs ); bool isAlphabet_lower ( const char rhs ); bool isAlphabet_lower ( const char * rhs ); bool isAlphabet_lower ( const std :: string & rhs ); bool charIn ( const char lhs , const char * rhs ); // Is lhs in rhs ? bool charIn ( const char lhs , const std :: string & rhs ); // Is lhs in rhs ? bool charIn ( const char * lhs , const char * rhs ); // Is lhs in rhs ? bool charIn ( const char * lhs , const std :: string & rhs ); // Is lhs in rhs ? bool charIn ( const std :: string & lhs , const char * rhs ); // Is lhs in rhs ? bool charIn ( const std :: string & lhs , const std :: string & rhs ); // Is lhs in rhs ? bool charIn_all ( const char * lhs , const char * rhs ); // Is all lhs char(s) in rhs ? bool charIn_all ( const char * lhs , const std :: string & rhs ); // Is all lhs char(s) in rhs ? bool charIn_all ( const std :: string & lhs , const char * rhs ); // Is all lhs char(s) in rhs ? bool charIn_all ( const std :: string & lhs , const std :: string & rhs ); // Is all lhs char(s) in rhs ? bool strIn ( const char * lhs , const char * rhs ); // is lhs in rhs ? (is rhs include lhs ?) bool strIn ( const char * lhs , const std :: string & rhs ); bool strIn ( const std :: string & lhs , const char * rhs ); bool strIn ( const std :: string & lhs , const std :: string & rhs ); }","title":"Header file"},{"location":"src/string/strmatch.html#description","text":"Function name Description strcmp() A function that compares whether two input strings exactly the same or not. When two arguments of strings are exactly the same, true is returned. Otherwise false is returned. 2 \u3064\u306e\u5165\u529b\u5f15\u6570\u304c\u5b8c\u5168\u306b\u4e00\u81f4\u3059\u308b\u304b\u3069\u3046\u304b\u5224\u5b9a\u3059\u308b\u95a2\u6570\uff0e2 \u3064\u306e\u5165\u529b\u5f15\u6570\u304c\u5b8c\u5168\u306b\u4e00\u81f4\u3059\u308b\u5834\u5408\u306f\uff0ctrue \u3092\uff0c\u305d\u308c\u4ee5\u5916\u306f false \u3092\u8fd4\u3057\u307e\u3059\uff0e strmatch() A function that judges whether a string and a string using wildcard are considered equivalent or not. When a string of 1st argument and a string of the 2nd argument can use wildcard considered equivalent, true is returned. Otherwise false is returned. Characters of * or ? can use as wildcards. \u6587\u5b57\u5217\u3068\u30ef\u30a4\u30eb\u30c9\u30ab\u30fc\u30c9\u4ed8\u304d\u6587\u5b57\u5217\u304c\u7b49\u4fa1\u3068\u898b\u306a\u305b\u308b\u304b\u5224\u5b9a\u3059\u308b\u95a2\u6570\uff0e\u7b2c\u4e00\u5f15\u6570\u306e\u6587\u5b57\u5217\u3068\uff0c\u30ef\u30a4\u30eb\u30c9\u30ab\u30fc\u30c9\u3092\u4f7f\u3048\u308b\u7b2c\u4e8c\u5f15\u6570\u306e\u6587\u5b57\u5217\u304c\u7b49\u4fa1\u3068\u898b\u306a\u305b\u308b\u5834\u5408\u306f\uff0ctrue \u3092\uff0c\u305d\u308c\u4ee5\u5916\u306f false \u3092\u8fd4\u3057\u307e\u3059\uff0e\u307e\u305f\uff0cwildcard \u306b\u306f\uff0c * \u3068 ? \u3092\u4f7f\u3046\u3053\u3068\u304c\u3067\u304d\u307e\u3059\uff0e strmatch_getWC() A function to get a substring indicated by a wildcard. The 3rd argument will return the substring of the 1st argument that matches for the wildcard ( * or ? ) of the 2nd argument. The other handlings work the same as strmatch() . \u30ef\u30a4\u30eb\u30c9\u30ab\u30fc\u30c9\u304c\u793a\u3059\u90e8\u5206\u6587\u5b57\u5217\u3092\u53d6\u5f97\u3059\u308b\u95a2\u6570\uff0e\u7b2c\u4e09\u5f15\u6570\u306f\uff0c\u7b2c\u4e00\u5f15\u6570\u306e\u6587\u5b57\u5217\u306e\u5185\uff0c\u7b2c\u4e8c\u5f15\u6570\u306e wildcard ( * \u307e\u305f\u306f ? ) \u3068\u4e00\u81f4\u3059\u308b\u90e8\u5206\u3092\u8fd4\u5374\u3057\u307e\u3059\uff0e\u305d\u308c\u4ee5\u5916\u306f\uff0c strmatch() \u3068\u540c\u69d8\u306b\u52d5\u4f5c\u3057\u307e\u3059\uff0e pathmatch() A function that judges whether a path string and a path string using wildcard are considered equivalent or not. The splitter string ( / or \\\\ ) cannot be excluded with wildcards. The other handlings work the same as strmatch() . \u30d1\u30b9\u306e\u6bd4\u8f03\u7528\u95a2\u6570\uff0e\u30b9\u30d7\u30ea\u30c3\u30bf\u3068\u306a\u308b\u6587\u5b57\u5217 ( / \u307e\u305f\u306f \\\\ ) \u304c wildcard \u306b\u3088\u308b\u9664\u5916\u3092\u53d7\u4ed8\u307e\u305b\u3093\uff0e\u305d\u308c\u4ee5\u5916\u306f\uff0c strmatch() \u3068\u540c\u69d8\u306b\u52d5\u4f5c\u3057\u307e\u3059\uff0e isNum() A function that judges whether a whole string is configured by numerical string or not. When all the character or string of the 1st argument is in the range of 0 to 9 as a ASCII Code, true is returned. Otherwise false is returned. \u5168\u3066\u306e\u6587\u5b57\u5217\u304c\u6570\u5024\u3067\u69cb\u6210\u3055\u308c\u3066\u3044\u308b\u304b\u5224\u5b9a\u3059\u308b\u95a2\u6570\uff0e\u7b2c\u4e00\u5f15\u6570\u306b\u6e21\u3055\u308c\u308b\u5168\u3066\u306e\u6587\u5b57\u307e\u305f\u306f\u6587\u5b57\u5217\u304c ASCII Code \u3067\u306e 0 ~ 9 \u306e\u7bc4\u56f2\u306b\u3042\u308b\u5834\u5408\u306f\uff0ctrue \u3092\uff0c\u305d\u308c\u4ee5\u5916\u306f false \u3092\u8fd4\u3057\u307e\u3059\uff0e isAlphabet() A function that judges whether a whole string is configured by alphabet or not. When a character or whole string of the 1st argument are in the range of A to Z or a to z as a ASCII Code, true is returned. Otherwise false is returned. \u5168\u3066\u306e\u6587\u5b57\u5217\u304c\u30a2\u30eb\u30d5\u30a1\u30d9\u30c3\u30c8\u3067\u69cb\u6210\u3055\u308c\u3066\u3044\u308b\u304b\u5224\u5b9a\u3059\u308b\u95a2\u6570\uff0e\u7b2c\u4e00\u5f15\u6570\u306b\u6e21\u3055\u308c\u305f\u5168\u3066\u306e\u6587\u5b57\u307e\u305f\u306f\u6587\u5b57\u5217\u304c ASCII Code \u3067\u306e A ~ Z \u307e\u305f\u306f a ~ z \u306e\u7bc4\u56f2\u306b\u3042\u308b\u5834\u5408\u306f\uff0ctrue \u3092\uff0c\u305d\u308c\u4ee5\u5916\u306f false \u3092\u8fd4\u3057\u307e\u3059\uff0e isAlphabet_upper() A function that judges whether a whole string is configured by uppercase or not. When all the character or string of the 1st argument is in the range of A to Z as a ASCII Code, true is returned. Otherwise false is returned. \u5168\u3066\u306e\u6587\u5b57\u5217\u304c\u5927\u6587\u5b57\u306e\u30a2\u30eb\u30d5\u30a1\u30d9\u30c3\u30c8\u3067\u69cb\u6210\u3055\u308c\u3066\u3044\u308b\u304b\u5224\u5b9a\u3059\u308b\u95a2\u6570\uff0e\u7b2c\u4e00\u5f15\u6570\u306b\u6e21\u3055\u308c\u305f\u5168\u3066\u306e\u6587\u5b57\u307e\u305f\u306f\u6587\u5b57\u5217\u304c ASCII Code \u3067\u306e A ~ Z \u306e\u7bc4\u56f2\u306b\u3042\u308b\u5834\u5408\u306f\uff0ctrue \u3092\uff0c\u305d\u308c\u4ee5\u5916\u306f false \u3092\u8fd4\u3057\u307e\u3059\uff0e isAlphabet_lower() A function that judges whether a whole string is configured by lowercase or not. When all the character or string of the 1st argument is in the range of a to z as a ASCII Code, true is returned. Otherwise false is returned. \u5168\u3066\u306e\u6587\u5b57\u5217\u304c\u5c0f\u6587\u5b57\u306e\u30a2\u30eb\u30d5\u30a1\u30d9\u30c3\u30c8\u3067\u69cb\u6210\u3055\u308c\u3066\u3044\u308b\u304b\u5224\u5b9a\u3059\u308b\u95a2\u6570\uff0e\u7b2c\u4e00\u5f15\u6570\u306b\u6e21\u3055\u308c\u305f\u5168\u3066\u306e\u6587\u5b57\u307e\u305f\u306f\u6587\u5b57\u5217\u304c ASCII Code \u3067\u306e a ~ z \u306e\u7bc4\u56f2\u306b\u3042\u308b\u5834\u5408\u306f\uff0ctrue \u3092\uff0c\u305d\u308c\u4ee5\u5916\u306f false \u3092\u8fd4\u3057\u307e\u3059\uff0e charIn() A function that judges whether a particular character is included in a string or not. When the character of the 1st argument is included in the string of the 2nd argument, true is returned. Otherwise false is returned. \u7279\u5b9a\u306e\u6587\u5b57\u3092\u5185\u5305\u3059\u308b\u304b\u5224\u5b9a\u3059\u308b\u95a2\u6570\uff0e\u7b2c\u4e00\u5f15\u6570\u306e\u6587\u5b57\u304c\uff0c\u7b2c\u4e8c\u5f15\u6570\u306e\u6587\u5b57\u5217\u306b\u542b\u307e\u308c\u308b\u5834\u5408\u306f\uff0ctrue \u3092\uff0c\u305d\u308c\u4ee5\u5916\u306f false \u3092\u8fd4\u3057\u307e\u3059\uff0e charIn_all() A function that judges whether all of particular character is included in a string or not. When the character of the 1st argument is included in the string of the 2nd argument, true is returned. Otherwise false is returned. \u7279\u5b9a\u306e\u6587\u5b57\u3092\u5168\u3066\u5185\u5305\u3059\u308b\u304b\u5224\u5b9a\u3059\u308b\u95a2\u6570\uff0e\u7b2c\u4e00\u5f15\u6570\u306e\u6587\u5b57\u304c\uff0c\u7b2c\u4e8c\u5f15\u6570\u306e\u6587\u5b57\u5217\u306b\u542b\u307e\u308c\u308b\u5834\u5408\u306f\uff0ctrue \u3092\uff0c\u305d\u308c\u4ee5\u5916\u306f false \u3092\u8fd4\u3057\u307e\u3059\uff0e strIn() A function that judges whether a particular string is included in a string or not. When the string of the 1st argument is included in the string of the 2nd argument, true is returned. Otherwise false is returned. \u7279\u5b9a\u306e\u6587\u5b57\u5217\u3092\u5185\u5305\u3059\u308b\u304b\u5224\u5b9a\u3059\u308b\u95a2\u6570\uff0e\u7b2c\u4e00\u5f15\u6570\u306e\u6587\u5b57\u5217\u304c\uff0c\u7b2c\u4e8c\u5f15\u6570\u306e\u6587\u5b57\u5217\u306b\u542b\u307e\u308c\u308b\u5834\u5408\u306f\uff0ctrue \u3092\uff0c\u305d\u308c\u4ee5\u5916\u306f false \u3092\u8fd4\u3057\u307e\u3059\uff0e","title":"Description"},{"location":"src/string/strmatch.html#usage","text":"","title":"Usage"},{"location":"src/string/strmatch.html#strcmp","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: strcmp ( \"abc def\" , \"abc def\" ) ); sstd :: printn ( sstd :: strcmp ( \"abc def\" , \"abc ef\" ) ); } Execution result sstd::strcmp(\"abc def\", \"abc def\") = true sstd::strcmp(\"abc def\", \"abc ef\") = false","title":"strcmp()"},{"location":"src/string/strmatch.html#strmatch-strmatch_getwc","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: string s = \"TOKYOTO...\" ; sstd :: printn ( sstd :: strmatch ( s , \"??KYOTO*\" ) ); std :: string ret ; sstd :: printn ( sstd :: strmatch_getWC ( s , \"TO*...\" , ret ) ); sstd :: printn ( ret ); } Execution result sstd::strmatch(s, \"??KYOTO*\") = true sstd::strmatch_getWC(s, \"TO*...\", ret) = true ret = \"KYOTO\"","title":"strmatch(), strmatch_getWC()"},{"location":"src/string/strmatch.html#pathmatch","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: string s = \"/a/b/c/example.txt\" ; sstd :: printn ( sstd :: pathmatch ( s , \"/*/*/*/*.txt\" ) ); sstd :: printn ( sstd :: pathmatch ( s , \"/*/*/*.txt\" ) ); } Execution result sstd::pathmatch(s, \"/*/*/*/*.txt\") = true sstd::pathmatch(s, \"/*/*/*.txt\") = false","title":"pathmatch()"},{"location":"src/string/strmatch.html#isnum","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: isNum ( '0' ) ); sstd :: printn ( sstd :: isNum ( 'A' ) ); sstd :: printn ( sstd :: isNum ( 'a' ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isNum ( \"0123456789\" ) ); sstd :: printn ( sstd :: isNum ( \"012345678a\" ) ); sstd :: printn ( sstd :: isNum ( \"abcdeABCDE\" ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isNum ( std :: string ( \"0123456789\" )) ); sstd :: printn ( sstd :: isNum ( std :: string ( \"012345678a\" )) ); sstd :: printn ( sstd :: isNum ( std :: string ( \"abcdeABCDE\" )) ); printf ( \" \\n \" ); } Execution result sstd::isNum('0') = true sstd::isNum('A') = false sstd::isNum('a') = false sstd::isNum(\"0123456789\") = true sstd::isNum(\"012345678a\") = false sstd::isNum(\"abcdeABCDE\") = false sstd::isNum(std::string(\"0123456789\")) = true sstd::isNum(std::string(\"012345678a\")) = false sstd::isNum(std::string(\"abcdeABCDE\")) = false","title":"isNum()"},{"location":"src/string/strmatch.html#isalphabet","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: isAlphabet ( '0' ) ); sstd :: printn ( sstd :: isAlphabet ( 'A' ) ); sstd :: printn ( sstd :: isAlphabet ( 'a' ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isAlphabet ( \"0123456789\" ) ); sstd :: printn ( sstd :: isAlphabet ( \"ABCDEFTGI9\" ) ); sstd :: printn ( sstd :: isAlphabet ( \"abcdeABCDE\" ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isAlphabet ( std :: string ( \"0123456789\" )) ); sstd :: printn ( sstd :: isAlphabet ( std :: string ( \"ABCDEFTGI9\" )) ); sstd :: printn ( sstd :: isAlphabet ( std :: string ( \"abcdeABCDE\" )) ); printf ( \" \\n \" ); } Execution result sstd::isAlphabet('0') = false sstd::isAlphabet('A') = true sstd::isAlphabet('a') = true sstd::isAlphabet(\"0123456789\") = false sstd::isAlphabet(\"ABCDEFTGI9\") = false sstd::isAlphabet(\"abcdeABCDE\") = true sstd::isAlphabet(std::string(\"0123456789\")) = false sstd::isAlphabet(std::string(\"ABCDEFTGI9\")) = false sstd::isAlphabet(std::string(\"abcdeABCDE\")) = true","title":"isAlphabet()"},{"location":"src/string/strmatch.html#isalphabet_upper","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: isAlphabet_upper ( '0' ) ); sstd :: printn ( sstd :: isAlphabet_upper ( 'A' ) ); sstd :: printn ( sstd :: isAlphabet_upper ( 'a' ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isAlphabet_upper ( \"0123456789\" ) ); sstd :: printn ( sstd :: isAlphabet_upper ( \"ABCDEFGHIJ\" ) ); sstd :: printn ( sstd :: isAlphabet_upper ( \"abcdeABCDE\" ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isAlphabet_upper ( std :: string ( \"0123456789\" )) ); sstd :: printn ( sstd :: isAlphabet_upper ( std :: string ( \"ABCDEFGHIJ\" )) ); sstd :: printn ( sstd :: isAlphabet_upper ( std :: string ( \"abcdeABCDE\" )) ); printf ( \" \\n \" ); } Execution result sstd::isAlphabet_upper('0') = false sstd::isAlphabet_upper('A') = true sstd::isAlphabet_upper('a') = false sstd::isAlphabet_upper(\"0123456789\") = false sstd::isAlphabet_upper(\"ABCDEFGHIJ\") = true sstd::isAlphabet_upper(\"abcdeABCDE\") = false sstd::isAlphabet_upper(std::string(\"0123456789\")) = false sstd::isAlphabet_upper(std::string(\"ABCDEFGHIJ\")) = true sstd::isAlphabet_upper(std::string(\"abcdeABCDE\")) = false","title":"isAlphabet_upper()"},{"location":"src/string/strmatch.html#isalphabet_lower","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: isAlphabet_lower ( '0' ) ); sstd :: printn ( sstd :: isAlphabet_lower ( 'A' ) ); sstd :: printn ( sstd :: isAlphabet_lower ( 'a' ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isAlphabet_lower ( \"0123456789\" ) ); sstd :: printn ( sstd :: isAlphabet_lower ( \"abcdeABCDE\" ) ); sstd :: printn ( sstd :: isAlphabet_lower ( \"abcdefghij\" ) ); printf ( \" \\n \" ); sstd :: printn ( sstd :: isAlphabet_lower ( std :: string ( \"0123456789\" )) ); sstd :: printn ( sstd :: isAlphabet_lower ( std :: string ( \"abcdeABCDE\" )) ); sstd :: printn ( sstd :: isAlphabet_lower ( std :: string ( \"abcdefghij\" )) ); printf ( \" \\n \" ); } Execution result sstd::isAlphabet_lower('0') = false sstd::isAlphabet_lower('A') = false sstd::isAlphabet_lower('a') = true sstd::isAlphabet_lower(\"0123456789\") = false sstd::isAlphabet_lower(\"abcdeABCDE\") = false sstd::isAlphabet_lower(\"abcdefghij\") = true sstd::isAlphabet_lower(std::string(\"0123456789\")) = false sstd::isAlphabet_lower(std::string(\"abcdeABCDE\")) = false sstd::isAlphabet_lower(std::string(\"abcdefghij\")) = true","title":"isAlphabet_lower()"},{"location":"src/string/strmatch.html#charin","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: charIn ( 'c' , \"abcdef\" ) ); // 'c' exists in \"abcdef\". sstd :: printn ( sstd :: charIn ( \"abc\" , \"abcdef\" ) ); // 'a', 'b' or 'c' exist in \"abcdef\". sstd :: printn ( sstd :: charIn_all ( \"abx\" , \"abcdef\" ) ); // 'x' dose not exist in \"abcdef\". sstd :: printn ( sstd :: charIn_all ( \"cba\" , \"abcdef\" ) ); // 'a', 'b' and 'c' exist in \"abcdef\". } Execution result sstd::charIn('c', \"abcdef\") = true sstd::charIn(\"abc\", \"abcdef\") = true sstd::charIn_all(\"abx\", \"abcdef\") = false sstd::charIn_all(\"cba\", \"abcdef\") = true","title":"charIn()"},{"location":"src/string/strmatch.html#strin","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: strIn ( \"def\" , \"abcdefgh\" ) ); sstd :: printn ( sstd :: strIn ( \"defx\" , \"abcdefgh\" ) ); } Execution result sstd::strIn(\"def\", \"abcdefgh\") = true sstd::strIn(\"defx\", \"abcdefgh\") = false","title":"strIn()"},{"location":"src/string/strmatch.html#implementation","text":"Source: sstd/src/string/strmatch.cpp Header: sstd/src/string/strmatch.hpp Test: test/string/strmatch.hpp","title":"Implementation"},{"location":"src/sys/pause.html","text":"pause Abstract pause waits until Enter is pressed. Header file namespace sstd { void pause (); } Description Function name Description pause() waits until Enter is pressed. Enter \u304c\u62bc\u3055\u308c\u308b\u307e\u3067\u5f85\u6a5f\u3057\u307e\u3059\uff0e Usage main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: pause (); } Execution result Appendix Implementation Source: sstd/src/sys/pause.cpp Header: sstd/src/sys/pause.hpp Test: test/sys/pause.hpp (Not implemented yet)","title":"pause"},{"location":"src/sys/pause.html#pause","text":"","title":"pause"},{"location":"src/sys/pause.html#abstract","text":"pause waits until Enter is pressed.","title":"Abstract"},{"location":"src/sys/pause.html#header-file","text":"namespace sstd { void pause (); }","title":"Header file"},{"location":"src/sys/pause.html#description","text":"Function name Description pause() waits until Enter is pressed. Enter \u304c\u62bc\u3055\u308c\u308b\u307e\u3067\u5f85\u6a5f\u3057\u307e\u3059\uff0e","title":"Description"},{"location":"src/sys/pause.html#usage","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: pause (); } Execution result","title":"Usage"},{"location":"src/sys/pause.html#appendix","text":"","title":"Appendix"},{"location":"src/sys/pause.html#implementation","text":"Source: sstd/src/sys/pause.cpp Header: sstd/src/sys/pause.hpp Test: test/sys/pause.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/sys/pid.html","text":"pid Abstract getpid returns the PID of its own process. getpid \u306f\u81ea\u30d7\u30ed\u30bb\u30b9\u306e PID \u3092\u8fd4\u3057\u307e\u3059\uff0e Header file namespace sstd { int32 getpid (); } Usage main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: getpid () ); } Execution result sstd::getpid() = 37 Implementation Source: sstd/src/sys/pid.cpp Header: sstd/src/sys/pid.hpp Test: test/sys/pid.hpp (Not implemented yet)","title":"pid"},{"location":"src/sys/pid.html#pid","text":"","title":"pid"},{"location":"src/sys/pid.html#abstract","text":"getpid returns the PID of its own process. getpid \u306f\u81ea\u30d7\u30ed\u30bb\u30b9\u306e PID \u3092\u8fd4\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/sys/pid.html#header-file","text":"namespace sstd { int32 getpid (); }","title":"Header file"},{"location":"src/sys/pid.html#usage","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: printn ( sstd :: getpid () ); } Execution result sstd::getpid() = 37","title":"Usage"},{"location":"src/sys/pid.html#implementation","text":"Source: sstd/src/sys/pid.cpp Header: sstd/src/sys/pid.hpp Test: test/sys/pid.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/sys/system.html","text":"system Abstract system() executes the specified command. system() \u306f\u6307\u5b9a\u3055\u308c\u305f\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3057\u307e\u3059\uff0e Header file namespace sstd { int system ( const char * cmd ); int system ( const std :: string & cmd ); std :: string system_stdout ( const char * cmd ); std :: string system_stdout ( const std :: string & cmd ); std :: string system_stderr ( const char * cmd ); std :: string system_stderr ( const std :: string & cmd ); std :: string system_stdout_stderr ( const char * cmd ); std :: string system_stdout_stderr ( const std :: string & cmd ); } Usage system main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: system ( \"mkdir -p ./tmp/a/b/c\" ); sstd :: system ( \"tree ./tmp\" ); } Execution result ./tmp \u2514\u2500\u2500 a \u2514\u2500\u2500 b \u2514\u2500\u2500 c 3 directories, 0 files system_stdout_stderr Acquires the stdout and stderr that accompany the execution result. \u5b9f\u884c\u7d50\u679c\u306b\u4f34\u3046\u6a19\u6e96\u51fa\u529b\u3068\u6a19\u6e96\u30a8\u30e9\u30fc\u51fa\u529b\u3092\u53d6\u5f97\u3057\u307e\u3059\uff0e main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: system ( \"touch hello\" ); sstd :: system ( \"touch system_stdout_stderr\" ); std :: string s = sstd :: system_stdout_stderr ( \"ls\" ); sstd :: printn ( s ); } Execution result s = \"hello sstd system_stdout_stderr \" Implementation Source: sstd/src/sys/stdlib.cpp Header: sstd/src/sys/stdlib.hpp Test: test/sys/stdlib.hpp","title":"system"},{"location":"src/sys/system.html#system","text":"","title":"system"},{"location":"src/sys/system.html#abstract","text":"system() executes the specified command. system() \u306f\u6307\u5b9a\u3055\u308c\u305f\u30b3\u30de\u30f3\u30c9\u3092\u5b9f\u884c\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/sys/system.html#header-file","text":"namespace sstd { int system ( const char * cmd ); int system ( const std :: string & cmd ); std :: string system_stdout ( const char * cmd ); std :: string system_stdout ( const std :: string & cmd ); std :: string system_stderr ( const char * cmd ); std :: string system_stderr ( const std :: string & cmd ); std :: string system_stdout_stderr ( const char * cmd ); std :: string system_stdout_stderr ( const std :: string & cmd ); }","title":"Header file"},{"location":"src/sys/system.html#usage","text":"","title":"Usage"},{"location":"src/sys/system.html#system_1","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: system ( \"mkdir -p ./tmp/a/b/c\" ); sstd :: system ( \"tree ./tmp\" ); } Execution result ./tmp \u2514\u2500\u2500 a \u2514\u2500\u2500 b \u2514\u2500\u2500 c 3 directories, 0 files","title":"system"},{"location":"src/sys/system.html#system_stdout_stderr","text":"Acquires the stdout and stderr that accompany the execution result. \u5b9f\u884c\u7d50\u679c\u306b\u4f34\u3046\u6a19\u6e96\u51fa\u529b\u3068\u6a19\u6e96\u30a8\u30e9\u30fc\u51fa\u529b\u3092\u53d6\u5f97\u3057\u307e\u3059\uff0e main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: system ( \"touch hello\" ); sstd :: system ( \"touch system_stdout_stderr\" ); std :: string s = sstd :: system_stdout_stderr ( \"ls\" ); sstd :: printn ( s ); } Execution result s = \"hello sstd system_stdout_stderr \"","title":"system_stdout_stderr"},{"location":"src/sys/system.html#implementation","text":"Source: sstd/src/sys/stdlib.cpp Header: sstd/src/sys/stdlib.hpp Test: test/sys/stdlib.hpp","title":"Implementation"},{"location":"src/time/measureTime.html","text":"measureTime Abstract measureTime measures the execution time. measureTime \u306f\u5b9f\u884c\u6642\u9593\u3092\u8a08\u6e2c\u3057\u307e\u3059\uff0e Header file namespace sstd { void measureTime_start ( time_m & startTime ); double measureTime_stop_s ( const time_m & startTime ); // sec double measureTime_stop_ms ( const time_m & startTime ); // milli sec double measureTime_stop_us ( const time_m & startTime ); // micro sec double measureTime_stop_ns ( const time_m & startTime ); // nano sec std :: string measureTime_ms2str ( uint64 tmp ); std :: string measureTime_stop_str ( const time_m & startTime ); void measureTime_stop_print ( const time_m & startTime ); } Usage Measurement of execution time. (\u5b9f\u884c\u6642\u9593\u306e\u8a08\u6e2c) main.cpp #include <sstd/sstd.hpp> int main (){ printf ( \" \\n \" ); printf ( \"+---------------------------------------------------+ \\n \" ); printf ( \"| | \\n \" ); printf ( \"| Welcome to Sub Standard Library (SSTD) ! | \\n \" ); printf ( \"| | \\n \" ); printf ( \"+---------------------------------------------------+ \\n \" ); printf ( \" \\n \" ); printf ( \"\u25a0 measureTime_start--------------- \\n\\n \" ); time_m timem ; sstd :: measureTime_start ( timem ); sstd :: sleep_s ( 1 ); sstd :: sleep_ms ( 100 ); sstd :: sleep_us ( 11 * 1000 ); printf ( \" \\n \" ); printf ( \"\u25a0 measureTime_stop---------------- \\n \" ); sstd :: measureTime_stop_print ( timem ); sstd :: pauseIfWin32 (); return 0 ; } Execution result +---------------------------------------------------+ | | | Welcome to Sub Standard Library (SSTD) ! | | | +---------------------------------------------------+ \u25a0 measureTime_start--------------- \u25a0 measureTime_stop---------------- -------------------------------- Execution time: 1. 111 sec -------------------------------- Lap time measurement. (\u30e9\u30c3\u30d7\u30bf\u30a4\u30e0\u306e\u6e2c\u5b9a) main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < double > vLT_ms ; time_m timem ; sstd :: measureTime_start ( timem ); vLT_ms . push_back ( sstd :: measureTime_stop_ms ( timem ) ); for ( uint i = 0 ; i < 5 ; ++ i ){ sstd :: sleep_ms ( 10 ); vLT_ms . push_back ( sstd :: measureTime_stop_ms ( timem ) ); } sstd :: printn ( vLT_ms ); return 0 ; } Execution result vLT_ms = [0. 10.071 20.145 30.234 40.307 50.391] Implementation Source: sstd/src/time/measureTime.cpp Header: sstd/src/time/measureTime.hpp Test: test/time/measureTime.hpp","title":"measureTime"},{"location":"src/time/measureTime.html#measuretime","text":"","title":"measureTime"},{"location":"src/time/measureTime.html#abstract","text":"measureTime measures the execution time. measureTime \u306f\u5b9f\u884c\u6642\u9593\u3092\u8a08\u6e2c\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/time/measureTime.html#header-file","text":"namespace sstd { void measureTime_start ( time_m & startTime ); double measureTime_stop_s ( const time_m & startTime ); // sec double measureTime_stop_ms ( const time_m & startTime ); // milli sec double measureTime_stop_us ( const time_m & startTime ); // micro sec double measureTime_stop_ns ( const time_m & startTime ); // nano sec std :: string measureTime_ms2str ( uint64 tmp ); std :: string measureTime_stop_str ( const time_m & startTime ); void measureTime_stop_print ( const time_m & startTime ); }","title":"Header file"},{"location":"src/time/measureTime.html#usage","text":"","title":"Usage"},{"location":"src/time/measureTime.html#measurement-of-execution-time","text":"main.cpp #include <sstd/sstd.hpp> int main (){ printf ( \" \\n \" ); printf ( \"+---------------------------------------------------+ \\n \" ); printf ( \"| | \\n \" ); printf ( \"| Welcome to Sub Standard Library (SSTD) ! | \\n \" ); printf ( \"| | \\n \" ); printf ( \"+---------------------------------------------------+ \\n \" ); printf ( \" \\n \" ); printf ( \"\u25a0 measureTime_start--------------- \\n\\n \" ); time_m timem ; sstd :: measureTime_start ( timem ); sstd :: sleep_s ( 1 ); sstd :: sleep_ms ( 100 ); sstd :: sleep_us ( 11 * 1000 ); printf ( \" \\n \" ); printf ( \"\u25a0 measureTime_stop---------------- \\n \" ); sstd :: measureTime_stop_print ( timem ); sstd :: pauseIfWin32 (); return 0 ; } Execution result +---------------------------------------------------+ | | | Welcome to Sub Standard Library (SSTD) ! | | | +---------------------------------------------------+ \u25a0 measureTime_start--------------- \u25a0 measureTime_stop---------------- -------------------------------- Execution time: 1. 111 sec --------------------------------","title":"Measurement of execution time. (\u5b9f\u884c\u6642\u9593\u306e\u8a08\u6e2c)"},{"location":"src/time/measureTime.html#lap-time-measurement","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < double > vLT_ms ; time_m timem ; sstd :: measureTime_start ( timem ); vLT_ms . push_back ( sstd :: measureTime_stop_ms ( timem ) ); for ( uint i = 0 ; i < 5 ; ++ i ){ sstd :: sleep_ms ( 10 ); vLT_ms . push_back ( sstd :: measureTime_stop_ms ( timem ) ); } sstd :: printn ( vLT_ms ); return 0 ; } Execution result vLT_ms = [0. 10.071 20.145 30.234 40.307 50.391]","title":"Lap time measurement. (\u30e9\u30c3\u30d7\u30bf\u30a4\u30e0\u306e\u6e2c\u5b9a)"},{"location":"src/time/measureTime.html#implementation","text":"Source: sstd/src/time/measureTime.cpp Header: sstd/src/time/measureTime.hpp Test: test/time/measureTime.hpp","title":"Implementation"},{"location":"src/time/sleep.html","text":"sleep Abstract sleep waits for the specified time. sleep \u306f\u6307\u5b9a\u6642\u9593\u5f85\u6a5f\u3057\u307e\u3059\uff0e Header file namespace sstd { inline void sleep_hour ( uint rhs ); inline void sleep_min ( uint rhs ); inline void sleep_s ( uint rhs ); inline void sleep_ms ( uint rhs ); inline void sleep_us ( uint rhs ); inline void sleep_ns ( uint rhs ); } Usage main.cpp #include <sstd/sstd.hpp> int main (){ time_m timem ; sstd :: measureTime_start ( timem ); sstd :: sleep_s ( 1 ); sstd :: sleep_ms ( 100 ); sstd :: sleep_us ( 11 * 1000 ); sstd :: measureTime_stop_print ( timem ); return 0 ; } Execution result -------------------------------- Execution time: 1. 111 sec -------------------------------- Implementation Header: sstd/src/sleep.hpp Test: test/sleep.hpp (Not implemented yet)","title":"sleep"},{"location":"src/time/sleep.html#sleep","text":"","title":"sleep"},{"location":"src/time/sleep.html#abstract","text":"sleep waits for the specified time. sleep \u306f\u6307\u5b9a\u6642\u9593\u5f85\u6a5f\u3057\u307e\u3059\uff0e","title":"Abstract"},{"location":"src/time/sleep.html#header-file","text":"namespace sstd { inline void sleep_hour ( uint rhs ); inline void sleep_min ( uint rhs ); inline void sleep_s ( uint rhs ); inline void sleep_ms ( uint rhs ); inline void sleep_us ( uint rhs ); inline void sleep_ns ( uint rhs ); }","title":"Header file"},{"location":"src/time/sleep.html#usage","text":"main.cpp #include <sstd/sstd.hpp> int main (){ time_m timem ; sstd :: measureTime_start ( timem ); sstd :: sleep_s ( 1 ); sstd :: sleep_ms ( 100 ); sstd :: sleep_us ( 11 * 1000 ); sstd :: measureTime_stop_print ( timem ); return 0 ; } Execution result -------------------------------- Execution time: 1. 111 sec --------------------------------","title":"Usage"},{"location":"src/time/sleep.html#implementation","text":"Header: sstd/src/sleep.hpp Test: test/sleep.hpp (Not implemented yet)","title":"Implementation"},{"location":"src/time/time.html","text":"time Abstract struct tm \u3068 time_t (unixtime) \u304a\u3088\u3073\uff0c\u305d\u306e\u4ed6\u306e\u6642\u523b\u3092\u76f8\u4e92\u5909\u63db\u3059\u308b\uff0e Header file namespace sstd { struct tm time2tm ( time_t unixtime ); time_t tm2time ( struct tm & rhs ); struct tm timeGm2tmLocal ( time_t unixtime ); time_t tmLocal2timeGm ( struct tm & rhs ); std :: string time2str ( time_t unixtime ); std :: string tm2str ( struct tm & rhs ); double time2unixday ( time_t unixtime ); double tm2unixday ( struct tm & rhs ); time_t yday2time ( uint year , uint yday ); struct tm yday2tm ( uint year , uint yday ); struct timeval getTimeval (); double unixtime2JulianDate ( time_t unixtime ); double Julius_T ( time_t unixtime ); double JulianDate2Julius_T ( double JulianDate ); double TJuliusD ( time_t unixtime ); double JulianDate2TJuliusD ( double JulianDate ); void print ( const struct tm & rhs ); void for_printn ( const struct tm & rhs ); } Usage main.cpp #include <time.h> // for time() #include <sstd/sstd.hpp> int main (){ time_t unixtime_UTC ; time ( & unixtime_UTC ); // get current unixtime (UTC) struct tm tm_UTC = sstd :: time2tm ( unixtime_UTC ); struct tm tm_Local = sstd :: timeGm2tmLocal ( unixtime_UTC ); sstd :: printn ( unixtime_UTC ); sstd :: printn ( tm_UTC ); sstd :: printn ( tm_Local ); } Execution result Below is the result on Japanese local time (UTC+9hour). unixtime_UTC = 1671885617 tm_UTC = 2022-12-24 12:40:17 tm_Local = 2022-12-24 12:40:17 Appendix struct tm { int tm_sec ; /* \u79d2 [0-61] \u6700\u59272\u79d2\u307e\u3067\u306e\u3046\u308b\u3046\u79d2\u3092\u8003\u616e */ int tm_min ; /* \u5206 [0-59] */ int tm_hour ; /* \u6642 [0-23] */ int tm_mday ; /* \u65e5 [1-31] */ int tm_mon ; /* \u6708 [0-11] 0\u304b\u3089\u59cb\u307e\u308b\u3053\u3068\u306b\u6ce8\u610f */ int tm_year ; /* \u5e74 [1900\u304b\u3089\u306e\u7d4c\u904e\u5e74\u6570] */ int tm_wday ; /* \u66dc\u65e5 [0:\u65e5 1:\u6708 ... 6:\u571f] */ int tm_yday ; /* \u5e74\u5185\u306e\u901a\u3057\u65e5\u6570 [0-365] 0\u304b\u3089\u59cb\u307e\u308b\u3053\u3068\u306b\u6ce8\u610f*/ int tm_isdst ; /* \u590f\u6642\u9593\u304c\u7121\u52b9\u3067\u3042\u308c\u3070 0 */ }; ref: localtime - \u521d\u5fc3\u8005\u306e\u305f\u3081\u306e\u30dd\u30a4\u30f3\u30c8\u5b66\u7fd2 C \u8a00\u8a9e Implementation Source: sstd/src/time/time.cpp Header: sstd/src/time/time.hpp Test: test/time/time.hpp","title":"time"},{"location":"src/time/time.html#time","text":"","title":"time"},{"location":"src/time/time.html#abstract","text":"struct tm \u3068 time_t (unixtime) \u304a\u3088\u3073\uff0c\u305d\u306e\u4ed6\u306e\u6642\u523b\u3092\u76f8\u4e92\u5909\u63db\u3059\u308b\uff0e","title":"Abstract"},{"location":"src/time/time.html#header-file","text":"namespace sstd { struct tm time2tm ( time_t unixtime ); time_t tm2time ( struct tm & rhs ); struct tm timeGm2tmLocal ( time_t unixtime ); time_t tmLocal2timeGm ( struct tm & rhs ); std :: string time2str ( time_t unixtime ); std :: string tm2str ( struct tm & rhs ); double time2unixday ( time_t unixtime ); double tm2unixday ( struct tm & rhs ); time_t yday2time ( uint year , uint yday ); struct tm yday2tm ( uint year , uint yday ); struct timeval getTimeval (); double unixtime2JulianDate ( time_t unixtime ); double Julius_T ( time_t unixtime ); double JulianDate2Julius_T ( double JulianDate ); double TJuliusD ( time_t unixtime ); double JulianDate2TJuliusD ( double JulianDate ); void print ( const struct tm & rhs ); void for_printn ( const struct tm & rhs ); }","title":"Header file"},{"location":"src/time/time.html#usage","text":"main.cpp #include <time.h> // for time() #include <sstd/sstd.hpp> int main (){ time_t unixtime_UTC ; time ( & unixtime_UTC ); // get current unixtime (UTC) struct tm tm_UTC = sstd :: time2tm ( unixtime_UTC ); struct tm tm_Local = sstd :: timeGm2tmLocal ( unixtime_UTC ); sstd :: printn ( unixtime_UTC ); sstd :: printn ( tm_UTC ); sstd :: printn ( tm_Local ); } Execution result Below is the result on Japanese local time (UTC+9hour). unixtime_UTC = 1671885617 tm_UTC = 2022-12-24 12:40:17 tm_Local = 2022-12-24 12:40:17","title":"Usage"},{"location":"src/time/time.html#appendix","text":"struct tm { int tm_sec ; /* \u79d2 [0-61] \u6700\u59272\u79d2\u307e\u3067\u306e\u3046\u308b\u3046\u79d2\u3092\u8003\u616e */ int tm_min ; /* \u5206 [0-59] */ int tm_hour ; /* \u6642 [0-23] */ int tm_mday ; /* \u65e5 [1-31] */ int tm_mon ; /* \u6708 [0-11] 0\u304b\u3089\u59cb\u307e\u308b\u3053\u3068\u306b\u6ce8\u610f */ int tm_year ; /* \u5e74 [1900\u304b\u3089\u306e\u7d4c\u904e\u5e74\u6570] */ int tm_wday ; /* \u66dc\u65e5 [0:\u65e5 1:\u6708 ... 6:\u571f] */ int tm_yday ; /* \u5e74\u5185\u306e\u901a\u3057\u65e5\u6570 [0-365] 0\u304b\u3089\u59cb\u307e\u308b\u3053\u3068\u306b\u6ce8\u610f*/ int tm_isdst ; /* \u590f\u6642\u9593\u304c\u7121\u52b9\u3067\u3042\u308c\u3070 0 */ }; ref: localtime - \u521d\u5fc3\u8005\u306e\u305f\u3081\u306e\u30dd\u30a4\u30f3\u30c8\u5b66\u7fd2 C \u8a00\u8a9e","title":"Appendix"},{"location":"src/time/time.html#implementation","text":"Source: sstd/src/time/time.cpp Header: sstd/src/time/time.hpp Test: test/time/time.hpp","title":"Implementation"},{"location":"src/vector/Tr.html","text":"Tr (Transpose) Abstract Tr() are the transpose functions for std::vector<std::vector<T>> . Tr() \u306f std::vector<std::vector<T>> \u3092\u8ee2\u7f6e\u3059\u308b\u305f\u3081\u306e\u95a2\u6570\u3067\u3059. Header file namespace sstd { template < typename T > std :: vector < std :: vector < T >> Tr ( const std :: vector < std :: vector < T >>& rhs ); template < typename T > std :: vector < std :: vector < T >> Tr ( std :: vector < std :: vector < T >>&& rhs ); } Usage Transpose. Ex: 1 main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < int >> vvec = { { 1 , 2 , 3 } }; sstd :: printn ( vvec ); std :: vector < std :: vector < int >> vvecTr = sstd :: Tr ( vvec ); sstd :: printn ( vvecTr ); } Execution result vvec = [[1 2 3]] vvecTr = [[1] [2] [3]] Transpose. Ex: 2 main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < int >> vvec = { { 1 , 2 , 3 }, { 4 , 5 , 6 }, { 7 , 8 , 9 } }; sstd :: printn ( vvec ); std :: vector < std :: vector < int >> vvecTr = sstd :: Tr ( vvec ); sstd :: printn ( vvecTr ); } Execution result vvec = [[1 2 3] [4 5 6] [7 8 9]] vvecTr = [[1 4 7] [2 5 8] [3 6 9]] Transpose. Ex: 3 main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < int >> vvec = { { 1 }, { 2 , 3 }, { 4 , 5 , 6 } }; sstd :: printn ( vvec ); std :: vector < std :: vector < int >> vvecTr = sstd :: Tr ( vvec ); sstd :: printn ( vvecTr ); } Execution result vvec = [[1] [2 3] [4 5 6]] vvecTr = [[1 2 4] [0 3 5] [0 0 6]] Implementation Header: sstd/src/vector/vvec.hpp Test: test/vector_vvec.hpp","title":"Tr (Transpose)"},{"location":"src/vector/Tr.html#tr-transpose","text":"","title":"Tr (Transpose)"},{"location":"src/vector/Tr.html#abstract","text":"Tr() are the transpose functions for std::vector<std::vector<T>> . Tr() \u306f std::vector<std::vector<T>> \u3092\u8ee2\u7f6e\u3059\u308b\u305f\u3081\u306e\u95a2\u6570\u3067\u3059.","title":"Abstract"},{"location":"src/vector/Tr.html#header-file","text":"namespace sstd { template < typename T > std :: vector < std :: vector < T >> Tr ( const std :: vector < std :: vector < T >>& rhs ); template < typename T > std :: vector < std :: vector < T >> Tr ( std :: vector < std :: vector < T >>&& rhs ); }","title":"Header file"},{"location":"src/vector/Tr.html#usage","text":"","title":"Usage"},{"location":"src/vector/Tr.html#transpose-ex-1","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < int >> vvec = { { 1 , 2 , 3 } }; sstd :: printn ( vvec ); std :: vector < std :: vector < int >> vvecTr = sstd :: Tr ( vvec ); sstd :: printn ( vvecTr ); } Execution result vvec = [[1 2 3]] vvecTr = [[1] [2] [3]]","title":"Transpose. Ex: 1"},{"location":"src/vector/Tr.html#transpose-ex-2","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < int >> vvec = { { 1 , 2 , 3 }, { 4 , 5 , 6 }, { 7 , 8 , 9 } }; sstd :: printn ( vvec ); std :: vector < std :: vector < int >> vvecTr = sstd :: Tr ( vvec ); sstd :: printn ( vvecTr ); } Execution result vvec = [[1 2 3] [4 5 6] [7 8 9]] vvecTr = [[1 4 7] [2 5 8] [3 6 9]]","title":"Transpose. Ex: 2"},{"location":"src/vector/Tr.html#transpose-ex-3","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < int >> vvec = { { 1 }, { 2 , 3 }, { 4 , 5 , 6 } }; sstd :: printn ( vvec ); std :: vector < std :: vector < int >> vvecTr = sstd :: Tr ( vvec ); sstd :: printn ( vvecTr ); } Execution result vvec = [[1] [2 3] [4 5 6]] vvecTr = [[1 2 4] [0 3 5] [0 0 6]]","title":"Transpose. Ex: 3"},{"location":"src/vector/Tr.html#implementation","text":"Header: sstd/src/vector/vvec.hpp Test: test/vector_vvec.hpp","title":"Implementation"},{"location":"src/vector/slice.html","text":"slice Abstract sstd::slice / sstd::slice_mv \u306f\uff0cPython \u306e slice \u5b9f\u88c5\u3092 C++ \u98a8\u306b\u30a2\u30ec\u30f3\u30b8\u3057\u305f sstd \u306e\u72ec\u81ea\u5b9f\u88c5\u3067\u3059\uff0e sstd::slice \u306f\u8981\u7d20\u30b3\u30d4\u30fc\u3092\u4f34\u3046\u547d\u4ee4\u3067\uff0c sstd::slice_mv \u306f\u5185\u90e8\u7684\u306b std::move \u3092\u547c\u3073\u51fa\u3057\u307e\u3059\uff0e std::vector \u306b\u5bfe\u3059\u308b slice \u64cd\u4f5c\u3092\u5b9a\u7fa9\u3057\u3066\u3044\u307e\u3059\uff0e \u306a\u304a\uff0c sstd::begin \u304a\u3088\u3073 sstd::end \u306f\uff0c src/itr.hpp \u306b\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\uff0e Header file namespace sstd { sstd_vecSc :: slice_i slice ( const int val ); sstd_vecSc :: slice_u slice ( const uint val ); sstd_vecSc :: slice_s slice ( const size_t val ); sstd_vecSc :: slice_b slice ( const sstd :: begin val ); sstd_vecSc :: slice_e slice ( const sstd :: end val ); sstd_vecSc :: slice_ii slice ( const int lhs , const int rhs ); sstd_vecSc :: slice_iu slice ( const int lhs , const uint rhs ); sstd_vecSc :: slice_is slice ( const int lhs , const size_t rhs ); sstd_vecSc :: slice_ui slice ( const uint lhs , const int rhs ); sstd_vecSc :: slice_uu slice ( const uint lhs , const uint rhs ); sstd_vecSc :: slice_us slice ( const uint lhs , const size_t rhs ); sstd_vecSc :: slice_si slice ( const size_t lhs , const int rhs ); sstd_vecSc :: slice_su slice ( const size_t lhs , const uint rhs ); sstd_vecSc :: slice_ss slice ( const size_t lhs , const size_t rhs ); sstd_vecSc :: slice_bi slice ( const sstd :: begin lhs , const int rhs ); sstd_vecSc :: slice_bu slice ( const sstd :: begin lhs , const uint rhs ); sstd_vecSc :: slice_bs slice ( const sstd :: begin lhs , const size_t rhs ); sstd_vecSc :: slice_ie slice ( const int lhs , const sstd :: end rhs ); sstd_vecSc :: slice_ue slice ( const uint lhs , const sstd :: end rhs ); sstd_vecSc :: slice_se slice ( const size_t lhs , const sstd :: end rhs ); sstd_vecSc :: slice_be slice ( const sstd :: begin lhs , const sstd :: end rhs ); //--- sstd_vecSc :: slice_mv_i slice_mv ( const int val ); sstd_vecSc :: slice_mv_u slice_mv ( const uint val ); sstd_vecSc :: slice_mv_s slice_mv ( const size_t val ); sstd_vecSc :: slice_mv_b slice_mv ( const sstd :: begin val ); sstd_vecSc :: slice_mv_e slice_mv ( const sstd :: end val ); sstd_vecSc :: slice_mv_ii slice_mv ( const int lhs , const int rhs ); sstd_vecSc :: slice_mv_iu slice_mv ( const int lhs , const uint rhs ); sstd_vecSc :: slice_mv_is slice_mv ( const int lhs , const size_t rhs ); sstd_vecSc :: slice_mv_ui slice_mv ( const uint lhs , const int rhs ); sstd_vecSc :: slice_mv_uu slice_mv ( const uint lhs , const uint rhs ); sstd_vecSc :: slice_mv_us slice_mv ( const uint lhs , const size_t rhs ); sstd_vecSc :: slice_mv_si slice_mv ( const size_t lhs , const int rhs ); sstd_vecSc :: slice_mv_su slice_mv ( const size_t lhs , const uint rhs ); sstd_vecSc :: slice_mv_ss slice_mv ( const size_t lhs , const size_t rhs ); sstd_vecSc :: slice_mv_bi slice_mv ( const sstd :: begin lhs , const int rhs ); sstd_vecSc :: slice_mv_bu slice_mv ( const sstd :: begin lhs , const uint rhs ); sstd_vecSc :: slice_mv_bs slice_mv ( const sstd :: begin lhs , const size_t rhs ); sstd_vecSc :: slice_mv_ie slice_mv ( const int lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_ue slice_mv ( const uint lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_se slice_mv ( const size_t lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_be slice_mv ( const sstd :: begin lhs , const sstd :: end rhs ); } Usage one arg (copy) main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced01 = v && sstd :: slice ( 1 ); std :: vector < int > v_sliced02 = v && sstd :: slice ( -1 ); sstd :: printn ( v ); sstd :: printn ( v_sliced01 ); sstd :: printn ( v_sliced02 ); } Execution result v = [1 2 3 4 5] v_sliced01 = [2] v_sliced02 = [5] two args (copy) main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced = v && sstd :: slice ( 1 , 3 ); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } Execution result v = [1 2 3 4 5] v_sliced = [2 3] begin to end (copy) main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced = v && sstd :: slice ( sstd :: begin (), sstd :: end ()); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } Execution result v = [1 2 3 4 5] v_sliced = [1 2 3 4 5] one arg (move) main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced01 = v && sstd :: slice_mv ( 1 ); std :: vector < std :: string > v_sliced02 = v && sstd :: slice_mv ( -1 ); sstd :: printn ( v ); sstd :: printn ( v_sliced01 ); sstd :: printn ( v_sliced02 ); } Execution result v = [\"1\" \"\" \"3\" \"4\" \"\"] v_sliced01 = [\"2\"] v_sliced02 = [\"5\"] two args (move) main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced = v && sstd :: slice_mv ( 1 , 3 ); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } Execution result v = [\"1\" \"\" \"\" \"4\" \"5\"] v_sliced = [\"2\" \"3\"] begin to end (move) main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced = v && sstd :: slice_mv ( sstd :: begin (), sstd :: end ()); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } Execution result v = [\"\" \"\" \"\" \"\" \"\"] v_sliced = [\"1\" \"2\" \"3\" \"4\" \"5\"] Implementation Header: sstd/src/vector/slice.hpp Test: test/vector_slice.hpp","title":"slice"},{"location":"src/vector/slice.html#slice","text":"","title":"slice"},{"location":"src/vector/slice.html#abstract","text":"sstd::slice / sstd::slice_mv \u306f\uff0cPython \u306e slice \u5b9f\u88c5\u3092 C++ \u98a8\u306b\u30a2\u30ec\u30f3\u30b8\u3057\u305f sstd \u306e\u72ec\u81ea\u5b9f\u88c5\u3067\u3059\uff0e sstd::slice \u306f\u8981\u7d20\u30b3\u30d4\u30fc\u3092\u4f34\u3046\u547d\u4ee4\u3067\uff0c sstd::slice_mv \u306f\u5185\u90e8\u7684\u306b std::move \u3092\u547c\u3073\u51fa\u3057\u307e\u3059\uff0e std::vector \u306b\u5bfe\u3059\u308b slice \u64cd\u4f5c\u3092\u5b9a\u7fa9\u3057\u3066\u3044\u307e\u3059\uff0e \u306a\u304a\uff0c sstd::begin \u304a\u3088\u3073 sstd::end \u306f\uff0c src/itr.hpp \u306b\u5b9a\u7fa9\u3055\u308c\u3066\u3044\u308b\uff0e","title":"Abstract"},{"location":"src/vector/slice.html#header-file","text":"namespace sstd { sstd_vecSc :: slice_i slice ( const int val ); sstd_vecSc :: slice_u slice ( const uint val ); sstd_vecSc :: slice_s slice ( const size_t val ); sstd_vecSc :: slice_b slice ( const sstd :: begin val ); sstd_vecSc :: slice_e slice ( const sstd :: end val ); sstd_vecSc :: slice_ii slice ( const int lhs , const int rhs ); sstd_vecSc :: slice_iu slice ( const int lhs , const uint rhs ); sstd_vecSc :: slice_is slice ( const int lhs , const size_t rhs ); sstd_vecSc :: slice_ui slice ( const uint lhs , const int rhs ); sstd_vecSc :: slice_uu slice ( const uint lhs , const uint rhs ); sstd_vecSc :: slice_us slice ( const uint lhs , const size_t rhs ); sstd_vecSc :: slice_si slice ( const size_t lhs , const int rhs ); sstd_vecSc :: slice_su slice ( const size_t lhs , const uint rhs ); sstd_vecSc :: slice_ss slice ( const size_t lhs , const size_t rhs ); sstd_vecSc :: slice_bi slice ( const sstd :: begin lhs , const int rhs ); sstd_vecSc :: slice_bu slice ( const sstd :: begin lhs , const uint rhs ); sstd_vecSc :: slice_bs slice ( const sstd :: begin lhs , const size_t rhs ); sstd_vecSc :: slice_ie slice ( const int lhs , const sstd :: end rhs ); sstd_vecSc :: slice_ue slice ( const uint lhs , const sstd :: end rhs ); sstd_vecSc :: slice_se slice ( const size_t lhs , const sstd :: end rhs ); sstd_vecSc :: slice_be slice ( const sstd :: begin lhs , const sstd :: end rhs ); //--- sstd_vecSc :: slice_mv_i slice_mv ( const int val ); sstd_vecSc :: slice_mv_u slice_mv ( const uint val ); sstd_vecSc :: slice_mv_s slice_mv ( const size_t val ); sstd_vecSc :: slice_mv_b slice_mv ( const sstd :: begin val ); sstd_vecSc :: slice_mv_e slice_mv ( const sstd :: end val ); sstd_vecSc :: slice_mv_ii slice_mv ( const int lhs , const int rhs ); sstd_vecSc :: slice_mv_iu slice_mv ( const int lhs , const uint rhs ); sstd_vecSc :: slice_mv_is slice_mv ( const int lhs , const size_t rhs ); sstd_vecSc :: slice_mv_ui slice_mv ( const uint lhs , const int rhs ); sstd_vecSc :: slice_mv_uu slice_mv ( const uint lhs , const uint rhs ); sstd_vecSc :: slice_mv_us slice_mv ( const uint lhs , const size_t rhs ); sstd_vecSc :: slice_mv_si slice_mv ( const size_t lhs , const int rhs ); sstd_vecSc :: slice_mv_su slice_mv ( const size_t lhs , const uint rhs ); sstd_vecSc :: slice_mv_ss slice_mv ( const size_t lhs , const size_t rhs ); sstd_vecSc :: slice_mv_bi slice_mv ( const sstd :: begin lhs , const int rhs ); sstd_vecSc :: slice_mv_bu slice_mv ( const sstd :: begin lhs , const uint rhs ); sstd_vecSc :: slice_mv_bs slice_mv ( const sstd :: begin lhs , const size_t rhs ); sstd_vecSc :: slice_mv_ie slice_mv ( const int lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_ue slice_mv ( const uint lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_se slice_mv ( const size_t lhs , const sstd :: end rhs ); sstd_vecSc :: slice_mv_be slice_mv ( const sstd :: begin lhs , const sstd :: end rhs ); }","title":"Header file"},{"location":"src/vector/slice.html#usage","text":"","title":"Usage"},{"location":"src/vector/slice.html#one-arg-copy","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced01 = v && sstd :: slice ( 1 ); std :: vector < int > v_sliced02 = v && sstd :: slice ( -1 ); sstd :: printn ( v ); sstd :: printn ( v_sliced01 ); sstd :: printn ( v_sliced02 ); } Execution result v = [1 2 3 4 5] v_sliced01 = [2] v_sliced02 = [5]","title":"one arg (copy)"},{"location":"src/vector/slice.html#two-args-copy","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced = v && sstd :: slice ( 1 , 3 ); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } Execution result v = [1 2 3 4 5] v_sliced = [2 3]","title":"two args (copy)"},{"location":"src/vector/slice.html#begin-to-end-copy","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v_sliced = v && sstd :: slice ( sstd :: begin (), sstd :: end ()); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } Execution result v = [1 2 3 4 5] v_sliced = [1 2 3 4 5]","title":"begin to end (copy)"},{"location":"src/vector/slice.html#one-arg-move","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced01 = v && sstd :: slice_mv ( 1 ); std :: vector < std :: string > v_sliced02 = v && sstd :: slice_mv ( -1 ); sstd :: printn ( v ); sstd :: printn ( v_sliced01 ); sstd :: printn ( v_sliced02 ); } Execution result v = [\"1\" \"\" \"3\" \"4\" \"\"] v_sliced01 = [\"2\"] v_sliced02 = [\"5\"]","title":"one arg (move)"},{"location":"src/vector/slice.html#two-args-move","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced = v && sstd :: slice_mv ( 1 , 3 ); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } Execution result v = [\"1\" \"\" \"\" \"4\" \"5\"] v_sliced = [\"2\" \"3\"]","title":"two args (move)"},{"location":"src/vector/slice.html#begin-to-end-move","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: string > v = { \"1\" , \"2\" , \"3\" , \"4\" , \"5\" }; std :: vector < std :: string > v_sliced = v && sstd :: slice_mv ( sstd :: begin (), sstd :: end ()); sstd :: printn ( v ); sstd :: printn ( v_sliced ); } Execution result v = [\"\" \"\" \"\" \"\" \"\"] v_sliced = [\"1\" \"2\" \"3\" \"4\" \"5\"]","title":"begin to end (move)"},{"location":"src/vector/slice.html#implementation","text":"Header: sstd/src/vector/slice.hpp Test: test/vector_slice.hpp","title":"Implementation"},{"location":"src/vector/stdVector_expansion.html","text":"Operator expansions for std::vector<T> Abstract Operator definitions on SSTD. These definitions are read by #include <sstd/sstd.hpp> . SSTD \u306b\u304a\u3051\u308b\u6f14\u7b97\u5b50\u306e\u5b9a\u7fa9\uff0e #include <sstd/sstd.hpp> \u306b\u3088\u308a\u5b9a\u7fa9\u304c\u8aad\u307f\u8fbc\u307e\u308c\u308b\uff0e Header file namespace sstd_stdVecEx { // operators for mathematics SSTD_DEF_stdVecEx_defInNamespace ( add ); // + SSTD_DEF_stdVecEx_defInNamespace_eq ( add_eq ); // += SSTD_DEF_stdVecEx_defInNamespace ( sub ); // - SSTD_DEF_stdVecEx_defInNamespace_eq ( sub_eq ); // -= SSTD_DEF_stdVecEx_defInNamespace ( mul ); // * SSTD_DEF_stdVecEx_defInNamespace_eq ( mul_eq ); // *= SSTD_DEF_stdVecEx_defInNamespace ( div ); // / SSTD_DEF_stdVecEx_defInNamespace_eq ( div_eq ); // /= SSTD_DEF_stdVecEx_defInNamespace ( mod ); // % SSTD_DEF_stdVecEx_defInNamespace_eq ( mod_eq ); // %= SSTD_DEF_stdVecEx_defInNamespace ( pow ); // ^ SSTD_DEF_stdVecEx_defInNamespace_eq ( pow_eq ); // ^= // operators for std::vector SSTD_DEF_stdVecEx_defInNamespace ( push_front ); // >> SSTD_DEF_stdVecEx_defInNamespace_eq ( push_front_eq ); // >>= SSTD_DEF_stdVecEx_defInNamespace ( push_back ); // << SSTD_DEF_stdVecEx_defInNamespace_eq ( push_back_eq ); // <<= } Usage Ope. * and *= vector \u00d7 scalar main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 }; sstd :: printn ( v * 2 ); v *= 3 ; sstd :: printn ( v ); } Execution result v * 2 = [2 4 6] v = [3 6 9] vector \u00d7 vector main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { 2 , 3 , 4 }; sstd :: printn ( v1 * v2 ); v1 *= v2 ; sstd :: printn ( v1 ); sstd :: printn ( v2 ); } Execution result v1 * v2 = [2 6 12] v1 = [2 6 12] v2 = [2 3 4] any depth vector \u00d7 scalar main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < std :: vector < int >>> v = {{{ 1 , 2 }, { 3 , 4 }}, {{ 5 , 6 }, { 7 , 8 }}}; sstd :: printn ( v * 2 ); v *= 3 ; sstd :: printn ( v ); } Execution result v * 2 = [[[2 4] [6 8]] [[10 12] [14 16]]] v = [[[3 6] [9 12]] [[15 18] [21 24]]] any depth vector \u00d7 vector main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < std :: vector < int >>> v1 = {{{ 1 , 2 }, { 3 , 4 }}, {{ 5 , 6 }, { 7 , 8 }}}; std :: vector < std :: vector < std :: vector < int >>> v2 = {{{ 9 , 10 }, { 11 , 12 }}, {{ 13 , 14 }, { 15 , 16 }}}; sstd :: printn ( v1 * v2 ); v1 *= v2 ; sstd :: printn ( v1 ); sstd :: printn ( v2 ); } Execution result v1 * v2 = [[[9 20] [33 48]] [[65 84] [105 128]]] v1 = [[[9 20] [33 48]] [[65 84] [105 128]]] v2 = [[[9 10] [11 12]] [[13 14] [15 16]]] Linking << vector << scalar main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 }; int s = 4 ; sstd :: printn ( v << s ); sstd :: printn ( v ); sstd :: printn ( s ); } Execution result v << s = [1 2 3 4] v = [1 2 3] s = 4 vector << vector main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { 4 , 5 , 6 }; sstd :: printn ( v1 << v2 ); sstd :: printn ( v1 ); sstd :: printn ( v2 ); } Execution result v1 << v2 = [1 2 3 4 5 6] v1 = [1 2 3] v2 = [4 5 6] push_back() vector <<= scalar main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v ; v <<= 1 ; // same as a \"v.push_back(1);\" v <<= 2 ; // same as a \"v.push_back(2);\" v <<= 3 ; // same as a \"v.push_back(3);\" sstd :: printn ( v ); } Execution result v = [1 2 3] vector <<= vector main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { 4 , 5 , 6 }; v1 <<= v2 ; sstd :: printn ( v1 ); sstd :: printn ( v2 ); } Execution result v1 = [1 2 3 4 5 6] v2 = [4 5 6] Linking >> vector >> scalar main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 }; int s = 0 ; sstd :: printn ( v >> s ); sstd :: printn ( v ); sstd :: printn ( s ); } Execution result v >> s = [0 1 2 3] v = [1 2 3] s = 0 vector >> vector main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { -2 , -1 , 0 }; sstd :: printn ( v1 >> v2 ); sstd :: printn ( v1 ); sstd :: printn ( v2 ); } Execution result v1 >> v2 = [-2 -1 0 1 2 3] v1 = [1 2 3] v2 = [-2 -1 0] push_front() vector >>= scalar main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 }; v >>= 0 ; sstd :: printn ( v ); } Execution result v = [0 1 2 3] vector >>= vector main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { -2 , -1 , 0 }; v1 >>= v2 ; sstd :: printn ( v1 ); sstd :: printn ( v2 ); } Execution result v1 = [-2 -1 0 1 2 3] v2 = [-2 -1 0] Implementation Header: sstd/src/vector/stdVector_expansion.hpp Test: test/vector_stdVector_expansion.hpp","title":"Ope. Exp. for std::vector&lt;T&gt;"},{"location":"src/vector/stdVector_expansion.html#operator-expansions-for-stdvectort","text":"","title":"Operator expansions for std::vector&lt;T&gt;"},{"location":"src/vector/stdVector_expansion.html#abstract","text":"Operator definitions on SSTD. These definitions are read by #include <sstd/sstd.hpp> . SSTD \u306b\u304a\u3051\u308b\u6f14\u7b97\u5b50\u306e\u5b9a\u7fa9\uff0e #include <sstd/sstd.hpp> \u306b\u3088\u308a\u5b9a\u7fa9\u304c\u8aad\u307f\u8fbc\u307e\u308c\u308b\uff0e","title":"Abstract"},{"location":"src/vector/stdVector_expansion.html#header-file","text":"namespace sstd_stdVecEx { // operators for mathematics SSTD_DEF_stdVecEx_defInNamespace ( add ); // + SSTD_DEF_stdVecEx_defInNamespace_eq ( add_eq ); // += SSTD_DEF_stdVecEx_defInNamespace ( sub ); // - SSTD_DEF_stdVecEx_defInNamespace_eq ( sub_eq ); // -= SSTD_DEF_stdVecEx_defInNamespace ( mul ); // * SSTD_DEF_stdVecEx_defInNamespace_eq ( mul_eq ); // *= SSTD_DEF_stdVecEx_defInNamespace ( div ); // / SSTD_DEF_stdVecEx_defInNamespace_eq ( div_eq ); // /= SSTD_DEF_stdVecEx_defInNamespace ( mod ); // % SSTD_DEF_stdVecEx_defInNamespace_eq ( mod_eq ); // %= SSTD_DEF_stdVecEx_defInNamespace ( pow ); // ^ SSTD_DEF_stdVecEx_defInNamespace_eq ( pow_eq ); // ^= // operators for std::vector SSTD_DEF_stdVecEx_defInNamespace ( push_front ); // >> SSTD_DEF_stdVecEx_defInNamespace_eq ( push_front_eq ); // >>= SSTD_DEF_stdVecEx_defInNamespace ( push_back ); // << SSTD_DEF_stdVecEx_defInNamespace_eq ( push_back_eq ); // <<= }","title":"Header file"},{"location":"src/vector/stdVector_expansion.html#usage","text":"","title":"Usage"},{"location":"src/vector/stdVector_expansion.html#ope-and","text":"","title":"Ope. * and *="},{"location":"src/vector/stdVector_expansion.html#vector-scalar","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 }; sstd :: printn ( v * 2 ); v *= 3 ; sstd :: printn ( v ); } Execution result v * 2 = [2 4 6] v = [3 6 9]","title":"vector \u00d7 scalar"},{"location":"src/vector/stdVector_expansion.html#vector-vector","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { 2 , 3 , 4 }; sstd :: printn ( v1 * v2 ); v1 *= v2 ; sstd :: printn ( v1 ); sstd :: printn ( v2 ); } Execution result v1 * v2 = [2 6 12] v1 = [2 6 12] v2 = [2 3 4]","title":"vector \u00d7 vector"},{"location":"src/vector/stdVector_expansion.html#any-depth-vector-scalar","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < std :: vector < int >>> v = {{{ 1 , 2 }, { 3 , 4 }}, {{ 5 , 6 }, { 7 , 8 }}}; sstd :: printn ( v * 2 ); v *= 3 ; sstd :: printn ( v ); } Execution result v * 2 = [[[2 4] [6 8]] [[10 12] [14 16]]] v = [[[3 6] [9 12]] [[15 18] [21 24]]]","title":"any depth vector \u00d7 scalar"},{"location":"src/vector/stdVector_expansion.html#any-depth-vector-vector","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < std :: vector < std :: vector < int >>> v1 = {{{ 1 , 2 }, { 3 , 4 }}, {{ 5 , 6 }, { 7 , 8 }}}; std :: vector < std :: vector < std :: vector < int >>> v2 = {{{ 9 , 10 }, { 11 , 12 }}, {{ 13 , 14 }, { 15 , 16 }}}; sstd :: printn ( v1 * v2 ); v1 *= v2 ; sstd :: printn ( v1 ); sstd :: printn ( v2 ); } Execution result v1 * v2 = [[[9 20] [33 48]] [[65 84] [105 128]]] v1 = [[[9 20] [33 48]] [[65 84] [105 128]]] v2 = [[[9 10] [11 12]] [[13 14] [15 16]]]","title":"any depth vector \u00d7 vector"},{"location":"src/vector/stdVector_expansion.html#linking","text":"","title":"Linking &lt;&lt;"},{"location":"src/vector/stdVector_expansion.html#vector-scalar_1","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 }; int s = 4 ; sstd :: printn ( v << s ); sstd :: printn ( v ); sstd :: printn ( s ); } Execution result v << s = [1 2 3 4] v = [1 2 3] s = 4","title":"vector &lt;&lt; scalar"},{"location":"src/vector/stdVector_expansion.html#vector-vector_1","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { 4 , 5 , 6 }; sstd :: printn ( v1 << v2 ); sstd :: printn ( v1 ); sstd :: printn ( v2 ); } Execution result v1 << v2 = [1 2 3 4 5 6] v1 = [1 2 3] v2 = [4 5 6]","title":"vector &lt;&lt; vector"},{"location":"src/vector/stdVector_expansion.html#push_back","text":"","title":"push_back()"},{"location":"src/vector/stdVector_expansion.html#vector-scalar_2","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v ; v <<= 1 ; // same as a \"v.push_back(1);\" v <<= 2 ; // same as a \"v.push_back(2);\" v <<= 3 ; // same as a \"v.push_back(3);\" sstd :: printn ( v ); } Execution result v = [1 2 3]","title":"vector &lt;&lt;= scalar"},{"location":"src/vector/stdVector_expansion.html#vector-vector_2","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { 4 , 5 , 6 }; v1 <<= v2 ; sstd :: printn ( v1 ); sstd :: printn ( v2 ); } Execution result v1 = [1 2 3 4 5 6] v2 = [4 5 6]","title":"vector &lt;&lt;= vector"},{"location":"src/vector/stdVector_expansion.html#linking_1","text":"","title":"Linking &gt;&gt;"},{"location":"src/vector/stdVector_expansion.html#vector-scalar_3","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 }; int s = 0 ; sstd :: printn ( v >> s ); sstd :: printn ( v ); sstd :: printn ( s ); } Execution result v >> s = [0 1 2 3] v = [1 2 3] s = 0","title":"vector &gt;&gt; scalar"},{"location":"src/vector/stdVector_expansion.html#vector-vector_3","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { -2 , -1 , 0 }; sstd :: printn ( v1 >> v2 ); sstd :: printn ( v1 ); sstd :: printn ( v2 ); } Execution result v1 >> v2 = [-2 -1 0 1 2 3] v1 = [1 2 3] v2 = [-2 -1 0]","title":"vector &gt;&gt; vector"},{"location":"src/vector/stdVector_expansion.html#push_front","text":"","title":"push_front()"},{"location":"src/vector/stdVector_expansion.html#vector-scalar_4","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v = { 1 , 2 , 3 }; v >>= 0 ; sstd :: printn ( v ); } Execution result v = [0 1 2 3]","title":"vector &gt;&gt;= scalar"},{"location":"src/vector/stdVector_expansion.html#vector-vector_4","text":"main.cpp #include <sstd/sstd.hpp> int main (){ std :: vector < int > v1 = { 1 , 2 , 3 }; std :: vector < int > v2 = { -2 , -1 , 0 }; v1 >>= v2 ; sstd :: printn ( v1 ); sstd :: printn ( v2 ); } Execution result v1 = [-2 -1 0 1 2 3] v2 = [-2 -1 0]","title":"vector &gt;&gt;= vector"},{"location":"src/vector/stdVector_expansion.html#implementation","text":"Header: sstd/src/vector/stdVector_expansion.hpp Test: test/vector_stdVector_expansion.hpp","title":"Implementation"},{"location":"src/vector/vec_vvec.html","text":"vec / vvec Abstract Type definitions on SSTD. These definitions are read by #include <sstd/sstd.hpp> . SSTD \u306b\u304a\u3051\u308b\u578b\u306e\u5b9a\u7fa9\uff0e #include <sstd/sstd.hpp> \u306b\u3088\u308a\u5b9a\u7fa9\u304c\u8aad\u307f\u8fbc\u307e\u308c\u308b\uff0e Header file namespace sstd { template < class T > using vec = std :: vector < T > ; template < class T > using vvec = std :: vector < std :: vector < T >> ; } Usage main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: vec < int > v = { 1 , 2 , 3 }; // same as a \"std::vector<int> v = {1, 2, 3};\" sstd :: printn ( v ); sstd :: vvec < int > vv = {{ 1 , 2 , 3 }, { 4 , 5 , 6 }}; // same as a \"std::vector<vector<int>> vv = {{1, 2, 3}, {4, 5, 6}};\" sstd :: printn ( vv ); } Execution result v = [1 2 3] vv = [[1 2 3] [4 5 6]] Implementation Header: sstd/src/vector/typeDef.hpp Test: test/vector/typeDef.hpp (Not implemented yet)","title":"vec / vvec"},{"location":"src/vector/vec_vvec.html#vec-vvec","text":"","title":"vec / vvec"},{"location":"src/vector/vec_vvec.html#abstract","text":"Type definitions on SSTD. These definitions are read by #include <sstd/sstd.hpp> . SSTD \u306b\u304a\u3051\u308b\u578b\u306e\u5b9a\u7fa9\uff0e #include <sstd/sstd.hpp> \u306b\u3088\u308a\u5b9a\u7fa9\u304c\u8aad\u307f\u8fbc\u307e\u308c\u308b\uff0e","title":"Abstract"},{"location":"src/vector/vec_vvec.html#header-file","text":"namespace sstd { template < class T > using vec = std :: vector < T > ; template < class T > using vvec = std :: vector < std :: vector < T >> ; }","title":"Header file"},{"location":"src/vector/vec_vvec.html#usage","text":"main.cpp #include <sstd/sstd.hpp> int main (){ sstd :: vec < int > v = { 1 , 2 , 3 }; // same as a \"std::vector<int> v = {1, 2, 3};\" sstd :: printn ( v ); sstd :: vvec < int > vv = {{ 1 , 2 , 3 }, { 4 , 5 , 6 }}; // same as a \"std::vector<vector<int>> vv = {{1, 2, 3}, {4, 5, 6}};\" sstd :: printn ( vv ); } Execution result v = [1 2 3] vv = [[1 2 3] [4 5 6]]","title":"Usage"},{"location":"src/vector/vec_vvec.html#implementation","text":"Header: sstd/src/vector/typeDef.hpp Test: test/vector/typeDef.hpp (Not implemented yet)","title":"Implementation"}]}